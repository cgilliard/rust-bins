/*
 * AUTOGENERATED by mrustc
 */
#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#include <assert.h>
#include <stdatomic.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <setjmp.h>
typedef uint32_t RUST_CHAR;
typedef uint8_t RUST_BOOL;
typedef struct { void* PTR; size_t META; } SLICE_PTR;
typedef struct { void* PTR; void* META; } TRAITOBJ_PTR;
typedef struct { void (*drop)(void*); size_t size; size_t align; } VTABLE_HDR;
typedef struct { char _d; } tUNIT;
typedef char tBANG;
typedef struct { char _d; } tTYPEID;
static inline size_t ALIGN_TO(size_t s, size_t a) { return (s + a-1) / a * a; }

extern void _Unwind_Resume(void) __attribute__((noreturn));
#define ALIGNOF(t) __alignof__(t)
extern __thread jmp_buf*    mrustc_panic_target;
extern __thread void* mrustc_panic_value;
static inline uint64_t __builtin_clz64(uint64_t v) {
	return ( (v >> 32) != 0 ? __builtin_clz(v>>32) : 32 + __builtin_clz(v));
}
static inline uint64_t __builtin_ctz64(uint64_t v) {
	return ((v&0xFFFFFFFF) == 0 ? __builtin_ctz(v>>32) + 32 : __builtin_ctz(v));
}
static inline uint8_t __mrustc_atomicloop8(volatile uint8_t* slot, uint8_t param, int ordering, uint8_t (*cb)(uint8_t, uint8_t)) { int ordering_load = (ordering == memory_order_release || ordering == memory_order_acq_rel ? memory_order_relaxed : ordering); for(;;) { uint8_t v = atomic_load_explicit((_Atomic uint8_t*)slot, ordering_load); if( atomic_compare_exchange_strong_explicit((_Atomic uint8_t*)slot, &v, cb(v, param), ordering, ordering_load) ) return v; }}
static inline uint16_t __mrustc_atomicloop16(volatile uint16_t* slot, uint16_t param, int ordering, uint16_t (*cb)(uint16_t, uint16_t)) { int ordering_load = (ordering == memory_order_release || ordering == memory_order_acq_rel ? memory_order_relaxed : ordering); for(;;) { uint16_t v = atomic_load_explicit((_Atomic uint16_t*)slot, ordering_load); if( atomic_compare_exchange_strong_explicit((_Atomic uint16_t*)slot, &v, cb(v, param), ordering, ordering_load) ) return v; }}
static inline uint32_t __mrustc_atomicloop32(volatile uint32_t* slot, uint32_t param, int ordering, uint32_t (*cb)(uint32_t, uint32_t)) { int ordering_load = (ordering == memory_order_release || ordering == memory_order_acq_rel ? memory_order_relaxed : ordering); for(;;) { uint32_t v = atomic_load_explicit((_Atomic uint32_t*)slot, ordering_load); if( atomic_compare_exchange_strong_explicit((_Atomic uint32_t*)slot, &v, cb(v, param), ordering, ordering_load) ) return v; }}
static inline uint64_t __mrustc_atomicloop64(volatile uint64_t* slot, uint64_t param, int ordering, uint64_t (*cb)(uint64_t, uint64_t)) { int ordering_load = (ordering == memory_order_release || ordering == memory_order_acq_rel ? memory_order_relaxed : ordering); for(;;) { uint64_t v = atomic_load_explicit((_Atomic uint64_t*)slot, ordering_load); if( atomic_compare_exchange_strong_explicit((_Atomic uint64_t*)slot, &v, cb(v, param), ordering, ordering_load) ) return v; }}
typedef struct { uint64_t lo, hi; } uint128_t;
typedef struct { uint64_t lo, hi; } int128_t;
static inline uint128_t intrinsic_ctlz_u128(uint128_t v);
static inline uint128_t shl128(uint128_t a, uint32_t b);
static inline uint128_t shr128(uint128_t a, uint32_t b);
static inline float make_float(int is_neg, int exp, uint32_t mantissa_bits) { float rv; uint32_t vi=(mantissa_bits&((1<<23)-1))|((exp+127)<<23);if(is_neg)vi|=1<<31; memcpy(&rv, &vi, 4); return rv; }
static inline double make_double(int is_neg, int exp, uint32_t mantissa_bits) { double rv; uint64_t vi=(mantissa_bits&((1ull<<52)-1))|((uint64_t)(exp+1023)<<52);if(is_neg)vi|=1ull<<63; memcpy(&rv, &vi, 4); return rv; }
static inline uint128_t make128_raw(uint64_t hi, uint64_t lo) { uint128_t rv = { lo, hi }; return rv; }
static inline uint128_t make128(uint64_t v) { uint128_t rv = { v, 0 }; return rv; }
static inline float cast128_float(uint128_t v) { int n = intrinsic_ctlz_u128(v).lo; uint128_t y = shl128(v, n); uint64_t a = (y.hi >> ((128-(23+1))-64)); uint64_t b = shr128(y, (64-(23+1))).lo | (y.lo & 0xFFFFFFFFFF); uint64_t m = a + ((b - ((b >> 63) & ~a)) >> 63); uint64_t e = (v.lo == 0 && v.hi == 0) ? 0 : (127 - n)+127-1; uint32_t vi = (e << 23) + m; float rv; memcpy(&rv, &vi, sizeof(rv)); return rv; }
static inline double cast128_double(uint128_t v) { int n = intrinsic_ctlz_u128(v).lo; uint128_t y = shl128(v, n); uint64_t a = (y.hi >> ((128-(52+1))-64)); uint64_t b = shr128(y, (64-(52+1))).lo | (y.lo & 0x7FF); uint64_t m = a + ((b - (b >> 63 & ~a)) >> 63); uint64_t e = (v.lo == 0 && v.hi == 0) ? 0 : (127 - n)+1023-1; uint64_t vi = (e << 52) + m; double rv; memcpy(&rv, &vi, sizeof(rv)); return rv; }
static inline int cmp128(uint128_t a, uint128_t b) { if(a.hi != b.hi) return a.hi < b.hi ? -1 : 1; if(a.lo != b.lo) return a.lo < b.lo ? -1 : 1; return 0; }
static inline bool add128_o(uint128_t a, uint128_t b, uint128_t* o) { o->lo = a.lo + b.lo; o->hi = a.hi + b.hi + (o->lo < a.lo ? 1 : 0); return (o->hi < a.hi); }
static inline bool sub128_o(uint128_t a, uint128_t b, uint128_t* o) { o->lo = a.lo - b.lo; o->hi = a.hi - b.hi - (a.lo < b.lo ? 1 : 0); return (o->hi > a.hi); }
static inline bool mul128_o(uint128_t a, uint128_t b, uint128_t* o) { bool of = false; o->hi = 0; o->lo = 0; for(int i=0;i<128;i++){ uint64_t m = (1ull << (i % 64)); if(a.hi==0&&a.lo<m)   break; if(i>=64&&a.hi<m) break; if( m & (i >= 64 ? a.hi : a.lo) ) of |= add128_o(*o, b, o); b.hi = (b.hi << 1) | (b.lo >> 63); b.lo = (b.lo << 1); } return of;}
static inline bool div128_o(uint128_t a, uint128_t b, uint128_t* q, uint128_t* r) { if(a.hi == 0 && b.hi == 0) { if(q) { q->hi=0; q->lo = a.lo / b.lo; } if(r) { r->hi=0; r->lo = a.lo % b.lo; } return false; } if(cmp128(a, b) < 0) { if(q) { q->hi=0; q->lo=0; } if(r) *r = a; return false; } uint128_t a_div_2 = {(a.lo>>1)|(a.hi << 63), a.hi>>1}; int shift = 0; while( cmp128(a_div_2, b) >= 0 && shift < 128 ) { shift += 1; b.hi = (b.hi<<1)|(b.lo>>63); b.lo <<= 1; } if(shift == 128) return true; uint128_t mask = { /*lo=*/(shift >= 64 ? 0 : (1ull << shift)), /*hi=*/(shift < 64 ? 0 : 1ull << (shift-64)) }; shift ++; if(q) { q->hi = 0; q->lo = 0; } while(shift--) { if( cmp128(a, b) >= 0 ) { if(q) add128_o(*q, mask, q); sub128_o(a, b, &a); } mask.lo = (mask.lo >> 1) | (mask.hi << 63); mask.hi >>= 1; b.lo = (b.lo >> 1) | (b.hi << 63); b.hi >>= 1; } if(r) *r = a; return false;}
static inline uint128_t add128(uint128_t a, uint128_t b) { uint128_t v; add128_o(a, b, &v); return v; }
static inline uint128_t sub128(uint128_t a, uint128_t b) { uint128_t v; sub128_o(a, b, &v); return v; }
static inline uint128_t mul128(uint128_t a, uint128_t b) { uint128_t v; mul128_o(a, b, &v); return v; }
static inline uint128_t div128(uint128_t a, uint128_t b) { uint128_t v; div128_o(a, b, &v, NULL); return v; }
static inline uint128_t mod128(uint128_t a, uint128_t b) { uint128_t v; div128_o(a, b, NULL, &v); return v;}
static inline uint128_t and128(uint128_t a, uint128_t b) { uint128_t v = { a.lo & b.lo, a.hi & b.hi }; return v; }
static inline uint128_t or128 (uint128_t a, uint128_t b) { uint128_t v = { a.lo | b.lo, a.hi | b.hi }; return v; }
static inline uint128_t xor128(uint128_t a, uint128_t b) { uint128_t v = { a.lo ^ b.lo, a.hi ^ b.hi }; return v; }
static inline uint128_t shl128(uint128_t a, uint32_t b) { uint128_t v; if(b == 0) { return a; } else if(b < 64) { v.lo = a.lo << b; v.hi = (a.hi << b) | (a.lo >> (64 - b)); } else { v.hi = a.lo << (b - 64); v.lo = 0; } return v; }
static inline uint128_t shr128(uint128_t a, uint32_t b) { uint128_t v; if(b == 0) { return a; } else if(b < 64) { v.lo = (a.lo >> b)|(a.hi << (64 - b)); v.hi = a.hi >> b; } else { v.lo = a.hi >> (b - 64); v.hi = 0; } return v; }
static inline uint128_t popcount128(uint128_t a) { uint128_t v = { __builtin_popcountll(a.lo) + __builtin_popcountll(a.hi), 0 }; return v; }
static inline uint128_t __builtin_bswap128(uint128_t v) { uint128_t rv = { __builtin_bswap64(v.hi), __builtin_bswap64(v.lo) }; return rv; }
static inline uint128_t intrinsic_ctlz_u128(uint128_t v) {
	uint128_t rv = { (v.hi != 0 ? __builtin_clz64(v.hi) : (v.lo != 0 ? 64 + __builtin_clz64(v.lo) : 128)), 0 };
	return rv;
}
static inline uint128_t intrinsic_cttz_u128(uint128_t v) {
	uint128_t rv = { (v.lo == 0 ? (v.hi == 0 ? 128 : __builtin_ctz64(v.hi) + 64) : __builtin_ctz64(v.lo)), 0 };
	return rv;
}
static inline int128_t make128s_raw(uint64_t hi, uint64_t lo) { int128_t rv = { lo, hi }; return rv; }
static inline int128_t make128s(int64_t v) { int128_t rv = { v, (v < 0 ? -1 : 0) }; return rv; }
static inline int128_t neg128s(int128_t v) { int128_t rv = { ~v.lo+1, ~v.hi + (v.lo == 0) }; return rv; }
static inline float cast128s_float(int128_t v) { int sgn = (v.hi >> 63); int128_t abs = sgn ? neg128s(v) : v; return (sgn ? -1.0 : 1.0) * cast128_float(make128_raw(v.hi,v.lo)); }
static inline double cast128s_double(int128_t v) { int sgn = (v.hi >> 63); int128_t abs = sgn ? neg128s(v) : v; return (sgn ? -1.0 : 1.0) * cast128_double(make128_raw(v.hi,v.lo)); }
static inline int cmp128s(int128_t a, int128_t b) { if(a.hi != b.hi) return (int64_t)a.hi < (int64_t)b.hi ? -1 : 1; if(a.lo != b.lo) return a.lo < b.lo ? -1 : 1; return 0; }
static inline bool add128s_o(int128_t a, int128_t b, int128_t* o) { bool sgna=a.hi>>63; bool sgnb=b.hi>>63; add128_o(*(uint128_t*)&a, *(uint128_t*)&b, (uint128_t*)o); bool sgno = o->hi>>63; return (sgna==sgnb && sgno != sgna); }
static inline bool sub128s_o(int128_t a, int128_t b, int128_t* o) { bool sgna=a.hi>>63; bool sgnb=b.hi>>63; sub128_o(*(uint128_t*)&a, *(uint128_t*)&b, (uint128_t*)o); bool sgno = o->hi>>63; return (sgna!=sgnb && sgno != sgna); }
static inline bool mul128s_o(int128_t a, int128_t b, int128_t* o) { bool sgna = (a.hi >> 63); bool sgnb = (b.hi >> 63); if(sgna) a = neg128s(a); if(sgnb) b = neg128s(b); bool rv = mul128_o(*(uint128_t*)&a, *(uint128_t*)&b, (uint128_t*)o); if(sgna != sgnb) *o = neg128s(*o); return rv; }
static inline bool div128s_o(int128_t a, int128_t b, int128_t* q, int128_t* r) { bool sgna = (a.hi >> 63) != 0; bool sgnb = (b.hi >> 63) != 0; if(sgna) a = neg128s(a); if(sgnb) b = neg128s(b); bool rv = div128_o(*(uint128_t*)&a, *(uint128_t*)&b, (uint128_t*)q, (uint128_t*)r); if(sgna != sgnb && q) *q = neg128s(*q); if(sgna && r) *r = neg128s(*r); return rv; }
static inline int128_t add128s(int128_t a, int128_t b) { int128_t v; add128s_o(a, b, &v); return v; }
static inline int128_t sub128s(int128_t a, int128_t b) { int128_t v; sub128s_o(a, b, &v); return v; }
static inline int128_t mul128s(int128_t a, int128_t b) { int128_t v; mul128s_o(a, b, &v); return v; }
static inline int128_t div128s(int128_t a, int128_t b) { int128_t v; div128s_o(a, b, &v, NULL); return v; }
static inline int128_t mod128s(int128_t a, int128_t b) { int128_t v; div128s_o(a, b, NULL, &v); return v; }
static inline int128_t and128s(int128_t a, int128_t b) { int128_t v = { a.lo & b.lo, a.hi & b.hi }; return v; }
static inline int128_t or128s (int128_t a, int128_t b) { int128_t v = { a.lo | b.lo, a.hi | b.hi }; return v; }
static inline int128_t xor128s(int128_t a, int128_t b) { int128_t v = { a.lo ^ b.lo, a.hi ^ b.hi }; return v; }
static inline int128_t shl128s(int128_t a, uint32_t b) { int128_t v; if(b == 0) { return a; } else if(b < 64) { v.lo = a.lo << b; v.hi = (a.hi << b) | (a.lo >> (64 - b)); } else { v.hi = a.lo << (b - 64); v.lo = 0; } return v; }
static inline int128_t shr128s(int128_t a, uint32_t b) { int128_t v; if(b == 0) { return a; } else if(b < 64) { v.lo = (a.lo >> b)|(a.hi << (64 - b)); v.hi = (int64_t)a.hi >> b; } else { v.lo = (int64_t)a.hi >> (b - 64); v.hi = (int64_t)a.hi < 0 ? -1 : 0; } return v; }

static inline int slice_cmp(SLICE_PTR l, SLICE_PTR r) {
	int rv = memcmp(l.PTR, r.PTR, l.META < r.META ? l.META : r.META);
	if(rv != 0) return rv;
	if(l.META < r.META) return -1;
	if(l.META > r.META) return 1;
	return 0;
}
static inline SLICE_PTR make_sliceptr(void* ptr, size_t s) { SLICE_PTR rv = { ptr, s }; return rv; }
static inline TRAITOBJ_PTR make_traitobjptr(void* ptr, void* vt) { TRAITOBJ_PTR rv = { ptr, vt }; return rv; }

static inline size_t mrustc_max(size_t a, size_t b) { return a < b ? b : a; }
static inline void noop_drop(tUNIT *p) { }

static inline size_t mrustc_string_search_linear(SLICE_PTR val, size_t count, SLICE_PTR* options) {
	for(size_t i = 0; i < count; i ++) {
		int cmp = slice_cmp(val, options[i]);
		if(cmp < 0) break;
		if(cmp == 0) return i;
	}
	return SIZE_MAX;
}
static const uint8_t __mrustc_revmap[16] = { 0, 8, 4,12, 2,10, 6,14,  1, 9, 5,13, 3, 7,15};
static inline uint8_t __mrustc_bitrev8(uint8_t v) { if(v==0||v==0xFF) return v; return __mrustc_revmap[v>>4]|(__mrustc_revmap[v&15]<<4); }
static inline uint16_t __mrustc_bitrev16(uint16_t v) { if(v==0) return 0; return ((uint16_t)__mrustc_bitrev8(v>>8))|((uint16_t)__mrustc_bitrev8(v)<<8); }
static inline uint32_t __mrustc_bitrev32(uint32_t v) { if(v==0) return 0; return ((uint32_t)__mrustc_bitrev16(v>>16))|((uint32_t)__mrustc_bitrev16(v)<<16); }
static inline uint64_t __mrustc_bitrev64(uint64_t v) { if(v==0) return 0; return ((uint64_t)__mrustc_bitrev32(v>>32))|((uint64_t)__mrustc_bitrev32(v)<<32); }
static inline uint128_t __mrustc_bitrev128(uint128_t v) { uint128_t rv = { __mrustc_bitrev64(v.hi), __mrustc_bitrev64(v.lo) }; return rv; }
static inline uint8_t __mrustc_op_umax8(uint8_t a, uint8_t b) { return (a > b ? a : b); }
static inline uint8_t __mrustc_op_umin8(uint8_t a, uint8_t b) { return (a < b ? a : b); }
static inline uint8_t __mrustc_op_imax8(uint8_t a, uint8_t b) { return ((int8_t)a > (int8_t)b ? a : b); }
static inline uint8_t __mrustc_op_imin8(uint8_t a, uint8_t b) { return ((int8_t)a < (int8_t)b ? a : b); }
static inline uint8_t __mrustc_op_and_not8(uint8_t a, uint8_t b) { return ~(a & b); }
static inline uint16_t __mrustc_op_umax16(uint16_t a, uint16_t b) { return (a > b ? a : b); }
static inline uint16_t __mrustc_op_umin16(uint16_t a, uint16_t b) { return (a < b ? a : b); }
static inline uint16_t __mrustc_op_imax16(uint16_t a, uint16_t b) { return ((int16_t)a > (int16_t)b ? a : b); }
static inline uint16_t __mrustc_op_imin16(uint16_t a, uint16_t b) { return ((int16_t)a < (int16_t)b ? a : b); }
static inline uint16_t __mrustc_op_and_not16(uint16_t a, uint16_t b) { return ~(a & b); }
static inline uint32_t __mrustc_op_umax32(uint32_t a, uint32_t b) { return (a > b ? a : b); }
static inline uint32_t __mrustc_op_umin32(uint32_t a, uint32_t b) { return (a < b ? a : b); }
static inline uint32_t __mrustc_op_imax32(uint32_t a, uint32_t b) { return ((int32_t)a > (int32_t)b ? a : b); }
static inline uint32_t __mrustc_op_imin32(uint32_t a, uint32_t b) { return ((int32_t)a < (int32_t)b ? a : b); }
static inline uint32_t __mrustc_op_and_not32(uint32_t a, uint32_t b) { return ~(a & b); }
static inline uint64_t __mrustc_op_umax64(uint64_t a, uint64_t b) { return (a > b ? a : b); }
static inline uint64_t __mrustc_op_umin64(uint64_t a, uint64_t b) { return (a < b ? a : b); }
static inline uint64_t __mrustc_op_imax64(uint64_t a, uint64_t b) { return ((int64_t)a > (int64_t)b ? a : b); }
static inline uint64_t __mrustc_op_imin64(uint64_t a, uint64_t b) { return ((int64_t)a < (int64_t)b ? a : b); }
static inline uint64_t __mrustc_op_and_not64(uint64_t a, uint64_t b) { return ~(a & b); }
 // (u128, bool, )
typedef struct TUP_2_ZRTCi_ZRTCw  {
	/*@0*/RUST_BOOL _1; // bool
	/*@8*/uint128_t _0; // u128
} TUP_2_ZRTCi_ZRTCw ;
typedef char sizeof_assert_TUP_2_ZRTCi_ZRTCw [ (sizeof(TUP_2_ZRTCi_ZRTCw ) == 24) ? 1 : -1 ];
 // (i128, bool, )
typedef struct TUP_2_ZRTCj_ZRTCw  {
	/*@0*/RUST_BOOL _1; // bool
	/*@8*/int128_t _0; // i128
} TUP_2_ZRTCj_ZRTCw ;
typedef char sizeof_assert_TUP_2_ZRTCj_ZRTCw [ (sizeof(TUP_2_ZRTCj_ZRTCw ) == 24) ? 1 : -1 ];
// struct ::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmodsi4_0
struct s_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmodsi4_00g  {
	char _d;
} __attribute__((__aligned__(1),)) ;
typedef char alignof_assert_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmodsi4_00g[ (ALIGNOF(struct s_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmodsi4_00g) == 1) ? 1 : -1 ];
// struct ::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmoddi4_1
struct s_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmoddi4_10g  {
	char _d;
} __attribute__((__aligned__(1),)) ;
typedef char alignof_assert_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmoddi4_10g[ (ALIGNOF(struct s_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmoddi4_10g) == 1) ? 1 : -1 ];
// struct ::"core-0_0_0"::option::Option#Some<&'#local0 mut u128,>
struct s_ZRG2cE9core0_0_06optionG10OptionSome1gBuCi  {
	/*@0*/uint128_t *_0; // &'#local0 mut u128
} ;
typedef char sizeof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gBuCi[ (sizeof(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gBuCi) == 8) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gBuCi[ (ALIGNOF(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gBuCi) == 8) ? 1 : -1 ];
// enum ::"core-0_0_0"::option::Option<&'#local0 mut u128,>
struct e_ZRG2cE9core0_0_06option6Option1gBuCi {
	struct {
		struct s_ZRG2cE9core0_0_06optionG10OptionSome1gBuCi var_1;
	} DATA;};
typedef char sizeof_assert_ZRG2cE9core0_0_06option6Option1gBuCi[ (sizeof(struct e_ZRG2cE9core0_0_06option6Option1gBuCi) == 8) ? 1 : -1 ];
// struct ::"core-0_0_0"::option::Option#Some<&'#omitted mut u64,>
struct s_ZRG2cE9core0_0_06optionG10OptionSome1gBuCg  {
	/*@0*/uint64_t *_0; // &'#omitted mut u64
} ;
typedef char sizeof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gBuCg[ (sizeof(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gBuCg) == 8) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gBuCg[ (ALIGNOF(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gBuCg) == 8) ? 1 : -1 ];
// enum ::"core-0_0_0"::option::Option<&'#omitted mut u64,>
struct e_ZRG2cE9core0_0_06option6Option1gBuCg {
	struct {
		struct s_ZRG2cE9core0_0_06optionG10OptionSome1gBuCg var_1;
	} DATA;};
typedef char sizeof_assert_ZRG2cE9core0_0_06option6Option1gBuCg[ (sizeof(struct e_ZRG2cE9core0_0_06option6Option1gBuCg) == 8) ? 1 : -1 ];
// struct ::"core-0_0_0"::option::Option#Some<&'#omitted mut u32,>
struct s_ZRG2cE9core0_0_06optionG10OptionSome1gBuCe  {
	/*@0*/uint32_t *_0; // &'#omitted mut u32
} ;
typedef char sizeof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gBuCe[ (sizeof(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gBuCe) == 8) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gBuCe[ (ALIGNOF(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gBuCe) == 8) ? 1 : -1 ];
// enum ::"core-0_0_0"::option::Option<&'#omitted mut u32,>
struct e_ZRG2cE9core0_0_06option6Option1gBuCe {
	struct {
		struct s_ZRG2cE9core0_0_06optionG10OptionSome1gBuCe var_1;
	} DATA;};
typedef char sizeof_assert_ZRG2cE9core0_0_06option6Option1gBuCe[ (sizeof(struct e_ZRG2cE9core0_0_06option6Option1gBuCe) == 8) ? 1 : -1 ];
 // (i64, bool, )
typedef struct TUP_2_ZRTCh_ZRTCw  {
	/*@0*/RUST_BOOL _1; // bool
	/*@8*/int64_t _0; // i64
} TUP_2_ZRTCh_ZRTCw ;
typedef char sizeof_assert_TUP_2_ZRTCh_ZRTCw [ (sizeof(TUP_2_ZRTCh_ZRTCw ) == 16) ? 1 : -1 ];
 // (i32, bool, )
typedef struct TUP_2_ZRTCf_ZRTCw  {
	/*@0*/RUST_BOOL _1; // bool
	/*@4*/int32_t _0; // i32
} TUP_2_ZRTCf_ZRTCw ;
typedef char sizeof_assert_TUP_2_ZRTCf_ZRTCw [ (sizeof(TUP_2_ZRTCf_ZRTCw ) == 8) ? 1 : -1 ];
// enum ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result
struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g {
	int8_t TAG;
};
typedef char sizeof_assert_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g[ (sizeof(struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g) == 1) ? 1 : -1 ];
// enum ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign
struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g {
	int8_t TAG;
};
typedef char sizeof_assert_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g[ (sizeof(struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g) == 1) ? 1 : -1 ];
 // (bool, u32, )
typedef struct TUP_2_ZRTCw_ZRTCe  {
	/*@0*/RUST_BOOL _0; // bool
	/*@4*/uint32_t _1; // u32
} TUP_2_ZRTCw_ZRTCe ;
typedef char sizeof_assert_TUP_2_ZRTCw_ZRTCe [ (sizeof(TUP_2_ZRTCw_ZRTCe ) == 8) ? 1 : -1 ];
 // (bool, u128, )
typedef struct TUP_2_ZRTCw_ZRTCi  {
	/*@0*/RUST_BOOL _0; // bool
	/*@8*/uint128_t _1; // u128
} TUP_2_ZRTCw_ZRTCi ;
typedef char sizeof_assert_TUP_2_ZRTCw_ZRTCi [ (sizeof(TUP_2_ZRTCw_ZRTCi ) == 24) ? 1 : -1 ];
 // (i32, u32, )
typedef struct TUP_2_ZRTCf_ZRTCe  {
	/*@0*/int32_t _0; // i32
	/*@4*/uint32_t _1; // u32
} TUP_2_ZRTCf_ZRTCe ;
typedef char sizeof_assert_TUP_2_ZRTCf_ZRTCe [ (sizeof(TUP_2_ZRTCf_ZRTCe ) == 8) ? 1 : -1 ];
 // (i32, u64, )
typedef struct TUP_2_ZRTCf_ZRTCg  {
	/*@0*/int32_t _0; // i32
	/*@8*/uint64_t _1; // u64
} TUP_2_ZRTCf_ZRTCg ;
typedef char sizeof_assert_TUP_2_ZRTCf_ZRTCg [ (sizeof(TUP_2_ZRTCf_ZRTCg ) == 16) ? 1 : -1 ];
// struct ::"core-0_0_0"::option::Option#Some<u32,>
struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCe  {
	/*@0*/uint8_t _1; // u8
	/*@4*/uint32_t _0; // u32
} ;
typedef char sizeof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gCe[ (sizeof(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCe) == 8) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gCe[ (ALIGNOF(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCe) == 4) ? 1 : -1 ];
// enum ::"core-0_0_0"::option::Option<u32,>
struct e_ZRG2cE9core0_0_06option6Option1gCe {
	union {
		// ZST: ()
		struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCe var_1;
		uint8_t TAG;
	} DATA;
};
typedef char sizeof_assert_ZRG2cE9core0_0_06option6Option1gCe[ (sizeof(struct e_ZRG2cE9core0_0_06option6Option1gCe) == 8) ? 1 : -1 ];
 // (u32, bool, )
typedef struct TUP_2_ZRTCe_ZRTCw  {
	/*@0*/RUST_BOOL _1; // bool
	/*@4*/uint32_t _0; // u32
} TUP_2_ZRTCe_ZRTCw ;
typedef char sizeof_assert_TUP_2_ZRTCe_ZRTCw [ (sizeof(TUP_2_ZRTCe_ZRTCw ) == 8) ? 1 : -1 ];
// struct ::"core-0_0_0"::option::Option#Some<i32,>
struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCf  {
	/*@0*/uint8_t _1; // u8
	/*@4*/int32_t _0; // i32
} ;
typedef char sizeof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gCf[ (sizeof(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCf) == 8) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gCf[ (ALIGNOF(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCf) == 4) ? 1 : -1 ];
// enum ::"core-0_0_0"::option::Option<i32,>
struct e_ZRG2cE9core0_0_06option6Option1gCf {
	union {
		// ZST: ()
		struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCf var_1;
		uint8_t TAG;
	} DATA;
};
typedef char sizeof_assert_ZRG2cE9core0_0_06option6Option1gCf[ (sizeof(struct e_ZRG2cE9core0_0_06option6Option1gCf) == 8) ? 1 : -1 ];
// struct ::"core-0_0_0"::option::Option#Some<u64,>
struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCg  {
	/*@0*/uint8_t _1; // u8
	/*@8*/uint64_t _0; // u64
} ;
typedef char sizeof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gCg[ (sizeof(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCg) == 16) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gCg[ (ALIGNOF(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCg) == 8) ? 1 : -1 ];
// enum ::"core-0_0_0"::option::Option<u64,>
struct e_ZRG2cE9core0_0_06option6Option1gCg {
	union {
		// ZST: ()
		struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCg var_1;
		uint8_t TAG;
	} DATA;
};
typedef char sizeof_assert_ZRG2cE9core0_0_06option6Option1gCg[ (sizeof(struct e_ZRG2cE9core0_0_06option6Option1gCg) == 16) ? 1 : -1 ];
 // (u64, bool, )
typedef struct TUP_2_ZRTCg_ZRTCw  {
	/*@0*/RUST_BOOL _1; // bool
	/*@8*/uint64_t _0; // u64
} TUP_2_ZRTCg_ZRTCw ;
typedef char sizeof_assert_TUP_2_ZRTCg_ZRTCw [ (sizeof(TUP_2_ZRTCg_ZRTCw ) == 16) ? 1 : -1 ];
 // (bool, u64, )
typedef struct TUP_2_ZRTCw_ZRTCg  {
	/*@0*/RUST_BOOL _0; // bool
	/*@8*/uint64_t _1; // u64
} TUP_2_ZRTCw_ZRTCg ;
typedef char sizeof_assert_TUP_2_ZRTCw_ZRTCg [ (sizeof(TUP_2_ZRTCw_ZRTCg ) == 16) ? 1 : -1 ];
// struct ::"core-0_0_0"::option::Option#Some<i64,>
struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCh  {
	/*@0*/uint8_t _1; // u8
	/*@8*/int64_t _0; // i64
} ;
typedef char sizeof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gCh[ (sizeof(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCh) == 16) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gCh[ (ALIGNOF(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCh) == 8) ? 1 : -1 ];
// enum ::"core-0_0_0"::option::Option<i64,>
struct e_ZRG2cE9core0_0_06option6Option1gCh {
	union {
		// ZST: ()
		struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCh var_1;
		uint8_t TAG;
	} DATA;
};
typedef char sizeof_assert_ZRG2cE9core0_0_06option6Option1gCh[ (sizeof(struct e_ZRG2cE9core0_0_06option6Option1gCh) == 16) ? 1 : -1 ];
// struct ::"core-0_0_0"::option::Option#Some<u128,>
struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCi  {
	/*@0*/uint8_t _1; // u8
	/*@8*/uint128_t _0; // u128
} ;
typedef char sizeof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gCi[ (sizeof(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCi) == 24) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gCi[ (ALIGNOF(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCi) == 8) ? 1 : -1 ];
// enum ::"core-0_0_0"::option::Option<u128,>
struct e_ZRG2cE9core0_0_06option6Option1gCi {
	union {
		// ZST: ()
		struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCi var_1;
		uint8_t TAG;
	} DATA;
};
typedef char sizeof_assert_ZRG2cE9core0_0_06option6Option1gCi[ (sizeof(struct e_ZRG2cE9core0_0_06option6Option1gCi) == 24) ? 1 : -1 ];
// struct ::"core-0_0_0"::option::Option#Some<i128,>
struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCj  {
	/*@0*/uint8_t _1; // u8
	/*@8*/int128_t _0; // i128
} ;
typedef char sizeof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gCj[ (sizeof(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCj) == 24) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gCj[ (ALIGNOF(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCj) == 8) ? 1 : -1 ];
// enum ::"core-0_0_0"::option::Option<i128,>
struct e_ZRG2cE9core0_0_06option6Option1gCj {
	union {
		// ZST: ()
		struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCj var_1;
		uint8_t TAG;
	} DATA;
};
typedef char sizeof_assert_ZRG2cE9core0_0_06option6Option1gCj[ (sizeof(struct e_ZRG2cE9core0_0_06option6Option1gCj) == 24) ? 1 : -1 ];
 // (u32, u32, )
typedef struct TUP_2_ZRTCe_ZRTCe  {
	/*@0*/uint32_t _0; // u32
	/*@4*/uint32_t _1; // u32
} TUP_2_ZRTCe_ZRTCe ;
typedef char sizeof_assert_TUP_2_ZRTCe_ZRTCe [ (sizeof(TUP_2_ZRTCe_ZRTCe ) == 8) ? 1 : -1 ];
 // (u64, u64, )
typedef struct TUP_2_ZRTCg_ZRTCg  {
	/*@0*/uint64_t _0; // u64
	/*@8*/uint64_t _1; // u64
} TUP_2_ZRTCg_ZRTCg ;
typedef char sizeof_assert_TUP_2_ZRTCg_ZRTCg [ (sizeof(TUP_2_ZRTCg_ZRTCg ) == 16) ? 1 : -1 ];
 // (i64, i64, )
typedef struct TUP_2_ZRTCh_ZRTCh  {
	/*@0*/int64_t _0; // i64
	/*@8*/int64_t _1; // i64
} TUP_2_ZRTCh_ZRTCh ;
typedef char sizeof_assert_TUP_2_ZRTCh_ZRTCh [ (sizeof(TUP_2_ZRTCh_ZRTCh ) == 16) ? 1 : -1 ];
 // (i32, i32, )
typedef struct TUP_2_ZRTCf_ZRTCf  {
	/*@0*/int32_t _0; // i32
	/*@4*/int32_t _1; // i32
} TUP_2_ZRTCf_ZRTCf ;
typedef char sizeof_assert_TUP_2_ZRTCf_ZRTCf [ (sizeof(TUP_2_ZRTCf_ZRTCf ) == 8) ? 1 : -1 ];
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::abort
tBANG  ZRG1cR25compiler_builtins0_0_0_Hb5abort0g(void) // -> !
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::add::__adddf3
#define ZRG3cR25compiler_builtins0_0_0_Hb5float3add8__adddf30g __adddf3
double  ZRG3cR25compiler_builtins0_0_0_Hb5float3add8__adddf30g(
		double arg0, // f64
		double arg1 // f64
		) // -> f64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::add::__addsf3
#define ZRG3cR25compiler_builtins0_0_0_Hb5float3add8__addsf30g __addsf3
float  ZRG3cR25compiler_builtins0_0_0_Hb5float3add8__addsf30g(
		float arg0, // f32
		float arg1 // f32
		) // -> f32
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::float::add::add<f32,>
float  ZRG3cR25compiler_builtins0_0_0_Hb5float3add_C1gCn(
		float arg0, // f32
		float arg1 // f32
		) // -> f32
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::float::add::add<f64,>
double  ZRG3cR25compiler_builtins0_0_0_Hb5float3add_C1gCo(
		double arg0, // f64
		double arg1 // f64
		) // -> f64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::cmp::__eqdf2
#define ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__eqdf20g __eqdf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__eqdf20g(
		double arg0, // f64
		double arg1 // f64
		) // -> i32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::cmp::__eqsf2
#define ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__eqsf20g __eqsf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__eqsf20g(
		float arg0, // f32
		float arg1 // f32
		) // -> i32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::cmp::__gedf2
#define ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__gedf20g __gedf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__gedf20g(
		double arg0, // f64
		double arg1 // f64
		) // -> i32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::cmp::__gesf2
#define ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__gesf20g __gesf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__gesf20g(
		float arg0, // f32
		float arg1 // f32
		) // -> i32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::cmp::__gtdf2
#define ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__gtdf20g __gtdf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__gtdf20g(
		double arg0, // f64
		double arg1 // f64
		) // -> i32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::cmp::__gtsf2
#define ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__gtsf20g __gtsf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__gtsf20g(
		float arg0, // f32
		float arg1 // f32
		) // -> i32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::cmp::__ledf2
#define ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__ledf20g __ledf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__ledf20g(
		double arg0, // f64
		double arg1 // f64
		) // -> i32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::cmp::__lesf2
#define ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__lesf20g __lesf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__lesf20g(
		float arg0, // f32
		float arg1 // f32
		) // -> i32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::cmp::__ltdf2
#define ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__ltdf20g __ltdf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__ltdf20g(
		double arg0, // f64
		double arg1 // f64
		) // -> i32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::cmp::__ltsf2
#define ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__ltsf20g __ltsf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__ltsf20g(
		float arg0, // f32
		float arg1 // f32
		) // -> i32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::cmp::__nedf2
#define ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__nedf20g __nedf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__nedf20g(
		double arg0, // f64
		double arg1 // f64
		) // -> i32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::cmp::__nesf2
#define ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__nesf20g __nesf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__nesf20g(
		float arg0, // f32
		float arg1 // f32
		) // -> i32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::cmp::__unorddf2
#define ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp10__unorddf20g __unorddf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp10__unorddf20g(
		double arg0, // f64
		double arg1 // f64
		) // -> i32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::cmp::__unordsf2
#define ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp10__unordsf20g __unordsf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp10__unordsf20g(
		float arg0, // f32
		float arg1 // f32
		) // -> i32
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::float::cmp::cmp<f32,>
struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp_C1gCn(
		float arg0, // f32
		float arg1 // f32
		) // -> ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::float::cmp::cmp<f64,>
struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp_C1gCo(
		double arg0, // f64
		double arg1 // f64
		) // -> ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::float::cmp::unord<f32,>
RUST_BOOL  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp5unord1gCn(
		float arg0, // f32
		float arg1 // f32
		) // -> bool
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::float::cmp::unord<f64,>
RUST_BOOL  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp5unord1gCo(
		double arg0, // f64
		double arg1 // f64
		) // -> bool
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::conv::__fixdfdi
#define ZRG3cR25compiler_builtins0_0_0_Hb5float4conv9__fixdfdi0g __fixdfdi
int64_t  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv9__fixdfdi0g(
		double arg0 // f64
		) // -> i64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::conv::__fixdfsi
#define ZRG3cR25compiler_builtins0_0_0_Hb5float4conv9__fixdfsi0g __fixdfsi
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv9__fixdfsi0g(
		double arg0 // f64
		) // -> i32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::conv::__fixdfti
#define ZRG3cR25compiler_builtins0_0_0_Hb5float4conv9__fixdfti0g __fixdfti
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv9__fixdfti0g(
		double arg0 // f64
		) // -> i128
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::conv::__fixsfdi
#define ZRG3cR25compiler_builtins0_0_0_Hb5float4conv9__fixsfdi0g __fixsfdi
int64_t  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv9__fixsfdi0g(
		float arg0 // f32
		) // -> i64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::conv::__fixsfsi
#define ZRG3cR25compiler_builtins0_0_0_Hb5float4conv9__fixsfsi0g __fixsfsi
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv9__fixsfsi0g(
		float arg0 // f32
		) // -> i32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::conv::__fixsfti
#define ZRG3cR25compiler_builtins0_0_0_Hb5float4conv9__fixsfti0g __fixsfti
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv9__fixsfti0g(
		float arg0 // f32
		) // -> i128
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::conv::__fixunsdfdi
#define ZRG3cR25compiler_builtins0_0_0_Hb5float4conv12__fixunsdfdi0g __fixunsdfdi
uint64_t  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv12__fixunsdfdi0g(
		double arg0 // f64
		) // -> u64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::conv::__fixunsdfsi
#define ZRG3cR25compiler_builtins0_0_0_Hb5float4conv12__fixunsdfsi0g __fixunsdfsi
uint32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv12__fixunsdfsi0g(
		double arg0 // f64
		) // -> u32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::conv::__fixunsdfti
#define ZRG3cR25compiler_builtins0_0_0_Hb5float4conv12__fixunsdfti0g __fixunsdfti
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv12__fixunsdfti0g(
		double arg0 // f64
		) // -> u128
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::conv::__fixunssfdi
#define ZRG3cR25compiler_builtins0_0_0_Hb5float4conv12__fixunssfdi0g __fixunssfdi
uint64_t  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv12__fixunssfdi0g(
		float arg0 // f32
		) // -> u64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::conv::__fixunssfsi
#define ZRG3cR25compiler_builtins0_0_0_Hb5float4conv12__fixunssfsi0g __fixunssfsi
uint32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv12__fixunssfsi0g(
		float arg0 // f32
		) // -> u32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::conv::__fixunssfti
#define ZRG3cR25compiler_builtins0_0_0_Hb5float4conv12__fixunssfti0g __fixunssfti
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv12__fixunssfti0g(
		float arg0 // f32
		) // -> u128
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::conv::__floatdidf
#define ZRG3cR25compiler_builtins0_0_0_Hb5float4conv11__floatdidf0g __floatdidf
double  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv11__floatdidf0g(
		int64_t arg0 // i64
		) // -> f64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::conv::__floatdisf
#define ZRG3cR25compiler_builtins0_0_0_Hb5float4conv11__floatdisf0g __floatdisf
float  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv11__floatdisf0g(
		int64_t arg0 // i64
		) // -> f32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::conv::__floatsidf
#define ZRG3cR25compiler_builtins0_0_0_Hb5float4conv11__floatsidf0g __floatsidf
double  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv11__floatsidf0g(
		int32_t arg0 // i32
		) // -> f64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::conv::__floatsisf
#define ZRG3cR25compiler_builtins0_0_0_Hb5float4conv11__floatsisf0g __floatsisf
float  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv11__floatsisf0g(
		int32_t arg0 // i32
		) // -> f32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::conv::__floattidf
#define ZRG3cR25compiler_builtins0_0_0_Hb5float4conv11__floattidf0g __floattidf
double  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv11__floattidf0g(
		int128_t arg0 // i128
		) // -> f64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::conv::__floattisf
#define ZRG3cR25compiler_builtins0_0_0_Hb5float4conv11__floattisf0g __floattisf
float  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv11__floattisf0g(
		int128_t arg0 // i128
		) // -> f32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::conv::__floatundidf
#define ZRG3cR25compiler_builtins0_0_0_Hb5float4conv13__floatundidf0g __floatundidf
double  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv13__floatundidf0g(
		uint64_t arg0 // u64
		) // -> f64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::conv::__floatundisf
#define ZRG3cR25compiler_builtins0_0_0_Hb5float4conv13__floatundisf0g __floatundisf
float  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv13__floatundisf0g(
		uint64_t arg0 // u64
		) // -> f32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::conv::__floatunsidf
#define ZRG3cR25compiler_builtins0_0_0_Hb5float4conv13__floatunsidf0g __floatunsidf
double  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv13__floatunsidf0g(
		uint32_t arg0 // u32
		) // -> f64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::conv::__floatunsisf
#define ZRG3cR25compiler_builtins0_0_0_Hb5float4conv13__floatunsisf0g __floatunsisf
float  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv13__floatunsisf0g(
		uint32_t arg0 // u32
		) // -> f32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::conv::__floatuntidf
#define ZRG3cR25compiler_builtins0_0_0_Hb5float4conv13__floatuntidf0g __floatuntidf
double  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv13__floatuntidf0g(
		uint128_t arg0 // u128
		) // -> f64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::conv::__floatuntisf
#define ZRG3cR25compiler_builtins0_0_0_Hb5float4conv13__floatuntisf0g __floatuntisf
float  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv13__floatuntisf0g(
		uint128_t arg0 // u128
		) // -> f32
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::float::div::#0::negate_u32
uint32_t  ZRG4cR25compiler_builtins0_0_0_Hb5float3divB_010negate_u320g(
		uint32_t arg0 // u32
		) // -> u32
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::float::div::#1::negate_u32
uint32_t  ZRG4cR25compiler_builtins0_0_0_Hb5float3divB_110negate_u320g(
		uint32_t arg0 // u32
		) // -> u32
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::float::div::#1::negate_u64
uint64_t  ZRG4cR25compiler_builtins0_0_0_Hb5float3divB_110negate_u640g(
		uint64_t arg0 // u64
		) // -> u64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::div::__divdf3
#define ZRG3cR25compiler_builtins0_0_0_Hb5float3div8__divdf30g __divdf3
double  ZRG3cR25compiler_builtins0_0_0_Hb5float3div8__divdf30g(
		double arg0, // f64
		double arg1 // f64
		) // -> f64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::div::__divsf3
#define ZRG3cR25compiler_builtins0_0_0_Hb5float3div8__divsf30g __divsf3
float  ZRG3cR25compiler_builtins0_0_0_Hb5float3div8__divsf30g(
		float arg0, // f32
		float arg1 // f32
		) // -> f32
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::float::div::div32<f32,>
float  ZRG3cR25compiler_builtins0_0_0_Hb5float3div5div321gCn(
		float arg0, // f32
		float arg1 // f32
		) // -> f32
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::float::div::div64<f64,>
double  ZRG3cR25compiler_builtins0_0_0_Hb5float3div5div641gCo(
		double arg0, // f64
		double arg1 // f64
		) // -> f64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::extend::__extendsfdf2
#define ZRG3cR25compiler_builtins0_0_0_Hb5float6extend13__extendsfdf20g __extendsfdf2
double  ZRG3cR25compiler_builtins0_0_0_Hb5float6extend13__extendsfdf20g(
		float arg0 // f32
		) // -> f64
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::float::extend::extend<f32,f64,>
double  ZRG3cR25compiler_builtins0_0_0_Hb5float6extend_C2gCnCo(
		float arg0 // f32
		) // -> f64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::mul::__muldf3
#define ZRG3cR25compiler_builtins0_0_0_Hb5float3mul8__muldf30g __muldf3
double  ZRG3cR25compiler_builtins0_0_0_Hb5float3mul8__muldf30g(
		double arg0, // f64
		double arg1 // f64
		) // -> f64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::mul::__mulsf3
#define ZRG3cR25compiler_builtins0_0_0_Hb5float3mul8__mulsf30g __mulsf3
float  ZRG3cR25compiler_builtins0_0_0_Hb5float3mul8__mulsf30g(
		float arg0, // f32
		float arg1 // f32
		) // -> f32
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::float::mul::mul<f32,>
float  ZRG3cR25compiler_builtins0_0_0_Hb5float3mul_C1gCn(
		float arg0, // f32
		float arg1 // f32
		) // -> f32
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::float::mul::mul<f64,>
double  ZRG3cR25compiler_builtins0_0_0_Hb5float3mul_C1gCo(
		double arg0, // f64
		double arg1 // f64
		) // -> f64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::pow::__powidf2
#define ZRG3cR25compiler_builtins0_0_0_Hb5float3pow9__powidf20g __powidf2
double  ZRG3cR25compiler_builtins0_0_0_Hb5float3pow9__powidf20g(
		double arg0, // f64
		int32_t arg1 // i32
		) // -> f64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::pow::__powisf2
#define ZRG3cR25compiler_builtins0_0_0_Hb5float3pow9__powisf20g __powisf2
float  ZRG3cR25compiler_builtins0_0_0_Hb5float3pow9__powisf20g(
		float arg0, // f32
		int32_t arg1 // i32
		) // -> f32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::sub::__subdf3
#define ZRG3cR25compiler_builtins0_0_0_Hb5float3sub8__subdf30g __subdf3
double  ZRG3cR25compiler_builtins0_0_0_Hb5float3sub8__subdf30g(
		double arg0, // f64
		double arg1 // f64
		) // -> f64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::float::sub::__subsf3
#define ZRG3cR25compiler_builtins0_0_0_Hb5float3sub8__subsf30g __subsf3
float  ZRG3cR25compiler_builtins0_0_0_Hb5float3sub8__subsf30g(
		float arg0, // f32
		float arg1 // f32
		) // -> f32
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::addsub::rust_i128_add
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int6addsub13rust_i128_add0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::addsub::rust_i128_addo
TUP_2_ZRTCj_ZRTCw  ZRG3cR25compiler_builtins0_0_0_Hb3int6addsub14rust_i128_addo0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> (i128, bool, )
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::addsub::rust_i128_sub
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int6addsub13rust_i128_sub0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::addsub::rust_i128_subo
TUP_2_ZRTCj_ZRTCw  ZRG3cR25compiler_builtins0_0_0_Hb3int6addsub14rust_i128_subo0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> (i128, bool, )
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::addsub::rust_u128_add
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int6addsub13rust_u128_add0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::addsub::rust_u128_addo
TUP_2_ZRTCi_ZRTCw  ZRG3cR25compiler_builtins0_0_0_Hb3int6addsub14rust_u128_addo0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> (u128, bool, )
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::addsub::rust_u128_sub
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int6addsub13rust_u128_sub0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::addsub::rust_u128_subo
TUP_2_ZRTCi_ZRTCw  ZRG3cR25compiler_builtins0_0_0_Hb3int6addsub14rust_u128_subo0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> (u128, bool, )
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::mul::__muldi3
#define ZRG3cR25compiler_builtins0_0_0_Hb3int3mul8__muldi30g __muldi3
uint64_t  ZRG3cR25compiler_builtins0_0_0_Hb3int3mul8__muldi30g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::mul::__mulodi4
#define ZRG3cR25compiler_builtins0_0_0_Hb3int3mul9__mulodi40g __mulodi4
int64_t  ZRG3cR25compiler_builtins0_0_0_Hb3int3mul9__mulodi40g(
		int64_t arg0, // i64
		int64_t arg1, // i64
		int32_t *arg2 // &'#omitted mut i32
		) // -> i64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::mul::__mulosi4
#define ZRG3cR25compiler_builtins0_0_0_Hb3int3mul9__mulosi40g __mulosi4
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb3int3mul9__mulosi40g(
		int32_t arg0, // i32
		int32_t arg1, // i32
		int32_t *arg2 // &'#omitted mut i32
		) // -> i32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::mul::__muloti4
#define ZRG3cR25compiler_builtins0_0_0_Hb3int3mul9__muloti40g __muloti4
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int3mul9__muloti40g(
		int128_t arg0, // i128
		int128_t arg1, // i128
		int32_t *arg2 // &'#omitted mut i32
		) // -> i128
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::mul::__multi3
#define ZRG3cR25compiler_builtins0_0_0_Hb3int3mul8__multi30g __multi3
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int3mul8__multi30g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::mul::rust_i128_mul
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int3mul13rust_i128_mul0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::mul::rust_i128_mulo
TUP_2_ZRTCj_ZRTCw  ZRG3cR25compiler_builtins0_0_0_Hb3int3mul14rust_i128_mulo0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> (i128, bool, )
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::mul::rust_u128_mul
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int3mul13rust_u128_mul0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::mul::rust_u128_mulo
TUP_2_ZRTCi_ZRTCw  ZRG3cR25compiler_builtins0_0_0_Hb3int3mul14rust_u128_mulo0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> (u128, bool, )
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::sdiv::__divdi3
#define ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv8__divdi30g __divdi3
int64_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv8__divdi30g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::sdiv::__divmoddi4
#define ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv11__divmoddi40g __divmoddi4
int64_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv11__divmoddi40g(
		int64_t arg0, // i64
		int64_t arg1, // i64
		int64_t *arg2 // &'#omitted mut i64
		) // -> i64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::sdiv::__divmodsi4
#define ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv11__divmodsi40g __divmodsi4
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv11__divmodsi40g(
		int32_t arg0, // i32
		int32_t arg1, // i32
		int32_t *arg2 // &'#omitted mut i32
		) // -> i32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::sdiv::__divsi3
#define ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv8__divsi30g __divsi3
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv8__divsi30g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::sdiv::__divti3
#define ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv8__divti30g __divti3
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv8__divti30g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::sdiv::__moddi3
#define ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv8__moddi30g __moddi3
int64_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv8__moddi30g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::sdiv::__modsi3
#define ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv8__modsi30g __modsi3
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv8__modsi30g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::sdiv::__modti3
#define ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv8__modti30g __modti3
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv8__modti30g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::sdiv::rust_i128_div
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv13rust_i128_div0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::sdiv::rust_i128_rem
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv13rust_i128_rem0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::shift::__ashldi3
#define ZRG3cR25compiler_builtins0_0_0_Hb3int5shift9__ashldi30g __ashldi3
uint64_t  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift9__ashldi30g(
		uint64_t arg0, // u64
		uint32_t arg1 // u32
		) // -> u64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::shift::__ashlti3
#define ZRG3cR25compiler_builtins0_0_0_Hb3int5shift9__ashlti30g __ashlti3
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift9__ashlti30g(
		uint128_t arg0, // u128
		uint32_t arg1 // u32
		) // -> u128
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::shift::__ashrdi3
#define ZRG3cR25compiler_builtins0_0_0_Hb3int5shift9__ashrdi30g __ashrdi3
int64_t  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift9__ashrdi30g(
		int64_t arg0, // i64
		uint32_t arg1 // u32
		) // -> i64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::shift::__ashrti3
#define ZRG3cR25compiler_builtins0_0_0_Hb3int5shift9__ashrti30g __ashrti3
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift9__ashrti30g(
		int128_t arg0, // i128
		uint32_t arg1 // u32
		) // -> i128
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::shift::__lshrdi3
#define ZRG3cR25compiler_builtins0_0_0_Hb3int5shift9__lshrdi30g __lshrdi3
uint64_t  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift9__lshrdi30g(
		uint64_t arg0, // u64
		uint32_t arg1 // u32
		) // -> u64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::shift::__lshrti3
#define ZRG3cR25compiler_builtins0_0_0_Hb3int5shift9__lshrti30g __lshrti3
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift9__lshrti30g(
		uint128_t arg0, // u128
		uint32_t arg1 // u32
		) // -> u128
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::shift::rust_i128_shl
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift13rust_i128_shl0g(
		int128_t arg0, // i128
		uint32_t arg1 // u32
		) // -> i128
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::shift::rust_i128_shlo
TUP_2_ZRTCj_ZRTCw  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift14rust_i128_shlo0g(
		int128_t arg0, // i128
		uint128_t arg1 // u128
		) // -> (i128, bool, )
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::shift::rust_i128_shr
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift13rust_i128_shr0g(
		int128_t arg0, // i128
		uint32_t arg1 // u32
		) // -> i128
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::shift::rust_i128_shro
TUP_2_ZRTCj_ZRTCw  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift14rust_i128_shro0g(
		int128_t arg0, // i128
		uint128_t arg1 // u128
		) // -> (i128, bool, )
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::shift::rust_u128_shl
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift13rust_u128_shl0g(
		uint128_t arg0, // u128
		uint32_t arg1 // u32
		) // -> u128
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::shift::rust_u128_shlo
TUP_2_ZRTCi_ZRTCw  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift14rust_u128_shlo0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> (u128, bool, )
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::shift::rust_u128_shr
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift13rust_u128_shr0g(
		uint128_t arg0, // u128
		uint32_t arg1 // u32
		) // -> u128
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::shift::rust_u128_shro
TUP_2_ZRTCi_ZRTCw  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift14rust_u128_shro0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> (u128, bool, )
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::udiv::__udivdi3
#define ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv9__udivdi30g __udivdi3
uint64_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv9__udivdi30g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::udiv::__udivmoddi4
#define ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv12__udivmoddi40g __udivmoddi4
uint64_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv12__udivmoddi40g(
		uint64_t arg0, // u64
		uint64_t arg1, // u64
		struct e_ZRG2cE9core0_0_06option6Option1gBuCg arg2 // ::"core-0_0_0"::option::Option<&'#omitted mut u64,>/*E*/
		) // -> u64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::udiv::__udivmodsi4
#define ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv12__udivmodsi40g __udivmodsi4
uint32_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv12__udivmodsi40g(
		uint32_t arg0, // u32
		uint32_t arg1, // u32
		struct e_ZRG2cE9core0_0_06option6Option1gBuCe arg2 // ::"core-0_0_0"::option::Option<&'#omitted mut u32,>/*E*/
		) // -> u32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::udiv::__udivmodti4
#define ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv12__udivmodti40g __udivmodti4
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv12__udivmodti40g(
		uint128_t arg0, // u128
		uint128_t arg1, // u128
		struct e_ZRG2cE9core0_0_06option6Option1gBuCi arg2 // ::"core-0_0_0"::option::Option<&'#omitted mut u128,>/*E*/
		) // -> u128
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::udiv::__udivsi3
#define ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv9__udivsi30g __udivsi3
uint32_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv9__udivsi30g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::udiv::__udivti3
#define ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv9__udivti30g __udivti3
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv9__udivti30g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::udiv::__umoddi3
#define ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv9__umoddi30g __umoddi3
uint64_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv9__umoddi30g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::udiv::__umodsi3
#define ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv9__umodsi30g __umodsi3
uint32_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv9__umodsi30g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::int::udiv::__umodti3
#define ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv9__umodti30g __umodti3
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv9__umodti30g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::udiv::rust_u128_div
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv13rust_u128_div0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::udiv::rust_u128_rem
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv13rust_u128_rem0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::unwrap<u32,>
uint32_t  ZRG2cR25compiler_builtins0_0_0_Hb3int6unwrap1gCe(
		struct e_ZRG2cE9core0_0_06option6Option1gCe arg0 // ::"core-0_0_0"::option::Option<u32,>/*E*/
		) // -> u32
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::unwrap<i32,>
int32_t  ZRG2cR25compiler_builtins0_0_0_Hb3int6unwrap1gCf(
		struct e_ZRG2cE9core0_0_06option6Option1gCf arg0 // ::"core-0_0_0"::option::Option<i32,>/*E*/
		) // -> i32
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::unwrap<u64,>
uint64_t  ZRG2cR25compiler_builtins0_0_0_Hb3int6unwrap1gCg(
		struct e_ZRG2cE9core0_0_06option6Option1gCg arg0 // ::"core-0_0_0"::option::Option<u64,>/*E*/
		) // -> u64
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::unwrap<i64,>
int64_t  ZRG2cR25compiler_builtins0_0_0_Hb3int6unwrap1gCh(
		struct e_ZRG2cE9core0_0_06option6Option1gCh arg0 // ::"core-0_0_0"::option::Option<i64,>/*E*/
		) // -> i64
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::unwrap<u128,>
uint128_t  ZRG2cR25compiler_builtins0_0_0_Hb3int6unwrap1gCi(
		struct e_ZRG2cE9core0_0_06option6Option1gCi arg0 // ::"core-0_0_0"::option::Option<u128,>/*E*/
		) // -> u128
;
// PROTO extern "Rust" ::"compiler_builtins-0_0_0_Hb"::int::unwrap<i128,>
int128_t  ZRG2cR25compiler_builtins0_0_0_Hb3int6unwrap1gCj(
		struct e_ZRG2cE9core0_0_06option6Option1gCj arg0 // ::"core-0_0_0"::option::Option<i128,>/*E*/
		) // -> i128
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::mem::memcmp
int32_t  ZRG2cR25compiler_builtins0_0_0_Hb3mem6memcmp0g(
		uint8_t *arg0, // *const u8
		uint8_t *arg1, // *const u8
		uintptr_t arg2 // usize
		) // -> i32
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::mem::memcpy
uint8_t * ZRG2cR25compiler_builtins0_0_0_Hb3mem6memcpy0g(
		uint8_t *arg0, // *mut u8
		uint8_t *arg1, // *const u8
		uintptr_t arg2 // usize
		) // -> *mut u8
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::mem::memmove
uint8_t * ZRG2cR25compiler_builtins0_0_0_Hb3mem7memmove0g(
		uint8_t *arg0, // *mut u8
		uint8_t *arg1, // *const u8
		uintptr_t arg2 // usize
		) // -> *mut u8
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::mem::memset
uint8_t * ZRG2cR25compiler_builtins0_0_0_Hb3mem6memset0g(
		uint8_t *arg0, // *mut u8
		int32_t arg1, // i32
		uintptr_t arg2 // usize
		) // -> *mut u8
;
// PROTO extern "C" ::"compiler_builtins-0_0_0_Hb"::probestack::__rust_probestack
#define ZRG2cR25compiler_builtins0_0_0_Hb10probestack17__rust_probestack0g __rust_probestack
void  ZRG2cR25compiler_builtins0_0_0_Hb10probestack17__rust_probestack0g(void) // -> ()
;
// PROTO extern "Rust" <u32 /*- */>::checked_div
static struct e_ZRG2cE9core0_0_06option6Option1gCe  ZRICe11checked_div0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> ::"core-0_0_0"::option::Option<u32,>/*E*/
;
// PROTO extern "Rust" <u32 /*- */>::checked_rem
static struct e_ZRG2cE9core0_0_06option6Option1gCe  ZRICe11checked_rem0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> ::"core-0_0_0"::option::Option<u32,>/*E*/
;
// PROTO extern "Rust" <u32 /*- */>::is_power_of_two
static RUST_BOOL  ZRICe15is_power_of_two0g(
		uint32_t arg0 // u32
		) // -> bool
;
// PROTO extern "Rust" <i32 /*- */>::checked_div
static struct e_ZRG2cE9core0_0_06option6Option1gCf  ZRICf11checked_div0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> ::"core-0_0_0"::option::Option<i32,>/*E*/
;
// PROTO extern "Rust" <i32 /*- */>::checked_rem
static struct e_ZRG2cE9core0_0_06option6Option1gCf  ZRICf11checked_rem0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> ::"core-0_0_0"::option::Option<i32,>/*E*/
;
// PROTO extern "Rust" <i32 /*- */>::overflowing_neg
static TUP_2_ZRTCf_ZRTCw  ZRICf15overflowing_neg0g(
		int32_t arg0 // i32
		) // -> (i32, bool, )
;
// PROTO extern "Rust" <u64 /*- */>::checked_div
static struct e_ZRG2cE9core0_0_06option6Option1gCg  ZRICg11checked_div0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> ::"core-0_0_0"::option::Option<u64,>/*E*/
;
// PROTO extern "Rust" <u64 /*- */>::checked_rem
static struct e_ZRG2cE9core0_0_06option6Option1gCg  ZRICg11checked_rem0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> ::"core-0_0_0"::option::Option<u64,>/*E*/
;
// PROTO extern "Rust" <u64 /*- */>::is_power_of_two
static RUST_BOOL  ZRICg15is_power_of_two0g(
		uint64_t arg0 // u64
		) // -> bool
;
// PROTO extern "Rust" <i64 /*- */>::checked_div
static struct e_ZRG2cE9core0_0_06option6Option1gCh  ZRICh11checked_div0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> ::"core-0_0_0"::option::Option<i64,>/*E*/
;
// PROTO extern "Rust" <i64 /*- */>::checked_rem
static struct e_ZRG2cE9core0_0_06option6Option1gCh  ZRICh11checked_rem0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> ::"core-0_0_0"::option::Option<i64,>/*E*/
;
// PROTO extern "Rust" <i64 /*- */>::overflowing_neg
static TUP_2_ZRTCh_ZRTCw  ZRICh15overflowing_neg0g(
		int64_t arg0 // i64
		) // -> (i64, bool, )
;
// PROTO extern "Rust" <u128 /*- */>::checked_div
static struct e_ZRG2cE9core0_0_06option6Option1gCi  ZRICi11checked_div0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> ::"core-0_0_0"::option::Option<u128,>/*E*/
;
// PROTO extern "Rust" <u128 /*- */>::checked_rem
static struct e_ZRG2cE9core0_0_06option6Option1gCi  ZRICi11checked_rem0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> ::"core-0_0_0"::option::Option<u128,>/*E*/
;
// PROTO extern "Rust" <i128 /*- */>::checked_div
static struct e_ZRG2cE9core0_0_06option6Option1gCj  ZRICj11checked_div0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> ::"core-0_0_0"::option::Option<i128,>/*E*/
;
// PROTO extern "Rust" <i128 /*- */>::checked_rem
static struct e_ZRG2cE9core0_0_06option6Option1gCj  ZRICj11checked_rem0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> ::"core-0_0_0"::option::Option<i128,>/*E*/
;
// PROTO extern "Rust" <::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/ /*- */>::to_ge_abi
int32_t  ZRIG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g9to_ge_abi0g(
		struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g arg0 // ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
		) // -> i32
;
// PROTO extern "Rust" <::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/ /*- */>::to_le_abi
int32_t  ZRIG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g9to_le_abi0g(
		struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g arg0 // ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
		) // -> i32
;
// PROTO extern "Rust" <::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmoddi4_1/*S*/ /*- */>::call_free
int64_t  ZRIG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmoddi4_10g9call_free0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64
;
// PROTO extern "Rust" <::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmodsi4_0/*S*/ /*- */>::call_free
int32_t  ZRIG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmodsi4_00g9call_free0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<usize,>>::cast
uintptr_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCu4cast0g(
		uint32_t arg0 // u32
		) // -> usize
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<isize,>>::cast
intptr_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCv4cast0g(
		uint32_t arg0 // u32
		) // -> isize
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u32,>>::cast
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCe4cast0g(
		uint32_t arg0 // u32
		) // -> u32
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i32,>>::cast
int32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCf4cast0g(
		uint32_t arg0 // u32
		) // -> i32
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u64,>>::cast
uint64_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCg4cast0g(
		uint32_t arg0 // u32
		) // -> u64
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i64,>>::cast
int64_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCh4cast0g(
		uint32_t arg0 // u32
		) // -> i64
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u128,>>::cast
uint128_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCi4cast0g(
		uint32_t arg0 // u32
		) // -> u128
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i128,>>::cast
int128_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCj4cast0g(
		uint32_t arg0 // u32
		) // -> i128
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_rem
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_rem0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::extract_sign
TUP_2_ZRTCw_ZRTCe  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g12extract_sign0g(
		uint32_t arg0 // u32
		) // -> (bool, u32, )
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::from_bool
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g9from_bool0g(
		RUST_BOOL arg0 // bool
		) // -> u32
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::from_unsigned
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g13from_unsigned0g(
		uint32_t arg0 // u32
		) // -> u32
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::leading_zeros
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g13leading_zeros0g(
		uint32_t arg0 // u32
		) // -> u32
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::max_value
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g9max_value0g(void) // -> u32
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::min_value
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g9min_value0g(void) // -> u32
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::overflowing_add
TUP_2_ZRTCe_ZRTCw  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g15overflowing_add0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> (u32, bool, )
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::unsigned
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g8unsigned0g(
		uint32_t arg0 // u32
		) // -> u32
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_add
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_add0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_mul
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_mul0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_shl
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_shl0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_sub
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_sub0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::WideInt>::wide_mul
TUP_2_ZRTCe_ZRTCe  ZRQCe2cR25compiler_builtins0_0_0_Hb3int7WideInt0g8wide_mul0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> (u32, u32, )
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::WideInt>::wide_shift_left<'#omitted,'#omitted,>
void  ZRQCe2cR25compiler_builtins0_0_0_Hb3int7WideInt0g15wide_shift_left0g(
		uint32_t *arg0, // &'#omitted mut u32
		uint32_t *arg1, // &'#omitted mut u32
		int32_t arg2 // i32
		) // -> ()
;
// PROTO extern "Rust" <u32 as ::"compiler_builtins-0_0_0_Hb"::int::WideInt>::wide_shift_right_with_sticky<'#omitted,'#omitted,>
void  ZRQCe2cR25compiler_builtins0_0_0_Hb3int7WideInt0g28wide_shift_right_with_sticky0g(
		uint32_t *arg0, // &'#omitted mut u32
		uint32_t *arg1, // &'#omitted mut u32
		int32_t arg2 // i32
		) // -> ()
;
// PROTO extern "Rust" <u32 as ::"core-0_0_0"::cmp::PartialEq<u32,>>::eq<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCe2cE9core0_0_03cmp9PartialEq1gCe2eq0g(
		uint32_t *arg0, // &'#omitted u32
		uint32_t *arg1 // &'#omitted u32
		) // -> bool
;
// PROTO extern "Rust" <u32 as ::"core-0_0_0"::cmp::PartialEq<u32,>>::ne<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCe2cE9core0_0_03cmp9PartialEq1gCe2ne0g(
		uint32_t *arg0, // &'#omitted u32
		uint32_t *arg1 // &'#omitted u32
		) // -> bool
;
// PROTO extern "Rust" <u32 as ::"core-0_0_0"::cmp::PartialOrd<u32,>>::ge<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCe2cE9core0_0_03cmp10PartialOrd1gCe2ge0g(
		uint32_t *arg0, // &'#omitted u32
		uint32_t *arg1 // &'#omitted u32
		) // -> bool
;
// PROTO extern "Rust" <u32 as ::"core-0_0_0"::cmp::PartialOrd<u32,>>::gt<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCe2cE9core0_0_03cmp10PartialOrd1gCe2gt0g(
		uint32_t *arg0, // &'#omitted u32
		uint32_t *arg1 // &'#omitted u32
		) // -> bool
;
// PROTO extern "Rust" <u32 as ::"core-0_0_0"::cmp::PartialOrd<u32,>>::lt<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCe2cE9core0_0_03cmp10PartialOrd1gCe2lt0g(
		uint32_t *arg0, // &'#omitted u32
		uint32_t *arg1 // &'#omitted u32
		) // -> bool
;
// PROTO extern "Rust" <u32 as ::"core-0_0_0"::ops::arith::AddAssign<u32,>>::add_assign<'#omitted,>
static void  ZRQCe3cE9core0_0_03ops5arith9AddAssign1gCe10add_assign0g(
		uint32_t *arg0, // &'#omitted mut u32
		uint32_t arg1 // u32
		) // -> ()
;
// PROTO extern "Rust" <u32 as ::"core-0_0_0"::ops::arith::Sub<u32,>>::sub
static uint32_t  ZRQCe3cE9core0_0_03ops5arith3Sub1gCe3sub0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32
;
// PROTO extern "Rust" <u32 as ::"core-0_0_0"::ops::bit::BitAnd<u32,>>::bitand
static uint32_t  ZRQCe3cE9core0_0_03ops3bit6BitAnd1gCe6bitand0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32
;
// PROTO extern "Rust" <u32 as ::"core-0_0_0"::ops::bit::BitAndAssign<u32,>>::bitand_assign<'#omitted,>
static void  ZRQCe3cE9core0_0_03ops3bit12BitAndAssign1gCe13bitand_assign0g(
		uint32_t *arg0, // &'#omitted mut u32
		uint32_t arg1 // u32
		) // -> ()
;
// PROTO extern "Rust" <u32 as ::"core-0_0_0"::ops::bit::BitOr<u32,>>::bitor
static uint32_t  ZRQCe3cE9core0_0_03ops3bit5BitOr1gCe5bitor0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32
;
// PROTO extern "Rust" <u32 as ::"core-0_0_0"::ops::bit::BitOrAssign<u32,>>::bitor_assign<'#omitted,>
static void  ZRQCe3cE9core0_0_03ops3bit11BitOrAssign1gCe12bitor_assign0g(
		uint32_t *arg0, // &'#omitted mut u32
		uint32_t arg1 // u32
		) // -> ()
;
// PROTO extern "Rust" <u32 as ::"core-0_0_0"::ops::bit::BitXor<u32,>>::bitxor
static uint32_t  ZRQCe3cE9core0_0_03ops3bit6BitXor1gCe6bitxor0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32
;
// PROTO extern "Rust" <u32 as ::"core-0_0_0"::ops::bit::Not>::not
static uint32_t  ZRQCe3cE9core0_0_03ops3bit3Not0g3not0g(
		uint32_t arg0 // u32
		) // -> u32
;
// PROTO extern "Rust" <u32 as ::"core-0_0_0"::ops::bit::Shl<u32,>>::shl
static uint32_t  ZRQCe3cE9core0_0_03ops3bit3Shl1gCe3shl0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32
;
// PROTO extern "Rust" <u32 as ::"core-0_0_0"::ops::bit::ShlAssign<i32,>>::shl_assign<'#omitted,>
static void  ZRQCe3cE9core0_0_03ops3bit9ShlAssign1gCf10shl_assign0g(
		uint32_t *arg0, // &'#omitted mut u32
		int32_t arg1 // i32
		) // -> ()
;
// PROTO extern "Rust" <u32 as ::"core-0_0_0"::ops::bit::Shr<u32,>>::shr
static uint32_t  ZRQCe3cE9core0_0_03ops3bit3Shr1gCe3shr0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32
;
// PROTO extern "Rust" <u32 as ::"core-0_0_0"::ops::bit::ShrAssign<u32,>>::shr_assign<'#omitted,>
static void  ZRQCe3cE9core0_0_03ops3bit9ShrAssign1gCe10shr_assign0g(
		uint32_t *arg0, // &'#omitted mut u32
		uint32_t arg1 // u32
		) // -> ()
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<usize,>>::cast
uintptr_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCu4cast0g(
		int32_t arg0 // i32
		) // -> usize
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<isize,>>::cast
intptr_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCv4cast0g(
		int32_t arg0 // i32
		) // -> isize
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u32,>>::cast
uint32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCe4cast0g(
		int32_t arg0 // i32
		) // -> u32
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i32,>>::cast
int32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCf4cast0g(
		int32_t arg0 // i32
		) // -> i32
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u64,>>::cast
uint64_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCg4cast0g(
		int32_t arg0 // i32
		) // -> u64
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i64,>>::cast
int64_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCh4cast0g(
		int32_t arg0 // i32
		) // -> i64
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u128,>>::cast
uint128_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCi4cast0g(
		int32_t arg0 // i32
		) // -> u128
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i128,>>::cast
int128_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCj4cast0g(
		int32_t arg0 // i32
		) // -> i128
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div
int32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_rem
int32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_rem0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::extract_sign
TUP_2_ZRTCw_ZRTCe  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g12extract_sign0g(
		int32_t arg0 // i32
		) // -> (bool, u32, )
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::from_bool
int32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g9from_bool0g(
		RUST_BOOL arg0 // bool
		) // -> i32
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::from_unsigned
int32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g13from_unsigned0g(
		uint32_t arg0 // u32
		) // -> i32
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::leading_zeros
uint32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g13leading_zeros0g(
		int32_t arg0 // i32
		) // -> u32
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::max_value
int32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g9max_value0g(void) // -> i32
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::min_value
int32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g9min_value0g(void) // -> i32
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::overflowing_add
TUP_2_ZRTCf_ZRTCw  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g15overflowing_add0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> (i32, bool, )
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::unsigned
uint32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g8unsigned0g(
		int32_t arg0 // i32
		) // -> u32
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_add
int32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_add0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_mul
int32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_mul0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_shl
int32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_shl0g(
		int32_t arg0, // i32
		uint32_t arg1 // u32
		) // -> i32
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_sub
int32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_sub0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::mul::Mulo>::mulo<'#omitted,>
int32_t  ZRQCf3cR25compiler_builtins0_0_0_Hb3int3mul4Mulo0g4mulo0g(
		int32_t arg0, // i32
		int32_t arg1, // i32
		int32_t *arg2 // &'#omitted mut i32
		) // -> i32
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Div>::div
int32_t  ZRQCf3cR25compiler_builtins0_0_0_Hb3int4sdiv3Div0g3div0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Divmod>::divmod<'#omitted,::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmodsi4_0/*S*/,>
int32_t  ZRQCf3cR25compiler_builtins0_0_0_Hb3int4sdiv6Divmod0g6divmod1gG3c_A_B_CH20closure__divmodsi4_00g(
		int32_t arg0, // i32
		int32_t arg1, // i32
		int32_t *arg2, // &'#omitted mut i32
		struct s_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmodsi4_00g arg3 // ::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmodsi4_0/*S*/
		) // -> i32
;
// PROTO extern "Rust" <i32 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Mod>::mod_
int32_t  ZRQCf3cR25compiler_builtins0_0_0_Hb3int4sdiv3Mod0g4mod_0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32
;
// PROTO extern "Rust" <i32 as ::"core-0_0_0"::cmp::PartialEq<i32,>>::eq<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCf2cE9core0_0_03cmp9PartialEq1gCf2eq0g(
		int32_t *arg0, // &'#omitted i32
		int32_t *arg1 // &'#omitted i32
		) // -> bool
;
// PROTO extern "Rust" <i32 as ::"core-0_0_0"::cmp::PartialEq<i32,>>::ne<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCf2cE9core0_0_03cmp9PartialEq1gCf2ne0g(
		int32_t *arg0, // &'#omitted i32
		int32_t *arg1 // &'#omitted i32
		) // -> bool
;
// PROTO extern "Rust" <i32 as ::"core-0_0_0"::cmp::PartialOrd<i32,>>::ge<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCf2cE9core0_0_03cmp10PartialOrd1gCf2ge0g(
		int32_t *arg0, // &'#omitted i32
		int32_t *arg1 // &'#omitted i32
		) // -> bool
;
// PROTO extern "Rust" <i32 as ::"core-0_0_0"::cmp::PartialOrd<i32,>>::gt<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCf2cE9core0_0_03cmp10PartialOrd1gCf2gt0g(
		int32_t *arg0, // &'#omitted i32
		int32_t *arg1 // &'#omitted i32
		) // -> bool
;
// PROTO extern "Rust" <i32 as ::"core-0_0_0"::cmp::PartialOrd<i32,>>::lt<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCf2cE9core0_0_03cmp10PartialOrd1gCf2lt0g(
		int32_t *arg0, // &'#omitted i32
		int32_t *arg1 // &'#omitted i32
		) // -> bool
;
// PROTO extern "Rust" <i32 as ::"core-0_0_0"::ops::arith::Add<i32,>>::add
static int32_t  ZRQCf3cE9core0_0_03ops5arith3Add1gCf3add0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32
;
// PROTO extern "Rust" <i32 as ::"core-0_0_0"::ops::arith::Neg>::neg
static int32_t  ZRQCf3cE9core0_0_03ops5arith3Neg0g3neg0g(
		int32_t arg0 // i32
		) // -> i32
;
// PROTO extern "Rust" <i32 as ::"core-0_0_0"::ops::arith::Sub<i32,>>::sub
static int32_t  ZRQCf3cE9core0_0_03ops5arith3Sub1gCf3sub0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32
;
// PROTO extern "Rust" <i32 as ::"core-0_0_0"::ops::bit::BitAnd<i32,>>::bitand
static int32_t  ZRQCf3cE9core0_0_03ops3bit6BitAnd1gCf6bitand0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32
;
// PROTO extern "Rust" <i32 as ::"core-0_0_0"::ops::bit::BitXor<i32,>>::bitxor
static int32_t  ZRQCf3cE9core0_0_03ops3bit6BitXor1gCf6bitxor0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32
;
// PROTO extern "Rust" <i32 as ::"core-0_0_0"::ops::bit::Shr<u32,>>::shr
static int32_t  ZRQCf3cE9core0_0_03ops3bit3Shr1gCe3shr0g(
		int32_t arg0, // i32
		uint32_t arg1 // u32
		) // -> i32
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<usize,>>::cast
uintptr_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCu4cast0g(
		uint64_t arg0 // u64
		) // -> usize
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<isize,>>::cast
intptr_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCv4cast0g(
		uint64_t arg0 // u64
		) // -> isize
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u32,>>::cast
uint32_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCe4cast0g(
		uint64_t arg0 // u64
		) // -> u32
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i32,>>::cast
int32_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCf4cast0g(
		uint64_t arg0 // u64
		) // -> i32
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u64,>>::cast
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCg4cast0g(
		uint64_t arg0 // u64
		) // -> u64
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i64,>>::cast
int64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCh4cast0g(
		uint64_t arg0 // u64
		) // -> i64
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u128,>>::cast
uint128_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCi4cast0g(
		uint64_t arg0 // u64
		) // -> u128
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i128,>>::cast
int128_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCj4cast0g(
		uint64_t arg0 // u64
		) // -> i128
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_rem
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_rem0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::extract_sign
TUP_2_ZRTCw_ZRTCg  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g12extract_sign0g(
		uint64_t arg0 // u64
		) // -> (bool, u64, )
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::from_bool
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g9from_bool0g(
		RUST_BOOL arg0 // bool
		) // -> u64
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::from_unsigned
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g13from_unsigned0g(
		uint64_t arg0 // u64
		) // -> u64
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::leading_zeros
uint32_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g13leading_zeros0g(
		uint64_t arg0 // u64
		) // -> u32
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::max_value
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g9max_value0g(void) // -> u64
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::min_value
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g9min_value0g(void) // -> u64
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::overflowing_add
TUP_2_ZRTCg_ZRTCw  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g15overflowing_add0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> (u64, bool, )
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::unsigned
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g8unsigned0g(
		uint64_t arg0 // u64
		) // -> u64
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_add
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_add0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_mul
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_mul0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_shl
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_shl0g(
		uint64_t arg0, // u64
		uint32_t arg1 // u32
		) // -> u64
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_sub
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_sub0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::from_parts
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g10from_parts0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u64
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::high
uint32_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g4high0g(
		uint64_t arg0 // u64
		) // -> u32
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::high_as_low
uint32_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g11high_as_low0g(
		uint32_t arg0 // u32
		) // -> u32
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::low
uint32_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g3low0g(
		uint64_t arg0 // u64
		) // -> u32
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::low_as_high
uint32_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g11low_as_high0g(
		uint32_t arg0 // u32
		) // -> u32
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::WideInt>::wide_mul
TUP_2_ZRTCg_ZRTCg  ZRQCg2cR25compiler_builtins0_0_0_Hb3int7WideInt0g8wide_mul0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> (u64, u64, )
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::WideInt>::wide_shift_left<'#omitted,'#omitted,>
void  ZRQCg2cR25compiler_builtins0_0_0_Hb3int7WideInt0g15wide_shift_left0g(
		uint64_t *arg0, // &'#omitted mut u64
		uint64_t *arg1, // &'#omitted mut u64
		int32_t arg2 // i32
		) // -> ()
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::WideInt>::wide_shift_right_with_sticky<'#omitted,'#omitted,>
void  ZRQCg2cR25compiler_builtins0_0_0_Hb3int7WideInt0g28wide_shift_right_with_sticky0g(
		uint64_t *arg0, // &'#omitted mut u64
		uint64_t *arg1, // &'#omitted mut u64
		int32_t arg2 // i32
		) // -> ()
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::mul::Mul>::mul
uint64_t  ZRQCg3cR25compiler_builtins0_0_0_Hb3int3mul3Mul0g_C0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Ashl>::ashl
uint64_t  ZRQCg3cR25compiler_builtins0_0_0_Hb3int5shift4Ashl0g4ashl0g(
		uint64_t arg0, // u64
		uint32_t arg1 // u32
		) // -> u64
;
// PROTO extern "Rust" <u64 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Lshr>::lshr
uint64_t  ZRQCg3cR25compiler_builtins0_0_0_Hb3int5shift4Lshr0g4lshr0g(
		uint64_t arg0, // u64
		uint32_t arg1 // u32
		) // -> u64
;
// PROTO extern "Rust" <u64 as ::"core-0_0_0"::cmp::PartialEq<u64,>>::eq<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCg2cE9core0_0_03cmp9PartialEq1gCg2eq0g(
		uint64_t *arg0, // &'#omitted u64
		uint64_t *arg1 // &'#omitted u64
		) // -> bool
;
// PROTO extern "Rust" <u64 as ::"core-0_0_0"::cmp::PartialEq<u64,>>::ne<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCg2cE9core0_0_03cmp9PartialEq1gCg2ne0g(
		uint64_t *arg0, // &'#omitted u64
		uint64_t *arg1 // &'#omitted u64
		) // -> bool
;
// PROTO extern "Rust" <u64 as ::"core-0_0_0"::cmp::PartialOrd<u64,>>::ge<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCg2cE9core0_0_03cmp10PartialOrd1gCg2ge0g(
		uint64_t *arg0, // &'#omitted u64
		uint64_t *arg1 // &'#omitted u64
		) // -> bool
;
// PROTO extern "Rust" <u64 as ::"core-0_0_0"::cmp::PartialOrd<u64,>>::gt<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCg2cE9core0_0_03cmp10PartialOrd1gCg2gt0g(
		uint64_t *arg0, // &'#omitted u64
		uint64_t *arg1 // &'#omitted u64
		) // -> bool
;
// PROTO extern "Rust" <u64 as ::"core-0_0_0"::cmp::PartialOrd<u64,>>::lt<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCg2cE9core0_0_03cmp10PartialOrd1gCg2lt0g(
		uint64_t *arg0, // &'#omitted u64
		uint64_t *arg1 // &'#omitted u64
		) // -> bool
;
// PROTO extern "Rust" <u64 as ::"core-0_0_0"::ops::arith::AddAssign<u64,>>::add_assign<'#omitted,>
static void  ZRQCg3cE9core0_0_03ops5arith9AddAssign1gCg10add_assign0g(
		uint64_t *arg0, // &'#omitted mut u64
		uint64_t arg1 // u64
		) // -> ()
;
// PROTO extern "Rust" <u64 as ::"core-0_0_0"::ops::arith::Sub<u64,>>::sub
static uint64_t  ZRQCg3cE9core0_0_03ops5arith3Sub1gCg3sub0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64
;
// PROTO extern "Rust" <u64 as ::"core-0_0_0"::ops::bit::BitAnd<u64,>>::bitand
static uint64_t  ZRQCg3cE9core0_0_03ops3bit6BitAnd1gCg6bitand0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64
;
// PROTO extern "Rust" <u64 as ::"core-0_0_0"::ops::bit::BitAndAssign<u64,>>::bitand_assign<'#omitted,>
static void  ZRQCg3cE9core0_0_03ops3bit12BitAndAssign1gCg13bitand_assign0g(
		uint64_t *arg0, // &'#omitted mut u64
		uint64_t arg1 // u64
		) // -> ()
;
// PROTO extern "Rust" <u64 as ::"core-0_0_0"::ops::bit::BitOr<u64,>>::bitor
static uint64_t  ZRQCg3cE9core0_0_03ops3bit5BitOr1gCg5bitor0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64
;
// PROTO extern "Rust" <u64 as ::"core-0_0_0"::ops::bit::BitOrAssign<u64,>>::bitor_assign<'#omitted,>
static void  ZRQCg3cE9core0_0_03ops3bit11BitOrAssign1gCg12bitor_assign0g(
		uint64_t *arg0, // &'#omitted mut u64
		uint64_t arg1 // u64
		) // -> ()
;
// PROTO extern "Rust" <u64 as ::"core-0_0_0"::ops::bit::BitXor<u64,>>::bitxor
static uint64_t  ZRQCg3cE9core0_0_03ops3bit6BitXor1gCg6bitxor0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64
;
// PROTO extern "Rust" <u64 as ::"core-0_0_0"::ops::bit::Not>::not
static uint64_t  ZRQCg3cE9core0_0_03ops3bit3Not0g3not0g(
		uint64_t arg0 // u64
		) // -> u64
;
// PROTO extern "Rust" <u64 as ::"core-0_0_0"::ops::bit::Shl<u32,>>::shl
static uint64_t  ZRQCg3cE9core0_0_03ops3bit3Shl1gCe3shl0g(
		uint64_t arg0, // u64
		uint32_t arg1 // u32
		) // -> u64
;
// PROTO extern "Rust" <u64 as ::"core-0_0_0"::ops::bit::ShlAssign<i32,>>::shl_assign<'#omitted,>
static void  ZRQCg3cE9core0_0_03ops3bit9ShlAssign1gCf10shl_assign0g(
		uint64_t *arg0, // &'#omitted mut u64
		int32_t arg1 // i32
		) // -> ()
;
// PROTO extern "Rust" <u64 as ::"core-0_0_0"::ops::bit::Shr<u32,>>::shr
static uint64_t  ZRQCg3cE9core0_0_03ops3bit3Shr1gCe3shr0g(
		uint64_t arg0, // u64
		uint32_t arg1 // u32
		) // -> u64
;
// PROTO extern "Rust" <u64 as ::"core-0_0_0"::ops::bit::ShrAssign<u32,>>::shr_assign<'#omitted,>
static void  ZRQCg3cE9core0_0_03ops3bit9ShrAssign1gCe10shr_assign0g(
		uint64_t *arg0, // &'#omitted mut u64
		uint32_t arg1 // u32
		) // -> ()
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<usize,>>::cast
uintptr_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCu4cast0g(
		int64_t arg0 // i64
		) // -> usize
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<isize,>>::cast
intptr_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCv4cast0g(
		int64_t arg0 // i64
		) // -> isize
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u32,>>::cast
uint32_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCe4cast0g(
		int64_t arg0 // i64
		) // -> u32
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i32,>>::cast
int32_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCf4cast0g(
		int64_t arg0 // i64
		) // -> i32
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u64,>>::cast
uint64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCg4cast0g(
		int64_t arg0 // i64
		) // -> u64
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i64,>>::cast
int64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCh4cast0g(
		int64_t arg0 // i64
		) // -> i64
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u128,>>::cast
uint128_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCi4cast0g(
		int64_t arg0 // i64
		) // -> u128
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i128,>>::cast
int128_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCj4cast0g(
		int64_t arg0 // i64
		) // -> i128
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div
int64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_rem
int64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_rem0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::extract_sign
TUP_2_ZRTCw_ZRTCg  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g12extract_sign0g(
		int64_t arg0 // i64
		) // -> (bool, u64, )
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::from_bool
int64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g9from_bool0g(
		RUST_BOOL arg0 // bool
		) // -> i64
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::from_unsigned
int64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g13from_unsigned0g(
		uint64_t arg0 // u64
		) // -> i64
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::leading_zeros
uint32_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g13leading_zeros0g(
		int64_t arg0 // i64
		) // -> u32
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::max_value
int64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g9max_value0g(void) // -> i64
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::min_value
int64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g9min_value0g(void) // -> i64
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::overflowing_add
TUP_2_ZRTCh_ZRTCw  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g15overflowing_add0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> (i64, bool, )
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::unsigned
uint64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g8unsigned0g(
		int64_t arg0 // i64
		) // -> u64
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_add
int64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_add0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_mul
int64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_mul0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_shl
int64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_shl0g(
		int64_t arg0, // i64
		uint32_t arg1 // u32
		) // -> i64
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_sub
int64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_sub0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::from_parts
int64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g10from_parts0g(
		uint32_t arg0, // u32
		int32_t arg1 // i32
		) // -> i64
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::high
int32_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g4high0g(
		int64_t arg0 // i64
		) // -> i32
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::high_as_low
uint32_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g11high_as_low0g(
		int32_t arg0 // i32
		) // -> u32
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::low
uint32_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g3low0g(
		int64_t arg0 // i64
		) // -> u32
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::low_as_high
int32_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g11low_as_high0g(
		uint32_t arg0 // u32
		) // -> i32
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::mul::Mulo>::mulo<'#omitted,>
int64_t  ZRQCh3cR25compiler_builtins0_0_0_Hb3int3mul4Mulo0g4mulo0g(
		int64_t arg0, // i64
		int64_t arg1, // i64
		int32_t *arg2 // &'#omitted mut i32
		) // -> i64
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Div>::div
int64_t  ZRQCh3cR25compiler_builtins0_0_0_Hb3int4sdiv3Div0g3div0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Divmod>::divmod<'#omitted,::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmoddi4_1/*S*/,>
int64_t  ZRQCh3cR25compiler_builtins0_0_0_Hb3int4sdiv6Divmod0g6divmod1gG3c_A_B_CH20closure__divmoddi4_10g(
		int64_t arg0, // i64
		int64_t arg1, // i64
		int64_t *arg2, // &'#omitted mut i64
		struct s_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmoddi4_10g arg3 // ::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmoddi4_1/*S*/
		) // -> i64
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Mod>::mod_
int64_t  ZRQCh3cR25compiler_builtins0_0_0_Hb3int4sdiv3Mod0g4mod_0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64
;
// PROTO extern "Rust" <i64 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Ashr>::ashr
int64_t  ZRQCh3cR25compiler_builtins0_0_0_Hb3int5shift4Ashr0g4ashr0g(
		int64_t arg0, // i64
		uint32_t arg1 // u32
		) // -> i64
;
// PROTO extern "Rust" <i64 as ::"core-0_0_0"::cmp::PartialEq<i64,>>::eq<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCh2cE9core0_0_03cmp9PartialEq1gCh2eq0g(
		int64_t *arg0, // &'#omitted i64
		int64_t *arg1 // &'#omitted i64
		) // -> bool
;
// PROTO extern "Rust" <i64 as ::"core-0_0_0"::cmp::PartialEq<i64,>>::ne<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCh2cE9core0_0_03cmp9PartialEq1gCh2ne0g(
		int64_t *arg0, // &'#omitted i64
		int64_t *arg1 // &'#omitted i64
		) // -> bool
;
// PROTO extern "Rust" <i64 as ::"core-0_0_0"::cmp::PartialOrd<i64,>>::ge<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCh2cE9core0_0_03cmp10PartialOrd1gCh2ge0g(
		int64_t *arg0, // &'#omitted i64
		int64_t *arg1 // &'#omitted i64
		) // -> bool
;
// PROTO extern "Rust" <i64 as ::"core-0_0_0"::cmp::PartialOrd<i64,>>::gt<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCh2cE9core0_0_03cmp10PartialOrd1gCh2gt0g(
		int64_t *arg0, // &'#omitted i64
		int64_t *arg1 // &'#omitted i64
		) // -> bool
;
// PROTO extern "Rust" <i64 as ::"core-0_0_0"::cmp::PartialOrd<i64,>>::lt<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCh2cE9core0_0_03cmp10PartialOrd1gCh2lt0g(
		int64_t *arg0, // &'#omitted i64
		int64_t *arg1 // &'#omitted i64
		) // -> bool
;
// PROTO extern "Rust" <i64 as ::"core-0_0_0"::ops::arith::Add<i64,>>::add
static int64_t  ZRQCh3cE9core0_0_03ops5arith3Add1gCh3add0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64
;
// PROTO extern "Rust" <i64 as ::"core-0_0_0"::ops::arith::AddAssign<i64,>>::add_assign<'#omitted,>
static void  ZRQCh3cE9core0_0_03ops5arith9AddAssign1gCh10add_assign0g(
		int64_t *arg0, // &'#omitted mut i64
		int64_t arg1 // i64
		) // -> ()
;
// PROTO extern "Rust" <i64 as ::"core-0_0_0"::ops::arith::Neg>::neg
static int64_t  ZRQCh3cE9core0_0_03ops5arith3Neg0g3neg0g(
		int64_t arg0 // i64
		) // -> i64
;
// PROTO extern "Rust" <i64 as ::"core-0_0_0"::ops::arith::Sub<i64,>>::sub
static int64_t  ZRQCh3cE9core0_0_03ops5arith3Sub1gCh3sub0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64
;
// PROTO extern "Rust" <i64 as ::"core-0_0_0"::ops::bit::BitAnd<i64,>>::bitand
static int64_t  ZRQCh3cE9core0_0_03ops3bit6BitAnd1gCh6bitand0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64
;
// PROTO extern "Rust" <i64 as ::"core-0_0_0"::ops::bit::BitXor<i64,>>::bitxor
static int64_t  ZRQCh3cE9core0_0_03ops3bit6BitXor1gCh6bitxor0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64
;
// PROTO extern "Rust" <i64 as ::"core-0_0_0"::ops::bit::Shr<u32,>>::shr
static int64_t  ZRQCh3cE9core0_0_03ops3bit3Shr1gCe3shr0g(
		int64_t arg0, // i64
		uint32_t arg1 // u32
		) // -> i64
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<usize,>>::cast
uintptr_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCu4cast0g(
		uint128_t arg0 // u128
		) // -> usize
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<isize,>>::cast
intptr_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCv4cast0g(
		uint128_t arg0 // u128
		) // -> isize
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u32,>>::cast
uint32_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCe4cast0g(
		uint128_t arg0 // u128
		) // -> u32
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i32,>>::cast
int32_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCf4cast0g(
		uint128_t arg0 // u128
		) // -> i32
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u64,>>::cast
uint64_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCg4cast0g(
		uint128_t arg0 // u128
		) // -> u64
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i64,>>::cast
int64_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCh4cast0g(
		uint128_t arg0 // u128
		) // -> i64
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u128,>>::cast
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCi4cast0g(
		uint128_t arg0 // u128
		) // -> u128
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i128,>>::cast
int128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCj4cast0g(
		uint128_t arg0 // u128
		) // -> i128
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_rem
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_rem0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::extract_sign
TUP_2_ZRTCw_ZRTCi  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g12extract_sign0g(
		uint128_t arg0 // u128
		) // -> (bool, u128, )
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::from_bool
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g9from_bool0g(
		RUST_BOOL arg0 // bool
		) // -> u128
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::from_unsigned
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g13from_unsigned0g(
		uint128_t arg0 // u128
		) // -> u128
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::leading_zeros
uint32_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g13leading_zeros0g(
		uint128_t arg0 // u128
		) // -> u32
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::max_value
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g9max_value0g(void) // -> u128
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::min_value
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g9min_value0g(void) // -> u128
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::overflowing_add
TUP_2_ZRTCi_ZRTCw  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g15overflowing_add0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> (u128, bool, )
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::unsigned
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g8unsigned0g(
		uint128_t arg0 // u128
		) // -> u128
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_add
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_add0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_mul
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_mul0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_shl
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_shl0g(
		uint128_t arg0, // u128
		uint32_t arg1 // u32
		) // -> u128
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_sub
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_sub0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::from_parts
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g10from_parts0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u128
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::high
uint64_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g4high0g(
		uint128_t arg0 // u128
		) // -> u64
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::high_as_low
uint64_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g11high_as_low0g(
		uint64_t arg0 // u64
		) // -> u64
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::low
uint64_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g3low0g(
		uint128_t arg0 // u128
		) // -> u64
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::low_as_high
uint64_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g11low_as_high0g(
		uint64_t arg0 // u64
		) // -> u64
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::AddSub>::add
uint128_t  ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub6AddSub0g3add0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::AddSub>::sub
uint128_t  ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub6AddSub0g3sub0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::Addo>::addo<'#omitted,>
uint128_t  ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub4Addo0g4addo0g(
		uint128_t arg0, // u128
		uint128_t arg1, // u128
		int32_t *arg2 // &'#omitted mut i32
		) // -> u128
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::Subo>::subo<'#omitted,>
uint128_t  ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub4Subo0g4subo0g(
		uint128_t arg0, // u128
		uint128_t arg1, // u128
		int32_t *arg2 // &'#omitted mut i32
		) // -> u128
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::UAddSub>::uadd
uint128_t  ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub7UAddSub0g4uadd0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::UAddSub>::uadd_one
uint128_t  ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub7UAddSub0g8uadd_one0g(
		uint128_t arg0 // u128
		) // -> u128
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::UAddSub>::usub
uint128_t  ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub7UAddSub0g4usub0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::mul::UMulo>::mulo<'#omitted,>
uint128_t  ZRQCi3cR25compiler_builtins0_0_0_Hb3int3mul5UMulo0g4mulo0g(
		uint128_t arg0, // u128
		uint128_t arg1, // u128
		int32_t *arg2 // &'#omitted mut i32
		) // -> u128
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Ashl>::ashl
uint128_t  ZRQCi3cR25compiler_builtins0_0_0_Hb3int5shift4Ashl0g4ashl0g(
		uint128_t arg0, // u128
		uint32_t arg1 // u32
		) // -> u128
;
// PROTO extern "Rust" <u128 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Lshr>::lshr
uint128_t  ZRQCi3cR25compiler_builtins0_0_0_Hb3int5shift4Lshr0g4lshr0g(
		uint128_t arg0, // u128
		uint32_t arg1 // u32
		) // -> u128
;
// PROTO extern "Rust" <u128 as ::"core-0_0_0"::cmp::PartialOrd<u128,>>::ge<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCi2cE9core0_0_03cmp10PartialOrd1gCi2ge0g(
		uint128_t *arg0, // &'#omitted u128
		uint128_t *arg1 // &'#omitted u128
		) // -> bool
;
// PROTO extern "Rust" <u128 as ::"core-0_0_0"::cmp::PartialOrd<u128,>>::gt<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCi2cE9core0_0_03cmp10PartialOrd1gCi2gt0g(
		uint128_t *arg0, // &'#omitted u128
		uint128_t *arg1 // &'#omitted u128
		) // -> bool
;
// PROTO extern "Rust" <u128 as ::"core-0_0_0"::cmp::PartialOrd<u128,>>::le<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCi2cE9core0_0_03cmp10PartialOrd1gCi2le0g(
		uint128_t *arg0, // &'#omitted u128
		uint128_t *arg1 // &'#omitted u128
		) // -> bool
;
// PROTO extern "Rust" <u128 as ::"core-0_0_0"::cmp::PartialOrd<u128,>>::lt<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCi2cE9core0_0_03cmp10PartialOrd1gCi2lt0g(
		uint128_t *arg0, // &'#omitted u128
		uint128_t *arg1 // &'#omitted u128
		) // -> bool
;
// PROTO extern "Rust" <u128 as ::"core-0_0_0"::ops::bit::Not>::not
static uint128_t  ZRQCi3cE9core0_0_03ops3bit3Not0g3not0g(
		uint128_t arg0 // u128
		) // -> u128
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<usize,>>::cast
uintptr_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCu4cast0g(
		int128_t arg0 // i128
		) // -> usize
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<isize,>>::cast
intptr_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCv4cast0g(
		int128_t arg0 // i128
		) // -> isize
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u32,>>::cast
uint32_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCe4cast0g(
		int128_t arg0 // i128
		) // -> u32
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i32,>>::cast
int32_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCf4cast0g(
		int128_t arg0 // i128
		) // -> i32
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u64,>>::cast
uint64_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCg4cast0g(
		int128_t arg0 // i128
		) // -> u64
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i64,>>::cast
int64_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCh4cast0g(
		int128_t arg0 // i128
		) // -> i64
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u128,>>::cast
uint128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCi4cast0g(
		int128_t arg0 // i128
		) // -> u128
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i128,>>::cast
int128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCj4cast0g(
		int128_t arg0 // i128
		) // -> i128
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div
int128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_rem
int128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_rem0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::extract_sign
TUP_2_ZRTCw_ZRTCi  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g12extract_sign0g(
		int128_t arg0 // i128
		) // -> (bool, u128, )
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::from_bool
int128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g9from_bool0g(
		RUST_BOOL arg0 // bool
		) // -> i128
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::from_unsigned
int128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g13from_unsigned0g(
		uint128_t arg0 // u128
		) // -> i128
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::leading_zeros
uint32_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g13leading_zeros0g(
		int128_t arg0 // i128
		) // -> u32
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::max_value
int128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g9max_value0g(void) // -> i128
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::min_value
int128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g9min_value0g(void) // -> i128
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::overflowing_add
TUP_2_ZRTCj_ZRTCw  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g15overflowing_add0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> (i128, bool, )
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::unsigned
uint128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g8unsigned0g(
		int128_t arg0 // i128
		) // -> u128
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_add
int128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_add0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_mul
int128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_mul0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_shl
int128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_shl0g(
		int128_t arg0, // i128
		uint32_t arg1 // u32
		) // -> i128
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_sub
int128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_sub0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::from_parts
int128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g10from_parts0g(
		uint64_t arg0, // u64
		int64_t arg1 // i64
		) // -> i128
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::high
int64_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g4high0g(
		int128_t arg0 // i128
		) // -> i64
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::high_as_low
uint64_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g11high_as_low0g(
		int64_t arg0 // i64
		) // -> u64
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::low
uint64_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g3low0g(
		int128_t arg0 // i128
		) // -> u64
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::low_as_high
int64_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g11low_as_high0g(
		uint64_t arg0 // u64
		) // -> i64
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::AddSub>::add
int128_t  ZRQCj3cR25compiler_builtins0_0_0_Hb3int6addsub6AddSub0g3add0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::AddSub>::sub
int128_t  ZRQCj3cR25compiler_builtins0_0_0_Hb3int6addsub6AddSub0g3sub0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::Addo>::addo<'#omitted,>
int128_t  ZRQCj3cR25compiler_builtins0_0_0_Hb3int6addsub4Addo0g4addo0g(
		int128_t arg0, // i128
		int128_t arg1, // i128
		int32_t *arg2 // &'#omitted mut i32
		) // -> i128
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::Subo>::subo<'#omitted,>
int128_t  ZRQCj3cR25compiler_builtins0_0_0_Hb3int6addsub4Subo0g4subo0g(
		int128_t arg0, // i128
		int128_t arg1, // i128
		int32_t *arg2 // &'#omitted mut i32
		) // -> i128
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::mul::Mul>::mul
int128_t  ZRQCj3cR25compiler_builtins0_0_0_Hb3int3mul3Mul0g_C0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::mul::Mulo>::mulo<'#omitted,>
int128_t  ZRQCj3cR25compiler_builtins0_0_0_Hb3int3mul4Mulo0g4mulo0g(
		int128_t arg0, // i128
		int128_t arg1, // i128
		int32_t *arg2 // &'#omitted mut i32
		) // -> i128
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Div>::div
int128_t  ZRQCj3cR25compiler_builtins0_0_0_Hb3int4sdiv3Div0g3div0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Mod>::mod_
int128_t  ZRQCj3cR25compiler_builtins0_0_0_Hb3int4sdiv3Mod0g4mod_0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128
;
// PROTO extern "Rust" <i128 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Ashr>::ashr
int128_t  ZRQCj3cR25compiler_builtins0_0_0_Hb3int5shift4Ashr0g4ashr0g(
		int128_t arg0, // i128
		uint32_t arg1 // u32
		) // -> i128
;
// PROTO extern "Rust" <i128 as ::"core-0_0_0"::cmp::PartialEq<i128,>>::eq<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCj2cE9core0_0_03cmp9PartialEq1gCj2eq0g(
		int128_t *arg0, // &'#omitted i128
		int128_t *arg1 // &'#omitted i128
		) // -> bool
;
// PROTO extern "Rust" <i128 as ::"core-0_0_0"::cmp::PartialEq<i128,>>::ne<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCj2cE9core0_0_03cmp9PartialEq1gCj2ne0g(
		int128_t *arg0, // &'#omitted i128
		int128_t *arg1 // &'#omitted i128
		) // -> bool
;
// PROTO extern "Rust" <i128 as ::"core-0_0_0"::cmp::PartialOrd<i128,>>::ge<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCj2cE9core0_0_03cmp10PartialOrd1gCj2ge0g(
		int128_t *arg0, // &'#omitted i128
		int128_t *arg1 // &'#omitted i128
		) // -> bool
;
// PROTO extern "Rust" <i128 as ::"core-0_0_0"::cmp::PartialOrd<i128,>>::gt<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCj2cE9core0_0_03cmp10PartialOrd1gCj2gt0g(
		int128_t *arg0, // &'#omitted i128
		int128_t *arg1 // &'#omitted i128
		) // -> bool
;
// PROTO extern "Rust" <i128 as ::"core-0_0_0"::cmp::PartialOrd<i128,>>::le<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCj2cE9core0_0_03cmp10PartialOrd1gCj2le0g(
		int128_t *arg0, // &'#omitted i128
		int128_t *arg1 // &'#omitted i128
		) // -> bool
;
// PROTO extern "Rust" <i128 as ::"core-0_0_0"::cmp::PartialOrd<i128,>>::lt<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCj2cE9core0_0_03cmp10PartialOrd1gCj2lt0g(
		int128_t *arg0, // &'#omitted i128
		int128_t *arg1 // &'#omitted i128
		) // -> bool
;
// PROTO extern "Rust" <i128 as ::"core-0_0_0"::ops::arith::Add<i128,>>::add
static int128_t  ZRQCj3cE9core0_0_03ops5arith3Add1gCj3add0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128
;
// PROTO extern "Rust" <i128 as ::"core-0_0_0"::ops::arith::Neg>::neg
static int128_t  ZRQCj3cE9core0_0_03ops5arith3Neg0g3neg0g(
		int128_t arg0 // i128
		) // -> i128
;
// PROTO extern "Rust" <i128 as ::"core-0_0_0"::ops::arith::Sub<i128,>>::sub
static int128_t  ZRQCj3cE9core0_0_03ops5arith3Sub1gCj3sub0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128
;
// PROTO extern "Rust" <i128 as ::"core-0_0_0"::ops::bit::BitXor<i128,>>::bitxor
static int128_t  ZRQCj3cE9core0_0_03ops3bit6BitXor1gCj6bitxor0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128
;
// PROTO extern "Rust" <i128 as ::"core-0_0_0"::ops::bit::Shr<u32,>>::shr
static int128_t  ZRQCj3cE9core0_0_03ops3bit3Shr1gCe3shr0g(
		int128_t arg0, // i128
		uint32_t arg1 // u32
		) // -> i128
;
// PROTO extern "Rust" <f32 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::from_parts
float  ZRQCn2cR25compiler_builtins0_0_0_Hb5float5Float0g10from_parts0g(
		RUST_BOOL arg0, // bool
		uint32_t arg1, // u32
		uint32_t arg2 // u32
		) // -> f32
;
// PROTO extern "Rust" <f32 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::from_repr
float  ZRQCn2cR25compiler_builtins0_0_0_Hb5float5Float0g9from_repr0g(
		uint32_t arg0 // u32
		) // -> f32
;
// PROTO extern "Rust" <f32 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::normalize
TUP_2_ZRTCf_ZRTCe  ZRQCn2cR25compiler_builtins0_0_0_Hb5float5Float0g9normalize0g(
		uint32_t arg0 // u32
		) // -> (i32, u32, )
;
// PROTO extern "Rust" <f32 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::repr
uint32_t  ZRQCn2cR25compiler_builtins0_0_0_Hb5float5Float0g4repr0g(
		float arg0 // f32
		) // -> u32
;
// PROTO extern "Rust" <f32 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::signed_repr
int32_t  ZRQCn2cR25compiler_builtins0_0_0_Hb5float5Float0g11signed_repr0g(
		float arg0 // f32
		) // -> i32
;
// PROTO extern "Rust" <f32 as ::"compiler_builtins-0_0_0_Hb"::float::pow::Pow>::pow
float  ZRQCn3cR25compiler_builtins0_0_0_Hb5float3pow3Pow0g_C0g(
		float arg0, // f32
		int32_t arg1 // i32
		) // -> f32
;
// PROTO extern "Rust" <f32 as ::"core-0_0_0"::ops::arith::Div<f32,>>::div
static float  ZRQCn3cE9core0_0_03ops5arith3Div1gCn3div0g(
		float arg0, // f32
		float arg1 // f32
		) // -> f32
;
// PROTO extern "Rust" <f32 as ::"core-0_0_0"::ops::arith::MulAssign<f32,>>::mul_assign<'#omitted,>
static void  ZRQCn3cE9core0_0_03ops5arith9MulAssign1gCn10mul_assign0g(
		float *arg0, // &'#omitted mut f32
		float arg1 // f32
		) // -> ()
;
// PROTO extern "Rust" <f64 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::from_parts
double  ZRQCo2cR25compiler_builtins0_0_0_Hb5float5Float0g10from_parts0g(
		RUST_BOOL arg0, // bool
		uint64_t arg1, // u64
		uint64_t arg2 // u64
		) // -> f64
;
// PROTO extern "Rust" <f64 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::from_repr
double  ZRQCo2cR25compiler_builtins0_0_0_Hb5float5Float0g9from_repr0g(
		uint64_t arg0 // u64
		) // -> f64
;
// PROTO extern "Rust" <f64 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::normalize
TUP_2_ZRTCf_ZRTCg  ZRQCo2cR25compiler_builtins0_0_0_Hb5float5Float0g9normalize0g(
		uint64_t arg0 // u64
		) // -> (i32, u64, )
;
// PROTO extern "Rust" <f64 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::repr
uint64_t  ZRQCo2cR25compiler_builtins0_0_0_Hb5float5Float0g4repr0g(
		double arg0 // f64
		) // -> u64
;
// PROTO extern "Rust" <f64 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::signed_repr
int64_t  ZRQCo2cR25compiler_builtins0_0_0_Hb5float5Float0g11signed_repr0g(
		double arg0 // f64
		) // -> i64
;
// PROTO extern "Rust" <f64 as ::"compiler_builtins-0_0_0_Hb"::float::pow::Pow>::pow
double  ZRQCo3cR25compiler_builtins0_0_0_Hb5float3pow3Pow0g_C0g(
		double arg0, // f64
		int32_t arg1 // i32
		) // -> f64
;
// PROTO extern "Rust" <f64 as ::"core-0_0_0"::ops::arith::Div<f64,>>::div
static double  ZRQCo3cE9core0_0_03ops5arith3Div1gCo3div0g(
		double arg0, // f64
		double arg1 // f64
		) // -> f64
;
// PROTO extern "Rust" <f64 as ::"core-0_0_0"::ops::arith::MulAssign<f64,>>::mul_assign<'#omitted,>
static void  ZRQCo3cE9core0_0_03ops5arith9MulAssign1gCo10mul_assign0g(
		double *arg0, // &'#omitted mut f64
		double arg1 // f64
		) // -> ()
;
// PROTO extern "Rust" <::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/ as ::"core-0_0_0"::clone::Clone>::clone<'#omitted,>
struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g  ZRQG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g2cE9core0_0_05clone5Clone0g_F0g(
		struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g *arg0 // &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
		) // -> ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
;
// PROTO extern "Rust" <::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/ as ::"core-0_0_0"::clone::Clone>::clone_from<'#omitted,'#omitted,>
static void  ZRQG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g2cE9core0_0_05clone5Clone0g10clone_from0g(
		struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g *arg0, // &'#omitted mut ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
		struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g *arg1 // &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
		) // -> ()
;
// PROTO extern "Rust" <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>
RUST_BOOL  ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g(
		struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *arg0, // &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
		struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *arg1 // &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
		) // -> bool
;
// PROTO extern "Rust" <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::ne<'#omitted,'#omitted,>
static RUST_BOOL  ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2ne0g(
		struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *arg0, // &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
		struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *arg1 // &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
		) // -> bool
;
// PROTO extern "Rust" <::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmoddi4_1/*S*/ as ::"core-0_0_0"::ops::function::Fn<(i64, i64, ),>>::call<'#omitted,>
int64_t  ZRQG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmoddi4_10g3cE9core0_0_03ops8function2Fn1gT2ChCh4call0g(
		struct s_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmoddi4_10g *arg0, // &'#omitted ::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmoddi4_1/*S*/
		TUP_2_ZRTCh_ZRTCh arg1 // (i64, i64, )
		) // -> i64
;
// PROTO extern "Rust" <::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmoddi4_1/*S*/ as ::"core-0_0_0"::ops::function::FnMut<(i64, i64, ),>>::call_mut<'#omitted,>
int64_t  ZRQG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmoddi4_10g3cE9core0_0_03ops8function5FnMut1gT2ChCh8call_mut0g(
		struct s_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmoddi4_10g *arg0, // &'#omitted mut ::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmoddi4_1/*S*/
		TUP_2_ZRTCh_ZRTCh arg1 // (i64, i64, )
		) // -> i64
;
// PROTO extern "Rust" <::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmoddi4_1/*S*/ as ::"core-0_0_0"::ops::function::FnOnce<(i64, i64, ),>>::call_once
int64_t  ZRQG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmoddi4_10g3cE9core0_0_03ops8function6FnOnce1gT2ChCh9call_once0g(
		struct s_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmoddi4_10g arg0, // ::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmoddi4_1/*S*/
		TUP_2_ZRTCh_ZRTCh arg1 // (i64, i64, )
		) // -> i64
;
// PROTO extern "Rust" <::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmodsi4_0/*S*/ as ::"core-0_0_0"::ops::function::Fn<(i32, i32, ),>>::call<'#omitted,>
int32_t  ZRQG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmodsi4_00g3cE9core0_0_03ops8function2Fn1gT2CfCf4call0g(
		struct s_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmodsi4_00g *arg0, // &'#omitted ::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmodsi4_0/*S*/
		TUP_2_ZRTCf_ZRTCf arg1 // (i32, i32, )
		) // -> i32
;
// PROTO extern "Rust" <::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmodsi4_0/*S*/ as ::"core-0_0_0"::ops::function::FnMut<(i32, i32, ),>>::call_mut<'#omitted,>
int32_t  ZRQG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmodsi4_00g3cE9core0_0_03ops8function5FnMut1gT2CfCf8call_mut0g(
		struct s_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmodsi4_00g *arg0, // &'#omitted mut ::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmodsi4_0/*S*/
		TUP_2_ZRTCf_ZRTCf arg1 // (i32, i32, )
		) // -> i32
;
// PROTO extern "Rust" <::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmodsi4_0/*S*/ as ::"core-0_0_0"::ops::function::FnOnce<(i32, i32, ),>>::call_once
int32_t  ZRQG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmodsi4_00g3cE9core0_0_03ops8function6FnOnce1gT2CfCf9call_once0g(
		struct s_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmodsi4_00g arg0, // ::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmodsi4_0/*S*/
		TUP_2_ZRTCf_ZRTCf arg1 // (i32, i32, )
		) // -> i32
;
// ::"compiler_builtins-0_0_0_Hb"::abort
tBANG  ZRG1cR25compiler_builtins0_0_0_Hb5abort0g(void) // -> !

{
	tBANG rv;
	tBANG var0 = {0};	// !
	abort();
	// ^ Call( _0 = "abort"::( ), bb1, bb1)
bb1: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::add::__adddf3
double  ZRG3cR25compiler_builtins0_0_0_Hb5float3add8__adddf30g(
		double arg0, // f64
		double arg1 // f64
		) // -> f64

{
	double rv;
	rv = ZRG3cR25compiler_builtins0_0_0_Hb5float3add_C1gCo( arg0, arg1 );
	// ^ Call( retval = ::"compiler_builtins-0_0_0_Hb"::float::add::add<f64,>( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::add::__addsf3
float  ZRG3cR25compiler_builtins0_0_0_Hb5float3add8__addsf30g(
		float arg0, // f32
		float arg1 // f32
		) // -> f32

{
	float rv;
	rv = ZRG3cR25compiler_builtins0_0_0_Hb5float3add_C1gCn( arg0, arg1 );
	// ^ Call( retval = ::"compiler_builtins-0_0_0_Hb"::float::add::add<f32,>( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::add::add<f32,>
float  ZRG3cR25compiler_builtins0_0_0_Hb5float3add_C1gCn(
		float arg0, // f32
		float arg1 // f32
		) // -> f32

{
	float rv;
	uint32_t var0;	// u32
	uint32_t var1;	// u32
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	uint32_t var4;	// u32
	uint32_t var5;	// u32
	uint32_t var6;	// u32
	uint32_t var7;	// u32
	uint32_t var8;	// u32
	uint32_t var9;	// u32
	uint32_t var10;	// u32
	uint32_t var11;	// u32
	uint32_t var12;	// u32
	uint32_t var13;	// u32
	uint32_t var14;	// u32
	uint32_t var15;	// u32
	uint32_t var16;	// u32
	uint32_t var17;	// u32
	int32_t var18;	// i32
	int32_t var19;	// i32
	uint32_t var20;	// u32
	uint32_t var21;	// u32
	uint32_t var22;	// u32
	RUST_BOOL var23;	// bool
	uint32_t var24;	// u32
	int32_t var25;	// i32
	uint32_t var26;	// u32
	int32_t var27;	// i32
	int32_t var28;	// i32
	uint32_t var29;	// u32
	RUST_BOOL var30;	// bool
	uint32_t var31;	// u32
	uint32_t var32;	// u32
	uint32_t var33;	// u32
	uint32_t var34;	// u32
	uint32_t var35;	// u32
	TUP_2_ZRTCf_ZRTCe var36;	// (i32, u32, )
	TUP_2_ZRTCf_ZRTCe var37;	// (i32, u32, )
	uint32_t var38;	// u32
	uint32_t var39;	// u32
	uint32_t var40;	// u32
	uint32_t var41;	// u32
	int32_t var42;	// i32
	uint32_t var43;	// u32
	int32_t var44;	// i32
	uint32_t *var45;	// &'#omitted mut u32
	uint32_t *var46;	// &'#omitted mut u32
	uint32_t var47;	// u32
	uint32_t var48;	// u32
	int32_t var49;	// i32
	uint32_t var50;	// u32
	uint32_t *var51;	// &'#omitted mut u32
	uint32_t *var52;	// &'#omitted mut u32
	uint32_t *var53;	// &'#omitted mut u32
	uint32_t *var54;	// &'#omitted mut u32
	uint32_t var55;	// u32
	uint32_t var56;	// u32
	uint32_t var57;	// u32
	uint32_t var58;	// u32
	uint32_t var59;	// u32
	uint32_t var60;	// u32
	uint32_t var61;	// u32
	int32_t var62;	// i32
	uint32_t var63;	// u32
	uint32_t var64;	// u32
	RUST_BOOL var65;	// bool
	uint32_t var66;	// u32
	uint32_t var67;	// u32
	uint32_t var68;	// u32
	int32_t var69;	// i32
	uint32_t var70;	// u32
	RUST_BOOL var71;	// bool
	uint32_t var72;	// u32
	uint32_t var73;	// u32
	uint32_t var74;	// u32
	uint32_t var75;	// u32
	uint32_t var76;	// u32
	uint32_t var77;	// u32
	uint32_t var78;	// u32
	uint32_t var79;	// u32
	RUST_BOOL var80;	// bool
	uint32_t var81;	// u32
	uint32_t var82;	// u32
	uint32_t var83;	// u32
	uint32_t var84;	// u32
	uint32_t var85;	// u32
	uint32_t var86;	// u32
	uint32_t var87;	// u32
	uint32_t var88;	// u32
	uint32_t var89;	// u32
	var0 = 0x1;	// _0 = Constant(0x1 u32)
	var1 = 0x0;	// _1 = Constant(0x0 u32)
	var2 = 0x20;	// _2 = Constant(0x20 u32)
	var3 = 0x17;	// _3 = Constant(0x17 u32)
	var4 = 0xff;	// _4 = Constant(0xff u32)
	var5 = 0x800000;	// _5 = Constant(0x800000 u32)
	var6 = 0x7fffff;	// _6 = Constant(0x7fffff u32)
	var7 = 0x80000000;	// _7 = Constant(0x80000000 u32)
	var8 = 0x7fffffff;	// _8 = Constant(0x7fffffff u32)
	var9 = 0x7f800000;	// _9 = Constant(0x7f800000 u32)
	var10 = 0x7f800000;	// _10 = Constant(0x7f800000 u32)
	var11 = 0x400000;	// _11 = Constant(0x400000 u32)
	var12 = 0x7fc00000;	// _12 = Constant(0x7fc00000 u32)
	memcpy( &var13, &arg0, sizeof(float ));
	// ^ Call( _13 = "transmute"::<f32,u32,>( a0, ), bb1, bb4)
	memcpy( &var14, &arg1, sizeof(float ));
	// ^ Call( _14 = "transmute"::<f32,u32,>( a1, ), bb2, bb4)
	var15 = var13 & var8;	// _15 = BinOp(_13 BIT_AND _8)
	var16 = var14 & var8;	// _16 = BinOp(_14 BIT_AND _8)
	__builtin_sub_overflow(var15, var0, &var31);
	// ^ Call( _31 = "overflowing_sub"::<u32,>( _15, _0, ), bb3, bb4)
	var32 = var10 - var0;	// _32 = BinOp(_10 SUB _0)
	var30 = var31 >= var32;	// _30 = BinOp(_31 GE _32)
	if(var30) goto bb7; else goto bb5;
	// ^ If( _30 : 7, 5)
bb4: _Unwind_Resume(); // Diverge
bb5:
	__builtin_sub_overflow(var16, var0, &var33);
	// ^ Call( _33 = "overflowing_sub"::<u32,>( _16, _0, ), bb6, bb4)
	var34 = var10 - var0;	// _34 = BinOp(_10 SUB _0)
	var30 = var33 >= var34;	// _30 = BinOp(_33 GE _34)
	if(var30) goto bb7; else goto bb8;
	// ^ If( _30 : 7, 8)
bb7:
	var30 = var15 > var10;	// _30 = BinOp(_15 GT _10)
	if(var30) goto bb43; else goto bb44;
	// ^ If( _30 : 43, 44)
bb8:
	var30 = var16 > var15;	// _30 = BinOp(_16 GT _15)
	if(var30) goto bb9; else goto bb10;
	// ^ If( _30 : 9, 10)
bb9:
	var17 = var13;	// _17 = Use(_13)
	var13 = var14;	// _13 = Use(_14)
	var14 = var17;	// _14 = Use(_17)
	// ^ Goto(10)
bb10:
	var55 = var13 & var9;	// _55 = BinOp(_13 BIT_AND _9)
	var56 = var55 >> var3;	// _56 = BinOp(_55 BIT_SHR _3)
	var18 = (int32_t )var56;	// _18 = Cast(_56 as i32)
	var57 = var14 & var9;	// _57 = BinOp(_14 BIT_AND _9)
	var58 = var57 >> var3;	// _58 = BinOp(_57 BIT_SHR _3)
	var19 = (int32_t )var58;	// _19 = Cast(_58 as i32)
	var20 = var13 & var6;	// _20 = BinOp(_13 BIT_AND _6)
	var21 = var14 & var6;	// _21 = BinOp(_14 BIT_AND _6)
	var30 = var18 == 0;	// _30 = BinOp(_18 EQ +0 i32)
	if(var30) goto bb11; else goto bb13;
	// ^ If( _30 : 11, 13)
bb11:
	var36 = ZRQCn2cR25compiler_builtins0_0_0_Hb5float5Float0g9normalize0g( var20 );
	// ^ Call( _36 = <f32 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::normalize( _20, ), bb12, bb4)
	var20 = var36._1;	// _20 = Use(_36.1)
	var18 = var36._0;	// _18 = Use(_36.0)
	// ^ Goto(13)
bb13:
	var30 = var19 == 0;	// _30 = BinOp(_19 EQ +0 i32)
	if(var30) goto bb14; else goto bb16;
	// ^ If( _30 : 14, 16)
bb14:
	var37 = ZRQCn2cR25compiler_builtins0_0_0_Hb5float5Float0g9normalize0g( var21 );
	// ^ Call( _37 = <f32 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::normalize( _21, ), bb15, bb4)
	var21 = var37._1;	// _21 = Use(_37.1)
	var19 = var37._0;	// _19 = Use(_37.0)
	// ^ Goto(16)
bb16:
	var22 = var13 & var7;	// _22 = BinOp(_13 BIT_AND _7)
	var59 = var13 ^ var14;	// _59 = BinOp(_13 BIT_XOR _14)
	var38 = var59 & var7;	// _38 = BinOp(_59 BIT_AND _7)
	var23 = var38 != var1;	// _23 = BinOp(_38 NE _1)
	var60 = var20 | var5;	// _60 = BinOp(_20 BIT_OR _5)
	var20 = var60 << 0x3;	// _20 = BinOp(_60 BIT_SHL 0x3 u32)
	var61 = var21 | var5;	// _61 = BinOp(_21 BIT_OR _5)
	var21 = var61 << 0x3;	// _21 = BinOp(_61 BIT_SHL 0x3 u32)
	__builtin_sub_overflow(var18, var19, &var62);
	// ^ Call( _62 = "overflowing_sub"::<i32,>( _18, _19, ), bb17, bb4)
	var24 = (uint32_t )var62;	// _24 = Cast(_62 as u32)
	var30 = var24 != 0x0;	// _30 = BinOp(_24 NE 0x0 u32)
	if(var30) goto bb18; else goto bb19;
	// ^ If( _30 : 18, 19)
bb18:
	var30 = var24 < var2;	// _30 = BinOp(_24 LT _2)
	if(var30) goto bb40; else goto bb42;
	// ^ If( _30 : 40, 42)
bb19:
	var30 = var23;	// _30 = Use(_23)
	if(var23) goto bb20; else goto bb22;
	// ^ If( _23 : 20, 22)
bb20:
	var63 = var20;	// _63 = Use(_20)
	__builtin_sub_overflow(var63, var21, &var20);
	// ^ Call( _20 = "overflowing_sub"::<u32,>( _63, _21, ), bb21, bb4)
	var30 = var20 == 0x0;	// _30 = BinOp(_20 EQ 0x0 u32)
	if(var30) goto bb35; else goto bb36;
	// ^ If( _30 : 35, 36)
bb22:
	var46 = & var20;	// _46 = Borrow(Unique, _20)
	(*var46) = (*var46) + var21;	// _46* = BinOp(_46* ADD _21)
	// ^ drop(_46)
	var64 = var5 << 0x4;	// _64 = BinOp(_5 BIT_SHL 0x4 u32)
	var47 = var20 & var64;	// _47 = BinOp(_20 BIT_AND _64)
	var30 = var47 != 0x0;	// _30 = BinOp(_47 NE 0x0 u32)
	if(var30) goto bb23; else goto bb24;
	// ^ If( _30 : 23, 24)
bb23:
	var48 = var20 & var0;	// _48 = BinOp(_20 BIT_AND _0)
	var65 = var48 != 0x0;	// _65 = BinOp(_48 NE 0x0 u32)
	var67 = (uint32_t )var65;	// _67 = Cast(_65 as u32)
	var66 = var20 >> 0x1;	// _66 = BinOp(_20 BIT_SHR 0x1 u32)
	var20 = var66 | var67;	// _20 = BinOp(_66 BIT_OR _67)
	var18 = var18 + 1;	// _18 = BinOp(_18 ADD +1 i32)
	// ^ Goto(24)
bb24:
	var49 = (int32_t )var4;	// _49 = Cast(_4 as i32)
	var30 = var18 >= var49;	// _30 = BinOp(_18 GE _49)
	if(var30) goto bb25; else goto bb26;
	// ^ If( _30 : 25, 26)
bb25:
	var68 = var10 | var22;	// _68 = BinOp(_10 BIT_OR _22)
	memcpy( &rv, &var68, sizeof(uint32_t ));
	goto bb34;
	// ^ Call( retval = "transmute"::<u32,f32,>( _68, ), bb34, bb4)
bb26:
	var30 = var18 <= 0;	// _30 = BinOp(_18 LE +0 i32)
	if(var30) goto bb27; else goto bb29;
	// ^ If( _30 : 27, 29)
bb27:
	var69 = 1 - var18;	// _69 = BinOp(+1 i32 SUB _18)
	var26 = (uint32_t )var69;	// _26 = Cast(_69 as u32)
	__builtin_sub_overflow(var2, var26, &var70);
	// ^ Call( _70 = "overflowing_sub"::<u32,>( _2, _26, ), bb28, bb4)
	var50 = var20 << var70;	// _50 = BinOp(_20 BIT_SHL _70)
	var71 = var50 != 0x0;	// _71 = BinOp(_50 NE 0x0 u32)
	var73 = (uint32_t )var71;	// _73 = Cast(_71 as u32)
	var72 = var20 >> var26;	// _72 = BinOp(_20 BIT_SHR _26)
	var20 = var72 | var73;	// _20 = BinOp(_72 BIT_OR _73)
	var18 = 0;	// _18 = Constant(+0 i32)
	// ^ Goto(29)
bb29:
	var27 = (int32_t )var20;	// _27 = Cast(_20 as i32)
	var28 = var27 & 7;	// _28 = BinOp(_27 BIT_AND +7 i32)
	var74 = var20 >> 0x3;	// _74 = BinOp(_20 BIT_SHR 0x3 u32)
	var29 = var74 & var6;	// _29 = BinOp(_74 BIT_AND _6)
	var51 = & var29;	// _51 = Borrow(Unique, _29)
	var75 = (uint32_t )var18;	// _75 = Cast(_18 as u32)
	var76 = var75 << var3;	// _76 = BinOp(_75 BIT_SHL _3)
	(*var51) = (*var51) | var76;	// _51* = BinOp(_51* BIT_OR _76)
	// ^ drop(_51)
	var52 = & var29;	// _52 = Borrow(Unique, _29)
	(*var52) = (*var52) | var22;	// _52* = BinOp(_52* BIT_OR _22)
	// ^ drop(_52)
	var30 = var28 > 4;	// _30 = BinOp(_28 GT +4 i32)
	if(var30) goto bb30; else goto bb31;
	// ^ If( _30 : 30, 31)
bb30:
	var53 = & var29;	// _53 = Borrow(Unique, _29)
	(*var53) = (*var53) + var0;	// _53* = BinOp(_53* ADD _0)
	// ^ drop(_53)
	// ^ Goto(31)
bb31:
	var30 = var28 == 4;	// _30 = BinOp(_28 EQ +4 i32)
	if(var30) goto bb32; else goto bb33;
	// ^ If( _30 : 32, 33)
bb32:
	var54 = & var29;	// _54 = Borrow(Unique, _29)
	var77 = var29 & var0;	// _77 = BinOp(_29 BIT_AND _0)
	(*var54) = (*var54) + var77;	// _54* = BinOp(_54* ADD _77)
	// ^ drop(_54)
	// ^ Goto(33)
bb33:
	memcpy( &rv, &var29, sizeof(uint32_t ));
	// ^ Call( retval = "transmute"::<u32,f32,>( _29, ), bb34, bb4)
bb34:
	return rv;
	// ^ Return
bb35:
	{ uint32_t v = 0x0; memcpy( &rv, &v, sizeof(float )); };
	goto bb34;
	// ^ Call( retval = "transmute"::<u32,f32,>( 0x0 u32, ), bb34, bb4)
bb36:
	var40 = var5 << 0x3;	// _40 = BinOp(_5 BIT_SHL 0x3 u32)
	var30 = var20 < var40;	// _30 = BinOp(_20 LT _40)
	if(var30) goto bb37; else goto bb24;
	// ^ If( _30 : 37, 24)
bb37:
	var41 = (var20 != 0 ? __builtin_clz(var20) : sizeof(uint32_t )*8);
	// ^ Call( _41 = "ctlz"::<u32,>( _20, ), bb38, bb4)
	var42 = (int32_t )var41;	// _42 = Cast(_41 as i32)
	var78 = var5 << 0x3;	// _78 = BinOp(_5 BIT_SHL 0x3 u32)
	var43 = (var78 != 0 ? __builtin_clz(var78) : sizeof(uint32_t )*8);
	// ^ Call( _43 = "ctlz"::<u32,>( _78, ), bb39, bb4)
	var44 = (int32_t )var43;	// _44 = Cast(_43 as i32)
	var25 = var42 - var44;	// _25 = BinOp(_42 SUB _44)
	var45 = & var20;	// _45 = Borrow(Unique, _20)
	(*var45) = (*var45) << var25;	// _45* = BinOp(_45* BIT_SHL _25)
	// ^ drop(_45)
	var18 = var18 - var25;	// _18 = BinOp(_18 SUB _25)
	goto bb24;
	// ^ Goto(24)
bb40:
	__builtin_sub_overflow(var2, var24, &var79);
	// ^ Call( _79 = "overflowing_sub"::<u32,>( _2, _24, ), bb41, bb4)
	var39 = var21 << var79;	// _39 = BinOp(_21 BIT_SHL _79)
	var80 = var39 != 0x0;	// _80 = BinOp(_39 NE 0x0 u32)
	var82 = (uint32_t )var80;	// _82 = Cast(_80 as u32)
	var81 = var21 >> var24;	// _81 = BinOp(_21 BIT_SHR _24)
	var21 = var81 | var82;	// _21 = BinOp(_81 BIT_OR _82)
	goto bb19;
	// ^ Goto(19)
bb42:
	var21 = var0;	// _21 = Use(_0)
	goto bb19;
	// ^ Goto(19)
bb43:
	var83 = var15 | var11;	// _83 = BinOp(_15 BIT_OR _11)
	memcpy( &rv, &var83, sizeof(uint32_t ));
	goto bb34;
	// ^ Call( retval = "transmute"::<u32,f32,>( _83, ), bb34, bb4)
bb44:
	var30 = var16 > var10;	// _30 = BinOp(_16 GT _10)
	if(var30) goto bb45; else goto bb46;
	// ^ If( _30 : 45, 46)
bb45:
	var84 = var16 | var11;	// _84 = BinOp(_16 BIT_OR _11)
	memcpy( &rv, &var84, sizeof(uint32_t ));
	goto bb34;
	// ^ Call( retval = "transmute"::<u32,f32,>( _84, ), bb34, bb4)
bb46:
	var30 = var15 == var10;	// _30 = BinOp(_15 EQ _10)
	if(var30) goto bb47; else goto bb50;
	// ^ If( _30 : 47, 50)
bb47:
	memcpy( &var85, &arg0, sizeof(float ));
	// ^ Call( _85 = "transmute"::<f32,u32,>( a0, ), bb48, bb4)
	memcpy( &var86, &arg1, sizeof(float ));
	// ^ Call( _86 = "transmute"::<f32,u32,>( a1, ), bb49, bb4)
	var35 = var85 ^ var86;	// _35 = BinOp(_85 BIT_XOR _86)
	var30 = var35 == var7;	// _30 = BinOp(_35 EQ _7)
	if(var30) goto bb59; else goto bb54;
	// ^ If( _30 : 59, 54)
bb50:
	var30 = var16 == var10;	// _30 = BinOp(_16 EQ _10)
	if(var30) goto bb58; else goto bb51;
	// ^ If( _30 : 58, 51)
bb51:
	var30 = var15 == 0x0;	// _30 = BinOp(_15 EQ 0x0 u32)
	if(var30) goto bb52; else goto bb53;
	// ^ If( _30 : 52, 53)
bb52:
	var30 = var16 == 0x0;	// _30 = BinOp(_16 EQ 0x0 u32)
	if(var30) goto bb55; else goto bb58;
	// ^ If( _30 : 55, 58)
bb53:
	var30 = var16 == 0x0;	// _30 = BinOp(_16 EQ 0x0 u32)
	if(var30) goto bb54; else goto bb8;
	// ^ If( _30 : 54, 8)
bb54:
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
bb55:
	memcpy( &var87, &arg0, sizeof(float ));
	// ^ Call( _87 = "transmute"::<f32,u32,>( a0, ), bb56, bb4)
	memcpy( &var88, &arg1, sizeof(float ));
	// ^ Call( _88 = "transmute"::<f32,u32,>( a1, ), bb57, bb4)
	var89 = var87 & var88;	// _89 = BinOp(_87 BIT_AND _88)
	memcpy( &rv, &var89, sizeof(uint32_t ));
	goto bb34;
	// ^ Call( retval = "transmute"::<u32,f32,>( _89, ), bb34, bb4)
bb58:
	rv = arg1;	// retval = Use(a1)
	return rv;
	// ^ Return
bb59:
	memcpy( &rv, &var12, sizeof(uint32_t ));
	goto bb34;
	// ^ Call( retval = "transmute"::<u32,f32,>( _12, ), bb34, bb4)
}
// ::"compiler_builtins-0_0_0_Hb"::float::add::add<f64,>
double  ZRG3cR25compiler_builtins0_0_0_Hb5float3add_C1gCo(
		double arg0, // f64
		double arg1 // f64
		) // -> f64

{
	double rv;
	uint64_t var0;	// u64
	uint64_t var1;	// u64
	uint64_t var2;	// u64
	uint32_t var3;	// u32
	uint32_t var4;	// u32
	uint64_t var5;	// u64
	uint64_t var6;	// u64
	uint64_t var7;	// u64
	uint64_t var8;	// u64
	uint64_t var9;	// u64
	uint64_t var10;	// u64
	uint64_t var11;	// u64
	uint64_t var12;	// u64
	uint64_t var13;	// u64
	uint64_t var14;	// u64
	uint64_t var15;	// u64
	uint64_t var16;	// u64
	uint64_t var17;	// u64
	int32_t var18;	// i32
	int32_t var19;	// i32
	uint64_t var20;	// u64
	uint64_t var21;	// u64
	uint64_t var22;	// u64
	RUST_BOOL var23;	// bool
	uint64_t var24;	// u64
	int32_t var25;	// i32
	uint64_t var26;	// u64
	int32_t var27;	// i32
	int32_t var28;	// i32
	uint64_t var29;	// u64
	RUST_BOOL var30;	// bool
	uint64_t var31;	// u64
	uint64_t var32;	// u64
	uint64_t var33;	// u64
	uint64_t var34;	// u64
	uint64_t var35;	// u64
	TUP_2_ZRTCf_ZRTCg var36;	// (i32, u64, )
	TUP_2_ZRTCf_ZRTCg var37;	// (i32, u64, )
	uint64_t var38;	// u64
	uint64_t var39;	// u64
	uint64_t var40;	// u64
	uint32_t var41;	// u32
	int32_t var42;	// i32
	uint32_t var43;	// u32
	int32_t var44;	// i32
	uint64_t *var45;	// &'#omitted mut u64
	uint64_t *var46;	// &'#omitted mut u64
	uint64_t var47;	// u64
	uint64_t var48;	// u64
	int32_t var49;	// i32
	uint64_t var50;	// u64
	uint64_t *var51;	// &'#omitted mut u64
	uint64_t *var52;	// &'#omitted mut u64
	uint64_t *var53;	// &'#omitted mut u64
	uint64_t *var54;	// &'#omitted mut u64
	uint64_t var55;	// u64
	uint64_t var56;	// u64
	uint64_t var57;	// u64
	uint64_t var58;	// u64
	uint64_t var59;	// u64
	uint64_t var60;	// u64
	uint64_t var61;	// u64
	int32_t var62;	// i32
	uint64_t var63;	// u64
	uint64_t var64;	// u64
	RUST_BOOL var65;	// bool
	uint64_t var66;	// u64
	uint64_t var67;	// u64
	uint64_t var68;	// u64
	int32_t var69;	// i32
	uint64_t var70;	// u64
	uint32_t var71;	// u32
	RUST_BOOL var72;	// bool
	uint32_t var73;	// u32
	uint64_t var74;	// u64
	uint64_t var75;	// u64
	uint64_t var76;	// u64
	uint64_t var77;	// u64
	uint64_t var78;	// u64
	uint64_t var79;	// u64
	uint64_t var80;	// u64
	uint64_t var81;	// u64
	uint64_t var82;	// u64
	uint64_t var83;	// u64
	uint32_t var84;	// u32
	RUST_BOOL var85;	// bool
	uint32_t var86;	// u32
	uint64_t var87;	// u64
	uint64_t var88;	// u64
	uint64_t var89;	// u64
	uint64_t var90;	// u64
	uint64_t var91;	// u64
	uint64_t var92;	// u64
	uint64_t var93;	// u64
	uint64_t var94;	// u64
	uint64_t var95;	// u64
	var0 = 0x1ull;	// _0 = Constant(0x1 u64)
	var1 = 0x0ull;	// _1 = Constant(0x0 u64)
	var2 = 0x40ull;	// _2 = Constant(0x40 u64)
	var3 = 0x34;	// _3 = Constant(0x34 u32)
	var4 = 0x7ff;	// _4 = Constant(0x7ff u32)
	var5 = 0x10000000000000ull;	// _5 = Constant(0x10000000000000 u64)
	var6 = 0xfffffffffffffull;	// _6 = Constant(0xfffffffffffff u64)
	var7 = 0x8000000000000000ull;	// _7 = Constant(0x8000000000000000 u64)
	var8 = 0x7fffffffffffffffull;	// _8 = Constant(0x7fffffffffffffff u64)
	var9 = 0x7ff0000000000000ull;	// _9 = Constant(0x7ff0000000000000 u64)
	var10 = 0x7ff0000000000000ull;	// _10 = Constant(0x7ff0000000000000 u64)
	var11 = 0x8000000000000ull;	// _11 = Constant(0x8000000000000 u64)
	var12 = 0x7ff8000000000000ull;	// _12 = Constant(0x7ff8000000000000 u64)
	memcpy( &var13, &arg0, sizeof(double ));
	// ^ Call( _13 = "transmute"::<f64,u64,>( a0, ), bb1, bb4)
	memcpy( &var14, &arg1, sizeof(double ));
	// ^ Call( _14 = "transmute"::<f64,u64,>( a1, ), bb2, bb4)
	var15 = var13 & var8;	// _15 = BinOp(_13 BIT_AND _8)
	var16 = var14 & var8;	// _16 = BinOp(_14 BIT_AND _8)
	__builtin_sub_overflow(var15, var0, &var31);
	// ^ Call( _31 = "overflowing_sub"::<u64,>( _15, _0, ), bb3, bb4)
	var32 = var10 - var0;	// _32 = BinOp(_10 SUB _0)
	var30 = var31 >= var32;	// _30 = BinOp(_31 GE _32)
	if(var30) goto bb7; else goto bb5;
	// ^ If( _30 : 7, 5)
bb4: _Unwind_Resume(); // Diverge
bb5:
	__builtin_sub_overflow(var16, var0, &var33);
	// ^ Call( _33 = "overflowing_sub"::<u64,>( _16, _0, ), bb6, bb4)
	var34 = var10 - var0;	// _34 = BinOp(_10 SUB _0)
	var30 = var33 >= var34;	// _30 = BinOp(_33 GE _34)
	if(var30) goto bb7; else goto bb8;
	// ^ If( _30 : 7, 8)
bb7:
	var30 = var15 > var10;	// _30 = BinOp(_15 GT _10)
	if(var30) goto bb43; else goto bb44;
	// ^ If( _30 : 43, 44)
bb8:
	var30 = var16 > var15;	// _30 = BinOp(_16 GT _15)
	if(var30) goto bb9; else goto bb10;
	// ^ If( _30 : 9, 10)
bb9:
	var17 = var13;	// _17 = Use(_13)
	var13 = var14;	// _13 = Use(_14)
	var14 = var17;	// _14 = Use(_17)
	// ^ Goto(10)
bb10:
	var55 = var13 & var9;	// _55 = BinOp(_13 BIT_AND _9)
	var56 = var55 >> var3;	// _56 = BinOp(_55 BIT_SHR _3)
	var18 = (int32_t )var56;	// _18 = Cast(_56 as i32)
	var57 = var14 & var9;	// _57 = BinOp(_14 BIT_AND _9)
	var58 = var57 >> var3;	// _58 = BinOp(_57 BIT_SHR _3)
	var19 = (int32_t )var58;	// _19 = Cast(_58 as i32)
	var20 = var13 & var6;	// _20 = BinOp(_13 BIT_AND _6)
	var21 = var14 & var6;	// _21 = BinOp(_14 BIT_AND _6)
	var30 = var18 == 0;	// _30 = BinOp(_18 EQ +0 i32)
	if(var30) goto bb11; else goto bb13;
	// ^ If( _30 : 11, 13)
bb11:
	var36 = ZRQCo2cR25compiler_builtins0_0_0_Hb5float5Float0g9normalize0g( var20 );
	// ^ Call( _36 = <f64 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::normalize( _20, ), bb12, bb4)
	var20 = var36._1;	// _20 = Use(_36.1)
	var18 = var36._0;	// _18 = Use(_36.0)
	// ^ Goto(13)
bb13:
	var30 = var19 == 0;	// _30 = BinOp(_19 EQ +0 i32)
	if(var30) goto bb14; else goto bb16;
	// ^ If( _30 : 14, 16)
bb14:
	var37 = ZRQCo2cR25compiler_builtins0_0_0_Hb5float5Float0g9normalize0g( var21 );
	// ^ Call( _37 = <f64 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::normalize( _21, ), bb15, bb4)
	var21 = var37._1;	// _21 = Use(_37.1)
	var19 = var37._0;	// _19 = Use(_37.0)
	// ^ Goto(16)
bb16:
	var22 = var13 & var7;	// _22 = BinOp(_13 BIT_AND _7)
	var59 = var13 ^ var14;	// _59 = BinOp(_13 BIT_XOR _14)
	var38 = var59 & var7;	// _38 = BinOp(_59 BIT_AND _7)
	var23 = var38 != var1;	// _23 = BinOp(_38 NE _1)
	var60 = var20 | var5;	// _60 = BinOp(_20 BIT_OR _5)
	var20 = var60 << 0x3;	// _20 = BinOp(_60 BIT_SHL 0x3 u32)
	var61 = var21 | var5;	// _61 = BinOp(_21 BIT_OR _5)
	var21 = var61 << 0x3;	// _21 = BinOp(_61 BIT_SHL 0x3 u32)
	__builtin_sub_overflow(var18, var19, &var62);
	// ^ Call( _62 = "overflowing_sub"::<i32,>( _18, _19, ), bb17, bb4)
	var24 = (uint64_t )var62;	// _24 = Cast(_62 as u64)
	var30 = var24 != 0x0ull;	// _30 = BinOp(_24 NE 0x0 u64)
	if(var30) goto bb18; else goto bb19;
	// ^ If( _30 : 18, 19)
bb18:
	var30 = var24 < var2;	// _30 = BinOp(_24 LT _2)
	if(var30) goto bb40; else goto bb42;
	// ^ If( _30 : 40, 42)
bb19:
	var30 = var23;	// _30 = Use(_23)
	if(var23) goto bb20; else goto bb22;
	// ^ If( _23 : 20, 22)
bb20:
	var63 = var20;	// _63 = Use(_20)
	__builtin_sub_overflow(var63, var21, &var20);
	// ^ Call( _20 = "overflowing_sub"::<u64,>( _63, _21, ), bb21, bb4)
	var30 = var20 == 0x0ull;	// _30 = BinOp(_20 EQ 0x0 u64)
	if(var30) goto bb35; else goto bb36;
	// ^ If( _30 : 35, 36)
bb22:
	var46 = & var20;	// _46 = Borrow(Unique, _20)
	(*var46) = (*var46) + var21;	// _46* = BinOp(_46* ADD _21)
	// ^ drop(_46)
	var64 = var5 << 0x4;	// _64 = BinOp(_5 BIT_SHL 0x4 u32)
	var47 = var20 & var64;	// _47 = BinOp(_20 BIT_AND _64)
	var30 = var47 != 0x0ull;	// _30 = BinOp(_47 NE 0x0 u64)
	if(var30) goto bb23; else goto bb24;
	// ^ If( _30 : 23, 24)
bb23:
	var48 = var20 & var0;	// _48 = BinOp(_20 BIT_AND _0)
	var65 = var48 != 0x0ull;	// _65 = BinOp(_48 NE 0x0 u64)
	var67 = (uint64_t )var65;	// _67 = Cast(_65 as u64)
	var66 = var20 >> 0x1;	// _66 = BinOp(_20 BIT_SHR 0x1 u32)
	var20 = var66 | var67;	// _20 = BinOp(_66 BIT_OR _67)
	var18 = var18 + 1;	// _18 = BinOp(_18 ADD +1 i32)
	// ^ Goto(24)
bb24:
	var49 = (int32_t )var4;	// _49 = Cast(_4 as i32)
	var30 = var18 >= var49;	// _30 = BinOp(_18 GE _49)
	if(var30) goto bb25; else goto bb26;
	// ^ If( _30 : 25, 26)
bb25:
	var68 = var10 | var22;	// _68 = BinOp(_10 BIT_OR _22)
	memcpy( &rv, &var68, sizeof(uint64_t ));
	goto bb34;
	// ^ Call( retval = "transmute"::<u64,f64,>( _68, ), bb34, bb4)
bb26:
	var30 = var18 <= 0;	// _30 = BinOp(_18 LE +0 i32)
	if(var30) goto bb27; else goto bb29;
	// ^ If( _30 : 27, 29)
bb27:
	var69 = 1 - var18;	// _69 = BinOp(+1 i32 SUB _18)
	var26 = (uint64_t )var69;	// _26 = Cast(_69 as u64)
	__builtin_sub_overflow(var2, var26, &var70);
	// ^ Call( _70 = "overflowing_sub"::<u64,>( _2, _26, ), bb28, bb4)
	var71 = (uint32_t )var70;	// _71 = Cast(_70 as u32)
	var50 = var20 << var71;	// _50 = BinOp(_20 BIT_SHL _71)
	var72 = var50 != 0x0ull;	// _72 = BinOp(_50 NE 0x0 u64)
	var75 = (uint64_t )var72;	// _75 = Cast(_72 as u64)
	var73 = (uint32_t )var26;	// _73 = Cast(_26 as u32)
	var74 = var20 >> var73;	// _74 = BinOp(_20 BIT_SHR _73)
	var20 = var74 | var75;	// _20 = BinOp(_74 BIT_OR _75)
	var18 = 0;	// _18 = Constant(+0 i32)
	// ^ Goto(29)
bb29:
	var27 = (int32_t )var20;	// _27 = Cast(_20 as i32)
	var28 = var27 & 7;	// _28 = BinOp(_27 BIT_AND +7 i32)
	var76 = var20 >> 0x3;	// _76 = BinOp(_20 BIT_SHR 0x3 u32)
	var29 = var76 & var6;	// _29 = BinOp(_76 BIT_AND _6)
	var51 = & var29;	// _51 = Borrow(Unique, _29)
	var77 = (uint64_t )var18;	// _77 = Cast(_18 as u64)
	var78 = var77 << var3;	// _78 = BinOp(_77 BIT_SHL _3)
	(*var51) = (*var51) | var78;	// _51* = BinOp(_51* BIT_OR _78)
	// ^ drop(_51)
	var52 = & var29;	// _52 = Borrow(Unique, _29)
	(*var52) = (*var52) | var22;	// _52* = BinOp(_52* BIT_OR _22)
	// ^ drop(_52)
	var30 = var28 > 4;	// _30 = BinOp(_28 GT +4 i32)
	if(var30) goto bb30; else goto bb31;
	// ^ If( _30 : 30, 31)
bb30:
	var53 = & var29;	// _53 = Borrow(Unique, _29)
	(*var53) = (*var53) + var0;	// _53* = BinOp(_53* ADD _0)
	// ^ drop(_53)
	// ^ Goto(31)
bb31:
	var30 = var28 == 4;	// _30 = BinOp(_28 EQ +4 i32)
	if(var30) goto bb32; else goto bb33;
	// ^ If( _30 : 32, 33)
bb32:
	var54 = & var29;	// _54 = Borrow(Unique, _29)
	var79 = var29 & var0;	// _79 = BinOp(_29 BIT_AND _0)
	(*var54) = (*var54) + var79;	// _54* = BinOp(_54* ADD _79)
	// ^ drop(_54)
	// ^ Goto(33)
bb33:
	memcpy( &rv, &var29, sizeof(uint64_t ));
	// ^ Call( retval = "transmute"::<u64,f64,>( _29, ), bb34, bb4)
bb34:
	return rv;
	// ^ Return
bb35:
	{ uint64_t v = 0x0ull; memcpy( &rv, &v, sizeof(double )); };
	goto bb34;
	// ^ Call( retval = "transmute"::<u64,f64,>( 0x0 u64, ), bb34, bb4)
bb36:
	var40 = var5 << 0x3;	// _40 = BinOp(_5 BIT_SHL 0x3 u32)
	var30 = var20 < var40;	// _30 = BinOp(_20 LT _40)
	if(var30) goto bb37; else goto bb24;
	// ^ If( _30 : 37, 24)
bb37:
	var80 = (var20 != 0 ? __builtin_clz64(var20) : sizeof(uint64_t )*8);
	// ^ Call( _80 = "ctlz"::<u64,>( _20, ), bb38, bb4)
	var41 = (uint32_t )var80;	// _41 = Cast(_80 as u32)
	var42 = (int32_t )var41;	// _42 = Cast(_41 as i32)
	var82 = var5 << 0x3;	// _82 = BinOp(_5 BIT_SHL 0x3 u32)
	var81 = (var82 != 0 ? __builtin_clz64(var82) : sizeof(uint64_t )*8);
	// ^ Call( _81 = "ctlz"::<u64,>( _82, ), bb39, bb4)
	var43 = (uint32_t )var81;	// _43 = Cast(_81 as u32)
	var44 = (int32_t )var43;	// _44 = Cast(_43 as i32)
	var25 = var42 - var44;	// _25 = BinOp(_42 SUB _44)
	var45 = & var20;	// _45 = Borrow(Unique, _20)
	(*var45) = (*var45) << var25;	// _45* = BinOp(_45* BIT_SHL _25)
	// ^ drop(_45)
	var18 = var18 - var25;	// _18 = BinOp(_18 SUB _25)
	goto bb24;
	// ^ Goto(24)
bb40:
	__builtin_sub_overflow(var2, var24, &var83);
	// ^ Call( _83 = "overflowing_sub"::<u64,>( _2, _24, ), bb41, bb4)
	var84 = (uint32_t )var83;	// _84 = Cast(_83 as u32)
	var39 = var21 << var84;	// _39 = BinOp(_21 BIT_SHL _84)
	var85 = var39 != 0x0ull;	// _85 = BinOp(_39 NE 0x0 u64)
	var88 = (uint64_t )var85;	// _88 = Cast(_85 as u64)
	var86 = (uint32_t )var24;	// _86 = Cast(_24 as u32)
	var87 = var21 >> var86;	// _87 = BinOp(_21 BIT_SHR _86)
	var21 = var87 | var88;	// _21 = BinOp(_87 BIT_OR _88)
	goto bb19;
	// ^ Goto(19)
bb42:
	var21 = var0;	// _21 = Use(_0)
	goto bb19;
	// ^ Goto(19)
bb43:
	var89 = var15 | var11;	// _89 = BinOp(_15 BIT_OR _11)
	memcpy( &rv, &var89, sizeof(uint64_t ));
	goto bb34;
	// ^ Call( retval = "transmute"::<u64,f64,>( _89, ), bb34, bb4)
bb44:
	var30 = var16 > var10;	// _30 = BinOp(_16 GT _10)
	if(var30) goto bb45; else goto bb46;
	// ^ If( _30 : 45, 46)
bb45:
	var90 = var16 | var11;	// _90 = BinOp(_16 BIT_OR _11)
	memcpy( &rv, &var90, sizeof(uint64_t ));
	goto bb34;
	// ^ Call( retval = "transmute"::<u64,f64,>( _90, ), bb34, bb4)
bb46:
	var30 = var15 == var10;	// _30 = BinOp(_15 EQ _10)
	if(var30) goto bb47; else goto bb50;
	// ^ If( _30 : 47, 50)
bb47:
	memcpy( &var91, &arg0, sizeof(double ));
	// ^ Call( _91 = "transmute"::<f64,u64,>( a0, ), bb48, bb4)
	memcpy( &var92, &arg1, sizeof(double ));
	// ^ Call( _92 = "transmute"::<f64,u64,>( a1, ), bb49, bb4)
	var35 = var91 ^ var92;	// _35 = BinOp(_91 BIT_XOR _92)
	var30 = var35 == var7;	// _30 = BinOp(_35 EQ _7)
	if(var30) goto bb59; else goto bb54;
	// ^ If( _30 : 59, 54)
bb50:
	var30 = var16 == var10;	// _30 = BinOp(_16 EQ _10)
	if(var30) goto bb58; else goto bb51;
	// ^ If( _30 : 58, 51)
bb51:
	var30 = var15 == 0x0ull;	// _30 = BinOp(_15 EQ 0x0 u64)
	if(var30) goto bb52; else goto bb53;
	// ^ If( _30 : 52, 53)
bb52:
	var30 = var16 == 0x0ull;	// _30 = BinOp(_16 EQ 0x0 u64)
	if(var30) goto bb55; else goto bb58;
	// ^ If( _30 : 55, 58)
bb53:
	var30 = var16 == 0x0ull;	// _30 = BinOp(_16 EQ 0x0 u64)
	if(var30) goto bb54; else goto bb8;
	// ^ If( _30 : 54, 8)
bb54:
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
bb55:
	memcpy( &var93, &arg0, sizeof(double ));
	// ^ Call( _93 = "transmute"::<f64,u64,>( a0, ), bb56, bb4)
	memcpy( &var94, &arg1, sizeof(double ));
	// ^ Call( _94 = "transmute"::<f64,u64,>( a1, ), bb57, bb4)
	var95 = var93 & var94;	// _95 = BinOp(_93 BIT_AND _94)
	memcpy( &rv, &var95, sizeof(uint64_t ));
	goto bb34;
	// ^ Call( retval = "transmute"::<u64,f64,>( _95, ), bb34, bb4)
bb58:
	rv = arg1;	// retval = Use(a1)
	return rv;
	// ^ Return
bb59:
	memcpy( &rv, &var12, sizeof(uint64_t ));
	goto bb34;
	// ^ Call( retval = "transmute"::<u64,f64,>( _12, ), bb34, bb4)
}
// ::"compiler_builtins-0_0_0_Hb"::float::cmp::__eqdf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__eqdf20g(
		double arg0, // f64
		double arg1 // f64
		) // -> i32

{
	int32_t rv;
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g var0;	// ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
	var0 = ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp_C1gCo( arg0, arg1 );
	// ^ Call( _0 = ::"compiler_builtins-0_0_0_Hb"::float::cmp::cmp<f64,>( a0, a1, ), bb1, bb3)
	rv = ZRIG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g9to_le_abi0g( var0 );
	// ^ Call( retval = <::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/ /*- */>::to_le_abi( _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::cmp::__eqsf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__eqsf20g(
		float arg0, // f32
		float arg1 // f32
		) // -> i32

{
	int32_t rv;
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g var0;	// ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
	var0 = ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp_C1gCn( arg0, arg1 );
	// ^ Call( _0 = ::"compiler_builtins-0_0_0_Hb"::float::cmp::cmp<f32,>( a0, a1, ), bb1, bb3)
	rv = ZRIG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g9to_le_abi0g( var0 );
	// ^ Call( retval = <::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/ /*- */>::to_le_abi( _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::cmp::__gedf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__gedf20g(
		double arg0, // f64
		double arg1 // f64
		) // -> i32

{
	int32_t rv;
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g var0;	// ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
	var0 = ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp_C1gCo( arg0, arg1 );
	// ^ Call( _0 = ::"compiler_builtins-0_0_0_Hb"::float::cmp::cmp<f64,>( a0, a1, ), bb1, bb3)
	rv = ZRIG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g9to_ge_abi0g( var0 );
	// ^ Call( retval = <::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/ /*- */>::to_ge_abi( _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::cmp::__gesf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__gesf20g(
		float arg0, // f32
		float arg1 // f32
		) // -> i32

{
	int32_t rv;
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g var0;	// ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
	var0 = ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp_C1gCn( arg0, arg1 );
	// ^ Call( _0 = ::"compiler_builtins-0_0_0_Hb"::float::cmp::cmp<f32,>( a0, a1, ), bb1, bb3)
	rv = ZRIG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g9to_ge_abi0g( var0 );
	// ^ Call( retval = <::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/ /*- */>::to_ge_abi( _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::cmp::__gtdf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__gtdf20g(
		double arg0, // f64
		double arg1 // f64
		) // -> i32

{
	int32_t rv;
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g var0;	// ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
	var0 = ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp_C1gCo( arg0, arg1 );
	// ^ Call( _0 = ::"compiler_builtins-0_0_0_Hb"::float::cmp::cmp<f64,>( a0, a1, ), bb1, bb3)
	rv = ZRIG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g9to_ge_abi0g( var0 );
	// ^ Call( retval = <::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/ /*- */>::to_ge_abi( _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::cmp::__gtsf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__gtsf20g(
		float arg0, // f32
		float arg1 // f32
		) // -> i32

{
	int32_t rv;
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g var0;	// ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
	var0 = ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp_C1gCn( arg0, arg1 );
	// ^ Call( _0 = ::"compiler_builtins-0_0_0_Hb"::float::cmp::cmp<f32,>( a0, a1, ), bb1, bb3)
	rv = ZRIG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g9to_ge_abi0g( var0 );
	// ^ Call( retval = <::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/ /*- */>::to_ge_abi( _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::cmp::__ledf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__ledf20g(
		double arg0, // f64
		double arg1 // f64
		) // -> i32

{
	int32_t rv;
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g var0;	// ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
	var0 = ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp_C1gCo( arg0, arg1 );
	// ^ Call( _0 = ::"compiler_builtins-0_0_0_Hb"::float::cmp::cmp<f64,>( a0, a1, ), bb1, bb3)
	rv = ZRIG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g9to_le_abi0g( var0 );
	// ^ Call( retval = <::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/ /*- */>::to_le_abi( _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::cmp::__lesf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__lesf20g(
		float arg0, // f32
		float arg1 // f32
		) // -> i32

{
	int32_t rv;
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g var0;	// ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
	var0 = ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp_C1gCn( arg0, arg1 );
	// ^ Call( _0 = ::"compiler_builtins-0_0_0_Hb"::float::cmp::cmp<f32,>( a0, a1, ), bb1, bb3)
	rv = ZRIG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g9to_le_abi0g( var0 );
	// ^ Call( retval = <::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/ /*- */>::to_le_abi( _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::cmp::__ltdf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__ltdf20g(
		double arg0, // f64
		double arg1 // f64
		) // -> i32

{
	int32_t rv;
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g var0;	// ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
	var0 = ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp_C1gCo( arg0, arg1 );
	// ^ Call( _0 = ::"compiler_builtins-0_0_0_Hb"::float::cmp::cmp<f64,>( a0, a1, ), bb1, bb3)
	rv = ZRIG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g9to_le_abi0g( var0 );
	// ^ Call( retval = <::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/ /*- */>::to_le_abi( _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::cmp::__ltsf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__ltsf20g(
		float arg0, // f32
		float arg1 // f32
		) // -> i32

{
	int32_t rv;
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g var0;	// ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
	var0 = ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp_C1gCn( arg0, arg1 );
	// ^ Call( _0 = ::"compiler_builtins-0_0_0_Hb"::float::cmp::cmp<f32,>( a0, a1, ), bb1, bb3)
	rv = ZRIG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g9to_le_abi0g( var0 );
	// ^ Call( retval = <::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/ /*- */>::to_le_abi( _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::cmp::__nedf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__nedf20g(
		double arg0, // f64
		double arg1 // f64
		) // -> i32

{
	int32_t rv;
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g var0;	// ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
	var0 = ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp_C1gCo( arg0, arg1 );
	// ^ Call( _0 = ::"compiler_builtins-0_0_0_Hb"::float::cmp::cmp<f64,>( a0, a1, ), bb1, bb3)
	rv = ZRIG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g9to_le_abi0g( var0 );
	// ^ Call( retval = <::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/ /*- */>::to_le_abi( _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::cmp::__nesf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp7__nesf20g(
		float arg0, // f32
		float arg1 // f32
		) // -> i32

{
	int32_t rv;
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g var0;	// ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
	var0 = ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp_C1gCn( arg0, arg1 );
	// ^ Call( _0 = ::"compiler_builtins-0_0_0_Hb"::float::cmp::cmp<f32,>( a0, a1, ), bb1, bb3)
	rv = ZRIG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g9to_le_abi0g( var0 );
	// ^ Call( retval = <::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/ /*- */>::to_le_abi( _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::cmp::__unorddf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp10__unorddf20g(
		double arg0, // f64
		double arg1 // f64
		) // -> i32

{
	int32_t rv;
	RUST_BOOL var0;	// bool
	var0 = ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp5unord1gCo( arg0, arg1 );
	// ^ Call( _0 = ::"compiler_builtins-0_0_0_Hb"::float::cmp::unord<f64,>( a0, a1, ), bb1, bb2)
	rv = (int32_t )var0;	// retval = Cast(_0 as i32)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::cmp::__unordsf2
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp10__unordsf20g(
		float arg0, // f32
		float arg1 // f32
		) // -> i32

{
	int32_t rv;
	RUST_BOOL var0;	// bool
	var0 = ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp5unord1gCn( arg0, arg1 );
	// ^ Call( _0 = ::"compiler_builtins-0_0_0_Hb"::float::cmp::unord<f32,>( a0, a1, ), bb1, bb2)
	rv = (int32_t )var0;	// retval = Cast(_0 as i32)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::cmp::cmp<f32,>
struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp_C1gCn(
		float arg0, // f32
		float arg1 // f32
		) // -> ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/

{
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g rv;
	uint32_t var0;	// u32
	int32_t var1;	// i32
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	uint32_t var4;	// u32
	uint32_t var5;	// u32
	int32_t var6;	// i32
	int32_t var7;	// i32
	RUST_BOOL var8;	// bool
	uint32_t var9;	// u32
	int32_t var10;	// i32
	uint32_t var11;	// u32
	uint32_t var12;	// u32
	var0 = 0x0;	// _0 = Constant(0x0 u32)
	var1 = 0;	// _1 = Constant(+0 i32)
	var2 = 0x7fffffff;	// _2 = Constant(0x7fffffff u32)
	var3 = 0x7f800000;	// _3 = Constant(0x7f800000 u32)
	memcpy( &var11, &arg0, sizeof(float ));
	// ^ Call( _11 = "transmute"::<f32,u32,>( a0, ), bb1, bb3)
	memcpy( &var12, &arg1, sizeof(float ));
	// ^ Call( _12 = "transmute"::<f32,u32,>( a1, ), bb2, bb3)
	var4 = var11 & var2;	// _4 = BinOp(_11 BIT_AND _2)
	var5 = var12 & var2;	// _5 = BinOp(_12 BIT_AND _2)
	var8 = var4 > var3;	// _8 = BinOp(_4 GT _3)
	if(var8) goto bb5; else goto bb4;
	// ^ If( _8 : 5, 4)
bb3: _Unwind_Resume(); // Diverge
bb4:
	var8 = var5 > var3;	// _8 = BinOp(_5 GT _3)
	if(var8) goto bb5; else goto bb6;
	// ^ If( _8 : 5, 6)
bb5:
	rv.TAG = 3;	// retval = Variant(::"compiler_builtins-0_0_0_Hb"::float::cmp::Result #3, {})
	return rv;
	// ^ Return
bb6:
	var9 = var4 | var5;	// _9 = BinOp(_4 BIT_OR _5)
	var8 = var9 == var0;	// _8 = BinOp(_9 EQ _0)
	if(var8) goto bb14; else goto bb7;
	// ^ If( _8 : 14, 7)
bb7:
	memcpy( &var6, &arg0, sizeof(float ));
	// ^ Call( _6 = "transmute"::<f32,i32,>( a0, ), bb8, bb3)
	memcpy( &var7, &arg1, sizeof(float ));
	// ^ Call( _7 = "transmute"::<f32,i32,>( a1, ), bb9, bb3)
	var10 = var6 & var7;	// _10 = BinOp(_6 BIT_AND _7)
	var8 = var10 >= var1;	// _8 = BinOp(_10 GE _1)
	if(var8) goto bb10; else goto bb11;
	// ^ If( _8 : 10, 11)
bb10:
	var8 = var6 < var7;	// _8 = BinOp(_6 LT _7)
	if(var8) goto bb12; else goto bb13;
	// ^ If( _8 : 12, 13)
bb11:
	var8 = var6 > var7;	// _8 = BinOp(_6 GT _7)
	if(var8) goto bb12; else goto bb13;
	// ^ If( _8 : 12, 13)
bb12:
	rv.TAG = 0;	// retval = Variant(::"compiler_builtins-0_0_0_Hb"::float::cmp::Result #0, {})
	return rv;
	// ^ Return
bb13:
	var8 = var6 == var7;	// _8 = BinOp(_6 EQ _7)
	if(var8) goto bb14; else goto bb15;
	// ^ If( _8 : 14, 15)
bb14:
	rv.TAG = 1;	// retval = Variant(::"compiler_builtins-0_0_0_Hb"::float::cmp::Result #1, {})
	return rv;
	// ^ Return
bb15:
	rv.TAG = 2;	// retval = Variant(::"compiler_builtins-0_0_0_Hb"::float::cmp::Result #2, {})
	return rv;
	// ^ Return
}
// ::"compiler_builtins-0_0_0_Hb"::float::cmp::cmp<f64,>
struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp_C1gCo(
		double arg0, // f64
		double arg1 // f64
		) // -> ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/

{
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g rv;
	uint64_t var0;	// u64
	int64_t var1;	// i64
	uint64_t var2;	// u64
	uint64_t var3;	// u64
	uint64_t var4;	// u64
	uint64_t var5;	// u64
	int64_t var6;	// i64
	int64_t var7;	// i64
	RUST_BOOL var8;	// bool
	uint64_t var9;	// u64
	int64_t var10;	// i64
	uint64_t var11;	// u64
	uint64_t var12;	// u64
	var0 = 0x0ull;	// _0 = Constant(0x0 u64)
	var1 = 0ll;	// _1 = Constant(+0 i64)
	var2 = 0x7fffffffffffffffull;	// _2 = Constant(0x7fffffffffffffff u64)
	var3 = 0x7ff0000000000000ull;	// _3 = Constant(0x7ff0000000000000 u64)
	memcpy( &var11, &arg0, sizeof(double ));
	// ^ Call( _11 = "transmute"::<f64,u64,>( a0, ), bb1, bb3)
	memcpy( &var12, &arg1, sizeof(double ));
	// ^ Call( _12 = "transmute"::<f64,u64,>( a1, ), bb2, bb3)
	var4 = var11 & var2;	// _4 = BinOp(_11 BIT_AND _2)
	var5 = var12 & var2;	// _5 = BinOp(_12 BIT_AND _2)
	var8 = var4 > var3;	// _8 = BinOp(_4 GT _3)
	if(var8) goto bb5; else goto bb4;
	// ^ If( _8 : 5, 4)
bb3: _Unwind_Resume(); // Diverge
bb4:
	var8 = var5 > var3;	// _8 = BinOp(_5 GT _3)
	if(var8) goto bb5; else goto bb6;
	// ^ If( _8 : 5, 6)
bb5:
	rv.TAG = 3;	// retval = Variant(::"compiler_builtins-0_0_0_Hb"::float::cmp::Result #3, {})
	return rv;
	// ^ Return
bb6:
	var9 = var4 | var5;	// _9 = BinOp(_4 BIT_OR _5)
	var8 = var9 == var0;	// _8 = BinOp(_9 EQ _0)
	if(var8) goto bb14; else goto bb7;
	// ^ If( _8 : 14, 7)
bb7:
	memcpy( &var6, &arg0, sizeof(double ));
	// ^ Call( _6 = "transmute"::<f64,i64,>( a0, ), bb8, bb3)
	memcpy( &var7, &arg1, sizeof(double ));
	// ^ Call( _7 = "transmute"::<f64,i64,>( a1, ), bb9, bb3)
	var10 = var6 & var7;	// _10 = BinOp(_6 BIT_AND _7)
	var8 = var10 >= var1;	// _8 = BinOp(_10 GE _1)
	if(var8) goto bb10; else goto bb11;
	// ^ If( _8 : 10, 11)
bb10:
	var8 = var6 < var7;	// _8 = BinOp(_6 LT _7)
	if(var8) goto bb12; else goto bb13;
	// ^ If( _8 : 12, 13)
bb11:
	var8 = var6 > var7;	// _8 = BinOp(_6 GT _7)
	if(var8) goto bb12; else goto bb13;
	// ^ If( _8 : 12, 13)
bb12:
	rv.TAG = 0;	// retval = Variant(::"compiler_builtins-0_0_0_Hb"::float::cmp::Result #0, {})
	return rv;
	// ^ Return
bb13:
	var8 = var6 == var7;	// _8 = BinOp(_6 EQ _7)
	if(var8) goto bb14; else goto bb15;
	// ^ If( _8 : 14, 15)
bb14:
	rv.TAG = 1;	// retval = Variant(::"compiler_builtins-0_0_0_Hb"::float::cmp::Result #1, {})
	return rv;
	// ^ Return
bb15:
	rv.TAG = 2;	// retval = Variant(::"compiler_builtins-0_0_0_Hb"::float::cmp::Result #2, {})
	return rv;
	// ^ Return
}
// ::"compiler_builtins-0_0_0_Hb"::float::cmp::unord<f32,>
RUST_BOOL  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp5unord1gCn(
		float arg0, // f32
		float arg1 // f32
		) // -> bool

{
	RUST_BOOL rv;
	uint32_t var0;	// u32
	uint32_t var1;	// u32
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	RUST_BOOL var4;	// bool
	uint32_t var5;	// u32
	uint32_t var6;	// u32
	var0 = 0x7fffffff;	// _0 = Constant(0x7fffffff u32)
	var1 = 0x7f800000;	// _1 = Constant(0x7f800000 u32)
	memcpy( &var5, &arg0, sizeof(float ));
	// ^ Call( _5 = "transmute"::<f32,u32,>( a0, ), bb1, bb3)
	memcpy( &var6, &arg1, sizeof(float ));
	// ^ Call( _6 = "transmute"::<f32,u32,>( a1, ), bb2, bb3)
	var2 = var5 & var0;	// _2 = BinOp(_5 BIT_AND _0)
	var3 = var6 & var0;	// _3 = BinOp(_6 BIT_AND _0)
	var4 = var2 > var1;	// _4 = BinOp(_2 GT _1)
	if(var4) goto bb4; else goto bb5;
	// ^ If( _4 : 4, 5)
bb3: _Unwind_Resume(); // Diverge
bb4:
	rv = true;	// retval = Constant(true)
	return rv;
	// ^ Return
bb5:
	rv = var3 > var1;	// retval = BinOp(_3 GT _1)
	return rv;
	// ^ Return
}
// ::"compiler_builtins-0_0_0_Hb"::float::cmp::unord<f64,>
RUST_BOOL  ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp5unord1gCo(
		double arg0, // f64
		double arg1 // f64
		) // -> bool

{
	RUST_BOOL rv;
	uint64_t var0;	// u64
	uint64_t var1;	// u64
	uint64_t var2;	// u64
	uint64_t var3;	// u64
	RUST_BOOL var4;	// bool
	uint64_t var5;	// u64
	uint64_t var6;	// u64
	var0 = 0x7fffffffffffffffull;	// _0 = Constant(0x7fffffffffffffff u64)
	var1 = 0x7ff0000000000000ull;	// _1 = Constant(0x7ff0000000000000 u64)
	memcpy( &var5, &arg0, sizeof(double ));
	// ^ Call( _5 = "transmute"::<f64,u64,>( a0, ), bb1, bb3)
	memcpy( &var6, &arg1, sizeof(double ));
	// ^ Call( _6 = "transmute"::<f64,u64,>( a1, ), bb2, bb3)
	var2 = var5 & var0;	// _2 = BinOp(_5 BIT_AND _0)
	var3 = var6 & var0;	// _3 = BinOp(_6 BIT_AND _0)
	var4 = var2 > var1;	// _4 = BinOp(_2 GT _1)
	if(var4) goto bb4; else goto bb5;
	// ^ If( _4 : 4, 5)
bb3: _Unwind_Resume(); // Diverge
bb4:
	rv = true;	// retval = Constant(true)
	return rv;
	// ^ Return
bb5:
	rv = var3 > var1;	// retval = BinOp(_3 GT _1)
	return rv;
	// ^ Return
}
// ::"compiler_builtins-0_0_0_Hb"::float::conv::__fixdfdi
int64_t  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv9__fixdfdi0g(
		double arg0 // f64
		) // -> i64

{
	int64_t rv;
	int64_t var0;	// i64
	int64_t var1;	// i64
	uintptr_t var2;	// usize
	RUST_BOOL var3;	// bool
	uint64_t var4;	// u64
	uintptr_t var5;	// usize
	uintptr_t var6;	// usize
	uint64_t var7;	// u64
	uint64_t var8;	// u64
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var9;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var10;	// usize
	uint64_t var11;	// u64
	int64_t var12;	// i64
	RUST_BOOL var13;	// bool
	uint32_t var14;	// u32
	uint64_t var15;	// u64
	uint64_t var16;	// u64
	uint64_t var17;	// u64
	uint64_t var18;	// u64
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var19;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var20;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var21;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var22;	// usize
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var23;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var24;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var25;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uint64_t var26;	// u64
	uintptr_t var27;	// usize
	int64_t var28;	// i64
	uintptr_t var29;	// usize
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var30;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var31;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var32;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	int64_t var33;	// i64
	int64_t var34;	// i64
	var0 = INT64_MIN;	// _0 = Constant(-9223372036854775808 i64)
	var1 = INT64_MAX;	// _1 = Constant(+9223372036854775807 i64)
	var2 = 0x40ull;	// _2 = Constant(0x40 usize)
	var3 = false;	// _3 = Constant(false)
	var4 = 0x8000000000000000ull;	// _4 = Constant(0x8000000000000000 u64)
	var5 = 0x34ull;	// _5 = Constant(0x34 usize)
	var14 = 0x3ff;	// _14 = Constant(0x3ff u32)
	var6 = (uintptr_t )var14;	// _6 = Cast(_14 as usize)
	memcpy( &var7, &arg0, sizeof(double ));
	// ^ Call( _7 = "transmute"::<f64,u64,>( a0, ), bb1, bb2)
	var15 = ~var4;	// _15 = UniOp(_4 INV)
	var8 = var7 & var15;	// _8 = BinOp(_7 BIT_AND _15)
	var16 = var7 & var4;	// _16 = BinOp(_7 BIT_AND _4)
	var13 = var16 == 0x0ull;	// _13 = BinOp(_16 EQ 0x0 u64)
	if(var13) goto bb3; else goto bb4;
	// ^ If( _13 : 3, 4)
bb2: _Unwind_Resume(); // Diverge
bb3:
	var9.TAG = 0;	// _9 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #0, {})
	goto bb5;
	// ^ Goto(5)
bb4:
	var9.TAG = 1;	// _9 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	// ^ Goto(5)
bb5:
	var17 = var8 >> var5;	// _17 = BinOp(_8 BIT_SHR _5)
	var10 = (uintptr_t )var17;	// _10 = Cast(_17 as usize)
	var18 = var8 & 0xfffffffffffffull;	// _18 = BinOp(_8 BIT_AND 0xfffffffffffff u64)
	var11 = var18 | 0x10000000000000ull;	// _11 = BinOp(_18 BIT_OR 0x10000000000000 u64)
	var13 = var10 < var6;	// _13 = BinOp(_10 LT _6)
	if(var13) goto bb26; else goto bb6;
	// ^ If( _13 : 26, 6)
bb6:
	var13 = var3;	// _13 = Use(_3)
	if(var3) goto bb7; else goto bb9;
	// ^ If( _3 : 7, 9)
bb7:
	var19 = & var9;	// _19 = Borrow(Shared, _9)
	var20.TAG = 1;	// _20 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	var21 = & var20;	// _21 = Borrow(Shared, _20)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var19, var21 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _19, _21, ), bb8, bb2)
	// ^ drop(_20)
	if(var13) goto bb26; else goto bb9;
	// ^ If( _13 : 26, 9)
bb9:
	var10 = var10 - var6;	// _10 = BinOp(_10 SUB _6)
	var13 = var3;	// _13 = Use(_3)
	if(var3) goto bb10; else goto bb11;
	// ^ If( _3 : 10, 11)
bb10:
	var22 = var2;	// _22 = Use(_2)
	goto bb12;
	// ^ Goto(12)
bb11:
	var22 = var2 - 0x1ull;	// _22 = BinOp(_2 SUB 0x1 usize)
	// ^ Goto(12)
bb12:
	var13 = var10 >= var22;	// _13 = BinOp(_10 GE _22)
	if(var13) goto bb13; else goto bb15;
	// ^ If( _13 : 13, 15)
bb13:
	var23 = & var9;	// _23 = Borrow(Shared, _9)
	var24.TAG = 0;	// _24 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #0, {})
	var25 = & var24;	// _25 = Borrow(Shared, _24)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var23, var25 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _23, _25, ), bb14, bb2)
	// ^ drop(_24)
	if(var13) goto bb23; else goto bb24;
	// ^ If( _13 : 23, 24)
bb15:
	var13 = var10 < var5;	// _13 = BinOp(_10 LT _5)
	if(var13) goto bb16; else goto bb17;
	// ^ If( _13 : 16, 17)
bb16:
	var27 = var5 - var10;	// _27 = BinOp(_5 SUB _10)
	var26 = var11 >> var27;	// _26 = BinOp(_11 BIT_SHR _27)
	var12 = (int64_t )var26;	// _12 = Cast(_26 as i64)
	goto bb18;
	// ^ Goto(18)
bb17:
	var28 = (int64_t )var11;	// _28 = Cast(_11 as i64)
	var29 = var10 - var5;	// _29 = BinOp(_10 SUB _5)
	var12 = var28 << var29;	// _12 = BinOp(_28 BIT_SHL _29)
	// ^ Goto(18)
bb18:
	var30 = & var9;	// _30 = Borrow(Shared, _9)
	var31.TAG = 1;	// _31 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	var32 = & var31;	// _32 = Borrow(Shared, _31)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var30, var32 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _30, _32, ), bb19, bb2)
	// ^ drop(_31)
	if(var13) goto bb20; else goto bb21;
	// ^ If( _13 : 20, 21)
bb20:
	var34 = ~var12;	// _34 = UniOp(_12 INV)
	__builtin_add_overflow(var34, 1ll, &var33);
	goto bb22;
	// ^ Call( _33 = "overflowing_add"::<i64,>( _34, +1 i64, ), bb22, bb2)
bb21:
	var33 = var12;	// _33 = Use(_12)
	// ^ Goto(22)
bb22:
	// ^ drop(_9)
	rv = var33;	// retval = Use(_33)
	return rv;
	// ^ Return
bb23:
	rv = var1;	// retval = Use(_1)
	goto bb25;
	// ^ Goto(25)
bb24:
	rv = var0;	// retval = Use(_0)
	// ^ Goto(25)
bb25:
	// ^ drop(_9)
	return rv;
	// ^ Return
bb26:
	rv = 0ll;	// retval = Constant(+0 i64)
	// ^ drop(_9)
	return rv;
	// ^ Return
}
// ::"compiler_builtins-0_0_0_Hb"::float::conv::__fixdfsi
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv9__fixdfsi0g(
		double arg0 // f64
		) // -> i32

{
	int32_t rv;
	int32_t var0;	// i32
	int32_t var1;	// i32
	uintptr_t var2;	// usize
	RUST_BOOL var3;	// bool
	uint64_t var4;	// u64
	uintptr_t var5;	// usize
	uintptr_t var6;	// usize
	uint64_t var7;	// u64
	uint64_t var8;	// u64
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var9;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var10;	// usize
	uint64_t var11;	// u64
	int32_t var12;	// i32
	RUST_BOOL var13;	// bool
	uint32_t var14;	// u32
	uint64_t var15;	// u64
	uint64_t var16;	// u64
	uint64_t var17;	// u64
	uint64_t var18;	// u64
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var19;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var20;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var21;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var22;	// usize
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var23;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var24;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var25;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uint64_t var26;	// u64
	uintptr_t var27;	// usize
	int32_t var28;	// i32
	uintptr_t var29;	// usize
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var30;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var31;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var32;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	int32_t var33;	// i32
	int32_t var34;	// i32
	var0 = -2147483648;	// _0 = Constant(-2147483648 i32)
	var1 = 2147483647;	// _1 = Constant(+2147483647 i32)
	var2 = 0x20ull;	// _2 = Constant(0x20 usize)
	var3 = false;	// _3 = Constant(false)
	var4 = 0x8000000000000000ull;	// _4 = Constant(0x8000000000000000 u64)
	var5 = 0x34ull;	// _5 = Constant(0x34 usize)
	var14 = 0x3ff;	// _14 = Constant(0x3ff u32)
	var6 = (uintptr_t )var14;	// _6 = Cast(_14 as usize)
	memcpy( &var7, &arg0, sizeof(double ));
	// ^ Call( _7 = "transmute"::<f64,u64,>( a0, ), bb1, bb2)
	var15 = ~var4;	// _15 = UniOp(_4 INV)
	var8 = var7 & var15;	// _8 = BinOp(_7 BIT_AND _15)
	var16 = var7 & var4;	// _16 = BinOp(_7 BIT_AND _4)
	var13 = var16 == 0x0ull;	// _13 = BinOp(_16 EQ 0x0 u64)
	if(var13) goto bb3; else goto bb4;
	// ^ If( _13 : 3, 4)
bb2: _Unwind_Resume(); // Diverge
bb3:
	var9.TAG = 0;	// _9 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #0, {})
	goto bb5;
	// ^ Goto(5)
bb4:
	var9.TAG = 1;	// _9 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	// ^ Goto(5)
bb5:
	var17 = var8 >> var5;	// _17 = BinOp(_8 BIT_SHR _5)
	var10 = (uintptr_t )var17;	// _10 = Cast(_17 as usize)
	var18 = var8 & 0xfffffffffffffull;	// _18 = BinOp(_8 BIT_AND 0xfffffffffffff u64)
	var11 = var18 | 0x10000000000000ull;	// _11 = BinOp(_18 BIT_OR 0x10000000000000 u64)
	var13 = var10 < var6;	// _13 = BinOp(_10 LT _6)
	if(var13) goto bb26; else goto bb6;
	// ^ If( _13 : 26, 6)
bb6:
	var13 = var3;	// _13 = Use(_3)
	if(var3) goto bb7; else goto bb9;
	// ^ If( _3 : 7, 9)
bb7:
	var19 = & var9;	// _19 = Borrow(Shared, _9)
	var20.TAG = 1;	// _20 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	var21 = & var20;	// _21 = Borrow(Shared, _20)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var19, var21 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _19, _21, ), bb8, bb2)
	// ^ drop(_20)
	if(var13) goto bb26; else goto bb9;
	// ^ If( _13 : 26, 9)
bb9:
	var10 = var10 - var6;	// _10 = BinOp(_10 SUB _6)
	var13 = var3;	// _13 = Use(_3)
	if(var3) goto bb10; else goto bb11;
	// ^ If( _3 : 10, 11)
bb10:
	var22 = var2;	// _22 = Use(_2)
	goto bb12;
	// ^ Goto(12)
bb11:
	var22 = var2 - 0x1ull;	// _22 = BinOp(_2 SUB 0x1 usize)
	// ^ Goto(12)
bb12:
	var13 = var10 >= var22;	// _13 = BinOp(_10 GE _22)
	if(var13) goto bb13; else goto bb15;
	// ^ If( _13 : 13, 15)
bb13:
	var23 = & var9;	// _23 = Borrow(Shared, _9)
	var24.TAG = 0;	// _24 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #0, {})
	var25 = & var24;	// _25 = Borrow(Shared, _24)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var23, var25 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _23, _25, ), bb14, bb2)
	// ^ drop(_24)
	if(var13) goto bb23; else goto bb24;
	// ^ If( _13 : 23, 24)
bb15:
	var13 = var10 < var5;	// _13 = BinOp(_10 LT _5)
	if(var13) goto bb16; else goto bb17;
	// ^ If( _13 : 16, 17)
bb16:
	var27 = var5 - var10;	// _27 = BinOp(_5 SUB _10)
	var26 = var11 >> var27;	// _26 = BinOp(_11 BIT_SHR _27)
	var12 = (int32_t )var26;	// _12 = Cast(_26 as i32)
	goto bb18;
	// ^ Goto(18)
bb17:
	var28 = (int32_t )var11;	// _28 = Cast(_11 as i32)
	var29 = var10 - var5;	// _29 = BinOp(_10 SUB _5)
	var12 = var28 << var29;	// _12 = BinOp(_28 BIT_SHL _29)
	// ^ Goto(18)
bb18:
	var30 = & var9;	// _30 = Borrow(Shared, _9)
	var31.TAG = 1;	// _31 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	var32 = & var31;	// _32 = Borrow(Shared, _31)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var30, var32 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _30, _32, ), bb19, bb2)
	// ^ drop(_31)
	if(var13) goto bb20; else goto bb21;
	// ^ If( _13 : 20, 21)
bb20:
	var34 = ~var12;	// _34 = UniOp(_12 INV)
	__builtin_add_overflow(var34, 1, &var33);
	goto bb22;
	// ^ Call( _33 = "overflowing_add"::<i32,>( _34, +1 i32, ), bb22, bb2)
bb21:
	var33 = var12;	// _33 = Use(_12)
	// ^ Goto(22)
bb22:
	// ^ drop(_9)
	rv = var33;	// retval = Use(_33)
	return rv;
	// ^ Return
bb23:
	rv = var1;	// retval = Use(_1)
	goto bb25;
	// ^ Goto(25)
bb24:
	rv = var0;	// retval = Use(_0)
	// ^ Goto(25)
bb25:
	// ^ drop(_9)
	return rv;
	// ^ Return
bb26:
	rv = 0;	// retval = Constant(+0 i32)
	// ^ drop(_9)
	return rv;
	// ^ Return
}
// ::"compiler_builtins-0_0_0_Hb"::float::conv::__fixdfti
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv9__fixdfti0g(
		double arg0 // f64
		) // -> i128

{
	int128_t rv;
	int128_t var0;	// i128
	int128_t var1;	// i128
	uintptr_t var2;	// usize
	RUST_BOOL var3;	// bool
	uint64_t var4;	// u64
	uintptr_t var5;	// usize
	uintptr_t var6;	// usize
	uint64_t var7;	// u64
	uint64_t var8;	// u64
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var9;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var10;	// usize
	uint64_t var11;	// u64
	int128_t var12;	// i128
	RUST_BOOL var13;	// bool
	uint32_t var14;	// u32
	uint64_t var15;	// u64
	uint64_t var16;	// u64
	uint64_t var17;	// u64
	uint64_t var18;	// u64
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var19;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var20;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var21;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var22;	// usize
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var23;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var24;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var25;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uint64_t var26;	// u64
	uintptr_t var27;	// usize
	int128_t var28;	// i128
	uintptr_t var29;	// usize
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var30;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var31;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var32;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	int128_t var33;	// i128
	int128_t var34;	// i128
	var0 = make128s_raw(9223372036854775808ull, 0ull);	// _0 = Constant(--170141183460469231731687303715884105728 i128)
	var1 = make128s_raw(9223372036854775807ull, 18446744073709551615ull);	// _1 = Constant(+170141183460469231731687303715884105727 i128)
	var2 = 0x80ull;	// _2 = Constant(0x80 usize)
	var3 = false;	// _3 = Constant(false)
	var4 = 0x8000000000000000ull;	// _4 = Constant(0x8000000000000000 u64)
	var5 = 0x34ull;	// _5 = Constant(0x34 usize)
	var14 = 0x3ff;	// _14 = Constant(0x3ff u32)
	var6 = (uintptr_t )var14;	// _6 = Cast(_14 as usize)
	memcpy( &var7, &arg0, sizeof(double ));
	// ^ Call( _7 = "transmute"::<f64,u64,>( a0, ), bb1, bb2)
	var15 = ~var4;	// _15 = UniOp(_4 INV)
	var8 = var7 & var15;	// _8 = BinOp(_7 BIT_AND _15)
	var16 = var7 & var4;	// _16 = BinOp(_7 BIT_AND _4)
	var13 = var16 == 0x0ull;	// _13 = BinOp(_16 EQ 0x0 u64)
	if(var13) goto bb3; else goto bb4;
	// ^ If( _13 : 3, 4)
bb2: _Unwind_Resume(); // Diverge
bb3:
	var9.TAG = 0;	// _9 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #0, {})
	goto bb5;
	// ^ Goto(5)
bb4:
	var9.TAG = 1;	// _9 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	// ^ Goto(5)
bb5:
	var17 = var8 >> var5;	// _17 = BinOp(_8 BIT_SHR _5)
	var10 = (uintptr_t )var17;	// _10 = Cast(_17 as usize)
	var18 = var8 & 0xfffffffffffffull;	// _18 = BinOp(_8 BIT_AND 0xfffffffffffff u64)
	var11 = var18 | 0x10000000000000ull;	// _11 = BinOp(_18 BIT_OR 0x10000000000000 u64)
	var13 = var10 < var6;	// _13 = BinOp(_10 LT _6)
	if(var13) goto bb26; else goto bb6;
	// ^ If( _13 : 26, 6)
bb6:
	var13 = var3;	// _13 = Use(_3)
	if(var3) goto bb7; else goto bb9;
	// ^ If( _3 : 7, 9)
bb7:
	var19 = & var9;	// _19 = Borrow(Shared, _9)
	var20.TAG = 1;	// _20 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	var21 = & var20;	// _21 = Borrow(Shared, _20)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var19, var21 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _19, _21, ), bb8, bb2)
	// ^ drop(_20)
	if(var13) goto bb26; else goto bb9;
	// ^ If( _13 : 26, 9)
bb9:
	var10 = var10 - var6;	// _10 = BinOp(_10 SUB _6)
	var13 = var3;	// _13 = Use(_3)
	if(var3) goto bb10; else goto bb11;
	// ^ If( _3 : 10, 11)
bb10:
	var22 = var2;	// _22 = Use(_2)
	goto bb12;
	// ^ Goto(12)
bb11:
	var22 = var2 - 0x1ull;	// _22 = BinOp(_2 SUB 0x1 usize)
	// ^ Goto(12)
bb12:
	var13 = var10 >= var22;	// _13 = BinOp(_10 GE _22)
	if(var13) goto bb13; else goto bb15;
	// ^ If( _13 : 13, 15)
bb13:
	var23 = & var9;	// _23 = Borrow(Shared, _9)
	var24.TAG = 0;	// _24 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #0, {})
	var25 = & var24;	// _25 = Borrow(Shared, _24)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var23, var25 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _23, _25, ), bb14, bb2)
	// ^ drop(_24)
	if(var13) goto bb23; else goto bb24;
	// ^ If( _13 : 23, 24)
bb15:
	var13 = var10 < var5;	// _13 = BinOp(_10 LT _5)
	if(var13) goto bb16; else goto bb17;
	// ^ If( _13 : 16, 17)
bb16:
	var27 = var5 - var10;	// _27 = BinOp(_5 SUB _10)
	var26 = var11 >> var27;	// _26 = BinOp(_11 BIT_SHR _27)
	var12.lo = var26; var12.hi = var26 < 0 ? -1 : 0;	// _12 = Cast(_26 as i128)
	goto bb18;
	// ^ Goto(18)
bb17:
	var28.lo = var11; var28.hi = var11 < 0 ? -1 : 0;	// _28 = Cast(_11 as i128)
	var29 = var10 - var5;	// _29 = BinOp(_10 SUB _5)
	var12 = shl128s(var28, var29);	// _12 = BinOp(_28 BIT_SHL _29)
	// ^ Goto(18)
bb18:
	var30 = & var9;	// _30 = Borrow(Shared, _9)
	var31.TAG = 1;	// _31 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	var32 = & var31;	// _32 = Borrow(Shared, _31)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var30, var32 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _30, _32, ), bb19, bb2)
	// ^ drop(_31)
	if(var13) goto bb20; else goto bb21;
	// ^ If( _13 : 20, 21)
bb20:
	var34.lo = ~var12.lo; var34.hi = ~var12.hi;	// _34 = UniOp(_12 INV)
	add128s_o(var34, make128s_raw(0ull, 1ull), &var33);
	goto bb22;
	// ^ Call( _33 = "overflowing_add"::<i128,>( _34, +1 i128, ), bb22, bb2)
bb21:
	var33 = var12;	// _33 = Use(_12)
	// ^ Goto(22)
bb22:
	// ^ drop(_9)
	rv = var33;	// retval = Use(_33)
	return rv;
	// ^ Return
bb23:
	rv = var1;	// retval = Use(_1)
	goto bb25;
	// ^ Goto(25)
bb24:
	rv = var0;	// retval = Use(_0)
	// ^ Goto(25)
bb25:
	// ^ drop(_9)
	return rv;
	// ^ Return
bb26:
	rv = make128s_raw(0ull, 0ull);	// retval = Constant(+0 i128)
	// ^ drop(_9)
	return rv;
	// ^ Return
}
// ::"compiler_builtins-0_0_0_Hb"::float::conv::__fixsfdi
int64_t  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv9__fixsfdi0g(
		float arg0 // f32
		) // -> i64

{
	int64_t rv;
	int64_t var0;	// i64
	int64_t var1;	// i64
	uintptr_t var2;	// usize
	RUST_BOOL var3;	// bool
	uint32_t var4;	// u32
	uintptr_t var5;	// usize
	uintptr_t var6;	// usize
	uint32_t var7;	// u32
	uint32_t var8;	// u32
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var9;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var10;	// usize
	uint32_t var11;	// u32
	int64_t var12;	// i64
	RUST_BOOL var13;	// bool
	uint32_t var14;	// u32
	uint32_t var15;	// u32
	uint32_t var16;	// u32
	uint32_t var17;	// u32
	uint32_t var18;	// u32
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var19;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var20;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var21;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var22;	// usize
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var23;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var24;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var25;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uint32_t var26;	// u32
	uintptr_t var27;	// usize
	int64_t var28;	// i64
	uintptr_t var29;	// usize
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var30;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var31;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var32;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	int64_t var33;	// i64
	int64_t var34;	// i64
	var0 = INT64_MIN;	// _0 = Constant(-9223372036854775808 i64)
	var1 = INT64_MAX;	// _1 = Constant(+9223372036854775807 i64)
	var2 = 0x40ull;	// _2 = Constant(0x40 usize)
	var3 = false;	// _3 = Constant(false)
	var4 = 0x80000000;	// _4 = Constant(0x80000000 u32)
	var5 = 0x17ull;	// _5 = Constant(0x17 usize)
	var14 = 0x7f;	// _14 = Constant(0x7f u32)
	var6 = (uintptr_t )var14;	// _6 = Cast(_14 as usize)
	memcpy( &var7, &arg0, sizeof(float ));
	// ^ Call( _7 = "transmute"::<f32,u32,>( a0, ), bb1, bb2)
	var15 = ~var4;	// _15 = UniOp(_4 INV)
	var8 = var7 & var15;	// _8 = BinOp(_7 BIT_AND _15)
	var16 = var7 & var4;	// _16 = BinOp(_7 BIT_AND _4)
	var13 = var16 == 0x0;	// _13 = BinOp(_16 EQ 0x0 u32)
	if(var13) goto bb3; else goto bb4;
	// ^ If( _13 : 3, 4)
bb2: _Unwind_Resume(); // Diverge
bb3:
	var9.TAG = 0;	// _9 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #0, {})
	goto bb5;
	// ^ Goto(5)
bb4:
	var9.TAG = 1;	// _9 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	// ^ Goto(5)
bb5:
	var17 = var8 >> var5;	// _17 = BinOp(_8 BIT_SHR _5)
	var10 = (uintptr_t )var17;	// _10 = Cast(_17 as usize)
	var18 = var8 & 0x7fffff;	// _18 = BinOp(_8 BIT_AND 0x7fffff u32)
	var11 = var18 | 0x800000;	// _11 = BinOp(_18 BIT_OR 0x800000 u32)
	var13 = var10 < var6;	// _13 = BinOp(_10 LT _6)
	if(var13) goto bb26; else goto bb6;
	// ^ If( _13 : 26, 6)
bb6:
	var13 = var3;	// _13 = Use(_3)
	if(var3) goto bb7; else goto bb9;
	// ^ If( _3 : 7, 9)
bb7:
	var19 = & var9;	// _19 = Borrow(Shared, _9)
	var20.TAG = 1;	// _20 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	var21 = & var20;	// _21 = Borrow(Shared, _20)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var19, var21 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _19, _21, ), bb8, bb2)
	// ^ drop(_20)
	if(var13) goto bb26; else goto bb9;
	// ^ If( _13 : 26, 9)
bb9:
	var10 = var10 - var6;	// _10 = BinOp(_10 SUB _6)
	var13 = var3;	// _13 = Use(_3)
	if(var3) goto bb10; else goto bb11;
	// ^ If( _3 : 10, 11)
bb10:
	var22 = var2;	// _22 = Use(_2)
	goto bb12;
	// ^ Goto(12)
bb11:
	var22 = var2 - 0x1ull;	// _22 = BinOp(_2 SUB 0x1 usize)
	// ^ Goto(12)
bb12:
	var13 = var10 >= var22;	// _13 = BinOp(_10 GE _22)
	if(var13) goto bb13; else goto bb15;
	// ^ If( _13 : 13, 15)
bb13:
	var23 = & var9;	// _23 = Borrow(Shared, _9)
	var24.TAG = 0;	// _24 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #0, {})
	var25 = & var24;	// _25 = Borrow(Shared, _24)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var23, var25 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _23, _25, ), bb14, bb2)
	// ^ drop(_24)
	if(var13) goto bb23; else goto bb24;
	// ^ If( _13 : 23, 24)
bb15:
	var13 = var10 < var5;	// _13 = BinOp(_10 LT _5)
	if(var13) goto bb16; else goto bb17;
	// ^ If( _13 : 16, 17)
bb16:
	var27 = var5 - var10;	// _27 = BinOp(_5 SUB _10)
	var26 = var11 >> var27;	// _26 = BinOp(_11 BIT_SHR _27)
	var12 = (int64_t )var26;	// _12 = Cast(_26 as i64)
	goto bb18;
	// ^ Goto(18)
bb17:
	var28 = (int64_t )var11;	// _28 = Cast(_11 as i64)
	var29 = var10 - var5;	// _29 = BinOp(_10 SUB _5)
	var12 = var28 << var29;	// _12 = BinOp(_28 BIT_SHL _29)
	// ^ Goto(18)
bb18:
	var30 = & var9;	// _30 = Borrow(Shared, _9)
	var31.TAG = 1;	// _31 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	var32 = & var31;	// _32 = Borrow(Shared, _31)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var30, var32 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _30, _32, ), bb19, bb2)
	// ^ drop(_31)
	if(var13) goto bb20; else goto bb21;
	// ^ If( _13 : 20, 21)
bb20:
	var34 = ~var12;	// _34 = UniOp(_12 INV)
	__builtin_add_overflow(var34, 1ll, &var33);
	goto bb22;
	// ^ Call( _33 = "overflowing_add"::<i64,>( _34, +1 i64, ), bb22, bb2)
bb21:
	var33 = var12;	// _33 = Use(_12)
	// ^ Goto(22)
bb22:
	// ^ drop(_9)
	rv = var33;	// retval = Use(_33)
	return rv;
	// ^ Return
bb23:
	rv = var1;	// retval = Use(_1)
	goto bb25;
	// ^ Goto(25)
bb24:
	rv = var0;	// retval = Use(_0)
	// ^ Goto(25)
bb25:
	// ^ drop(_9)
	return rv;
	// ^ Return
bb26:
	rv = 0ll;	// retval = Constant(+0 i64)
	// ^ drop(_9)
	return rv;
	// ^ Return
}
// ::"compiler_builtins-0_0_0_Hb"::float::conv::__fixsfsi
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv9__fixsfsi0g(
		float arg0 // f32
		) // -> i32

{
	int32_t rv;
	int32_t var0;	// i32
	int32_t var1;	// i32
	uintptr_t var2;	// usize
	RUST_BOOL var3;	// bool
	uint32_t var4;	// u32
	uintptr_t var5;	// usize
	uintptr_t var6;	// usize
	uint32_t var7;	// u32
	uint32_t var8;	// u32
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var9;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var10;	// usize
	uint32_t var11;	// u32
	int32_t var12;	// i32
	RUST_BOOL var13;	// bool
	uint32_t var14;	// u32
	uint32_t var15;	// u32
	uint32_t var16;	// u32
	uint32_t var17;	// u32
	uint32_t var18;	// u32
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var19;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var20;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var21;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var22;	// usize
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var23;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var24;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var25;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uint32_t var26;	// u32
	uintptr_t var27;	// usize
	int32_t var28;	// i32
	uintptr_t var29;	// usize
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var30;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var31;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var32;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	int32_t var33;	// i32
	int32_t var34;	// i32
	var0 = -2147483648;	// _0 = Constant(-2147483648 i32)
	var1 = 2147483647;	// _1 = Constant(+2147483647 i32)
	var2 = 0x20ull;	// _2 = Constant(0x20 usize)
	var3 = false;	// _3 = Constant(false)
	var4 = 0x80000000;	// _4 = Constant(0x80000000 u32)
	var5 = 0x17ull;	// _5 = Constant(0x17 usize)
	var14 = 0x7f;	// _14 = Constant(0x7f u32)
	var6 = (uintptr_t )var14;	// _6 = Cast(_14 as usize)
	memcpy( &var7, &arg0, sizeof(float ));
	// ^ Call( _7 = "transmute"::<f32,u32,>( a0, ), bb1, bb2)
	var15 = ~var4;	// _15 = UniOp(_4 INV)
	var8 = var7 & var15;	// _8 = BinOp(_7 BIT_AND _15)
	var16 = var7 & var4;	// _16 = BinOp(_7 BIT_AND _4)
	var13 = var16 == 0x0;	// _13 = BinOp(_16 EQ 0x0 u32)
	if(var13) goto bb3; else goto bb4;
	// ^ If( _13 : 3, 4)
bb2: _Unwind_Resume(); // Diverge
bb3:
	var9.TAG = 0;	// _9 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #0, {})
	goto bb5;
	// ^ Goto(5)
bb4:
	var9.TAG = 1;	// _9 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	// ^ Goto(5)
bb5:
	var17 = var8 >> var5;	// _17 = BinOp(_8 BIT_SHR _5)
	var10 = (uintptr_t )var17;	// _10 = Cast(_17 as usize)
	var18 = var8 & 0x7fffff;	// _18 = BinOp(_8 BIT_AND 0x7fffff u32)
	var11 = var18 | 0x800000;	// _11 = BinOp(_18 BIT_OR 0x800000 u32)
	var13 = var10 < var6;	// _13 = BinOp(_10 LT _6)
	if(var13) goto bb26; else goto bb6;
	// ^ If( _13 : 26, 6)
bb6:
	var13 = var3;	// _13 = Use(_3)
	if(var3) goto bb7; else goto bb9;
	// ^ If( _3 : 7, 9)
bb7:
	var19 = & var9;	// _19 = Borrow(Shared, _9)
	var20.TAG = 1;	// _20 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	var21 = & var20;	// _21 = Borrow(Shared, _20)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var19, var21 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _19, _21, ), bb8, bb2)
	// ^ drop(_20)
	if(var13) goto bb26; else goto bb9;
	// ^ If( _13 : 26, 9)
bb9:
	var10 = var10 - var6;	// _10 = BinOp(_10 SUB _6)
	var13 = var3;	// _13 = Use(_3)
	if(var3) goto bb10; else goto bb11;
	// ^ If( _3 : 10, 11)
bb10:
	var22 = var2;	// _22 = Use(_2)
	goto bb12;
	// ^ Goto(12)
bb11:
	var22 = var2 - 0x1ull;	// _22 = BinOp(_2 SUB 0x1 usize)
	// ^ Goto(12)
bb12:
	var13 = var10 >= var22;	// _13 = BinOp(_10 GE _22)
	if(var13) goto bb13; else goto bb15;
	// ^ If( _13 : 13, 15)
bb13:
	var23 = & var9;	// _23 = Borrow(Shared, _9)
	var24.TAG = 0;	// _24 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #0, {})
	var25 = & var24;	// _25 = Borrow(Shared, _24)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var23, var25 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _23, _25, ), bb14, bb2)
	// ^ drop(_24)
	if(var13) goto bb23; else goto bb24;
	// ^ If( _13 : 23, 24)
bb15:
	var13 = var10 < var5;	// _13 = BinOp(_10 LT _5)
	if(var13) goto bb16; else goto bb17;
	// ^ If( _13 : 16, 17)
bb16:
	var27 = var5 - var10;	// _27 = BinOp(_5 SUB _10)
	var26 = var11 >> var27;	// _26 = BinOp(_11 BIT_SHR _27)
	var12 = (int32_t )var26;	// _12 = Cast(_26 as i32)
	goto bb18;
	// ^ Goto(18)
bb17:
	var28 = (int32_t )var11;	// _28 = Cast(_11 as i32)
	var29 = var10 - var5;	// _29 = BinOp(_10 SUB _5)
	var12 = var28 << var29;	// _12 = BinOp(_28 BIT_SHL _29)
	// ^ Goto(18)
bb18:
	var30 = & var9;	// _30 = Borrow(Shared, _9)
	var31.TAG = 1;	// _31 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	var32 = & var31;	// _32 = Borrow(Shared, _31)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var30, var32 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _30, _32, ), bb19, bb2)
	// ^ drop(_31)
	if(var13) goto bb20; else goto bb21;
	// ^ If( _13 : 20, 21)
bb20:
	var34 = ~var12;	// _34 = UniOp(_12 INV)
	__builtin_add_overflow(var34, 1, &var33);
	goto bb22;
	// ^ Call( _33 = "overflowing_add"::<i32,>( _34, +1 i32, ), bb22, bb2)
bb21:
	var33 = var12;	// _33 = Use(_12)
	// ^ Goto(22)
bb22:
	// ^ drop(_9)
	rv = var33;	// retval = Use(_33)
	return rv;
	// ^ Return
bb23:
	rv = var1;	// retval = Use(_1)
	goto bb25;
	// ^ Goto(25)
bb24:
	rv = var0;	// retval = Use(_0)
	// ^ Goto(25)
bb25:
	// ^ drop(_9)
	return rv;
	// ^ Return
bb26:
	rv = 0;	// retval = Constant(+0 i32)
	// ^ drop(_9)
	return rv;
	// ^ Return
}
// ::"compiler_builtins-0_0_0_Hb"::float::conv::__fixsfti
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv9__fixsfti0g(
		float arg0 // f32
		) // -> i128

{
	int128_t rv;
	int128_t var0;	// i128
	int128_t var1;	// i128
	uintptr_t var2;	// usize
	RUST_BOOL var3;	// bool
	uint32_t var4;	// u32
	uintptr_t var5;	// usize
	uintptr_t var6;	// usize
	uint32_t var7;	// u32
	uint32_t var8;	// u32
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var9;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var10;	// usize
	uint32_t var11;	// u32
	int128_t var12;	// i128
	RUST_BOOL var13;	// bool
	uint32_t var14;	// u32
	uint32_t var15;	// u32
	uint32_t var16;	// u32
	uint32_t var17;	// u32
	uint32_t var18;	// u32
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var19;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var20;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var21;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var22;	// usize
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var23;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var24;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var25;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uint32_t var26;	// u32
	uintptr_t var27;	// usize
	int128_t var28;	// i128
	uintptr_t var29;	// usize
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var30;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var31;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var32;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	int128_t var33;	// i128
	int128_t var34;	// i128
	var0 = make128s_raw(9223372036854775808ull, 0ull);	// _0 = Constant(--170141183460469231731687303715884105728 i128)
	var1 = make128s_raw(9223372036854775807ull, 18446744073709551615ull);	// _1 = Constant(+170141183460469231731687303715884105727 i128)
	var2 = 0x80ull;	// _2 = Constant(0x80 usize)
	var3 = false;	// _3 = Constant(false)
	var4 = 0x80000000;	// _4 = Constant(0x80000000 u32)
	var5 = 0x17ull;	// _5 = Constant(0x17 usize)
	var14 = 0x7f;	// _14 = Constant(0x7f u32)
	var6 = (uintptr_t )var14;	// _6 = Cast(_14 as usize)
	memcpy( &var7, &arg0, sizeof(float ));
	// ^ Call( _7 = "transmute"::<f32,u32,>( a0, ), bb1, bb2)
	var15 = ~var4;	// _15 = UniOp(_4 INV)
	var8 = var7 & var15;	// _8 = BinOp(_7 BIT_AND _15)
	var16 = var7 & var4;	// _16 = BinOp(_7 BIT_AND _4)
	var13 = var16 == 0x0;	// _13 = BinOp(_16 EQ 0x0 u32)
	if(var13) goto bb3; else goto bb4;
	// ^ If( _13 : 3, 4)
bb2: _Unwind_Resume(); // Diverge
bb3:
	var9.TAG = 0;	// _9 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #0, {})
	goto bb5;
	// ^ Goto(5)
bb4:
	var9.TAG = 1;	// _9 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	// ^ Goto(5)
bb5:
	var17 = var8 >> var5;	// _17 = BinOp(_8 BIT_SHR _5)
	var10 = (uintptr_t )var17;	// _10 = Cast(_17 as usize)
	var18 = var8 & 0x7fffff;	// _18 = BinOp(_8 BIT_AND 0x7fffff u32)
	var11 = var18 | 0x800000;	// _11 = BinOp(_18 BIT_OR 0x800000 u32)
	var13 = var10 < var6;	// _13 = BinOp(_10 LT _6)
	if(var13) goto bb26; else goto bb6;
	// ^ If( _13 : 26, 6)
bb6:
	var13 = var3;	// _13 = Use(_3)
	if(var3) goto bb7; else goto bb9;
	// ^ If( _3 : 7, 9)
bb7:
	var19 = & var9;	// _19 = Borrow(Shared, _9)
	var20.TAG = 1;	// _20 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	var21 = & var20;	// _21 = Borrow(Shared, _20)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var19, var21 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _19, _21, ), bb8, bb2)
	// ^ drop(_20)
	if(var13) goto bb26; else goto bb9;
	// ^ If( _13 : 26, 9)
bb9:
	var10 = var10 - var6;	// _10 = BinOp(_10 SUB _6)
	var13 = var3;	// _13 = Use(_3)
	if(var3) goto bb10; else goto bb11;
	// ^ If( _3 : 10, 11)
bb10:
	var22 = var2;	// _22 = Use(_2)
	goto bb12;
	// ^ Goto(12)
bb11:
	var22 = var2 - 0x1ull;	// _22 = BinOp(_2 SUB 0x1 usize)
	// ^ Goto(12)
bb12:
	var13 = var10 >= var22;	// _13 = BinOp(_10 GE _22)
	if(var13) goto bb13; else goto bb15;
	// ^ If( _13 : 13, 15)
bb13:
	var23 = & var9;	// _23 = Borrow(Shared, _9)
	var24.TAG = 0;	// _24 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #0, {})
	var25 = & var24;	// _25 = Borrow(Shared, _24)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var23, var25 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _23, _25, ), bb14, bb2)
	// ^ drop(_24)
	if(var13) goto bb23; else goto bb24;
	// ^ If( _13 : 23, 24)
bb15:
	var13 = var10 < var5;	// _13 = BinOp(_10 LT _5)
	if(var13) goto bb16; else goto bb17;
	// ^ If( _13 : 16, 17)
bb16:
	var27 = var5 - var10;	// _27 = BinOp(_5 SUB _10)
	var26 = var11 >> var27;	// _26 = BinOp(_11 BIT_SHR _27)
	var12.lo = var26; var12.hi = var26 < 0 ? -1 : 0;	// _12 = Cast(_26 as i128)
	goto bb18;
	// ^ Goto(18)
bb17:
	var28.lo = var11; var28.hi = var11 < 0 ? -1 : 0;	// _28 = Cast(_11 as i128)
	var29 = var10 - var5;	// _29 = BinOp(_10 SUB _5)
	var12 = shl128s(var28, var29);	// _12 = BinOp(_28 BIT_SHL _29)
	// ^ Goto(18)
bb18:
	var30 = & var9;	// _30 = Borrow(Shared, _9)
	var31.TAG = 1;	// _31 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	var32 = & var31;	// _32 = Borrow(Shared, _31)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var30, var32 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _30, _32, ), bb19, bb2)
	// ^ drop(_31)
	if(var13) goto bb20; else goto bb21;
	// ^ If( _13 : 20, 21)
bb20:
	var34.lo = ~var12.lo; var34.hi = ~var12.hi;	// _34 = UniOp(_12 INV)
	add128s_o(var34, make128s_raw(0ull, 1ull), &var33);
	goto bb22;
	// ^ Call( _33 = "overflowing_add"::<i128,>( _34, +1 i128, ), bb22, bb2)
bb21:
	var33 = var12;	// _33 = Use(_12)
	// ^ Goto(22)
bb22:
	// ^ drop(_9)
	rv = var33;	// retval = Use(_33)
	return rv;
	// ^ Return
bb23:
	rv = var1;	// retval = Use(_1)
	goto bb25;
	// ^ Goto(25)
bb24:
	rv = var0;	// retval = Use(_0)
	// ^ Goto(25)
bb25:
	// ^ drop(_9)
	return rv;
	// ^ Return
bb26:
	rv = make128s_raw(0ull, 0ull);	// retval = Constant(+0 i128)
	// ^ drop(_9)
	return rv;
	// ^ Return
}
// ::"compiler_builtins-0_0_0_Hb"::float::conv::__fixunsdfdi
uint64_t  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv12__fixunsdfdi0g(
		double arg0 // f64
		) // -> u64

{
	uint64_t rv;
	uint64_t var0;	// u64
	uint64_t var1;	// u64
	uintptr_t var2;	// usize
	RUST_BOOL var3;	// bool
	uint64_t var4;	// u64
	uintptr_t var5;	// usize
	uintptr_t var6;	// usize
	uint64_t var7;	// u64
	uint64_t var8;	// u64
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var9;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var10;	// usize
	uint64_t var11;	// u64
	uint64_t var12;	// u64
	RUST_BOOL var13;	// bool
	uint32_t var14;	// u32
	uint64_t var15;	// u64
	uint64_t var16;	// u64
	uint64_t var17;	// u64
	uint64_t var18;	// u64
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var19;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var20;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var21;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var22;	// usize
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var23;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var24;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var25;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var26;	// usize
	uintptr_t var27;	// usize
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var28;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var29;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var30;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uint64_t var31;	// u64
	uint64_t var32;	// u64
	var0 = 0x0ull;	// _0 = Constant(0x0 u64)
	var1 = 0xffffffffffffffffull;	// _1 = Constant(0xffffffffffffffff u64)
	var2 = 0x40ull;	// _2 = Constant(0x40 usize)
	var3 = true;	// _3 = Constant(true)
	var4 = 0x8000000000000000ull;	// _4 = Constant(0x8000000000000000 u64)
	var5 = 0x34ull;	// _5 = Constant(0x34 usize)
	var14 = 0x3ff;	// _14 = Constant(0x3ff u32)
	var6 = (uintptr_t )var14;	// _6 = Cast(_14 as usize)
	memcpy( &var7, &arg0, sizeof(double ));
	// ^ Call( _7 = "transmute"::<f64,u64,>( a0, ), bb1, bb2)
	var15 = ~var4;	// _15 = UniOp(_4 INV)
	var8 = var7 & var15;	// _8 = BinOp(_7 BIT_AND _15)
	var16 = var7 & var4;	// _16 = BinOp(_7 BIT_AND _4)
	var13 = var16 == 0x0ull;	// _13 = BinOp(_16 EQ 0x0 u64)
	if(var13) goto bb3; else goto bb4;
	// ^ If( _13 : 3, 4)
bb2: _Unwind_Resume(); // Diverge
bb3:
	var9.TAG = 0;	// _9 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #0, {})
	goto bb5;
	// ^ Goto(5)
bb4:
	var9.TAG = 1;	// _9 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	// ^ Goto(5)
bb5:
	var17 = var8 >> var5;	// _17 = BinOp(_8 BIT_SHR _5)
	var10 = (uintptr_t )var17;	// _10 = Cast(_17 as usize)
	var18 = var8 & 0xfffffffffffffull;	// _18 = BinOp(_8 BIT_AND 0xfffffffffffff u64)
	var11 = var18 | 0x10000000000000ull;	// _11 = BinOp(_18 BIT_OR 0x10000000000000 u64)
	var13 = var10 < var6;	// _13 = BinOp(_10 LT _6)
	if(var13) goto bb26; else goto bb6;
	// ^ If( _13 : 26, 6)
bb6:
	var13 = var3;	// _13 = Use(_3)
	if(var3) goto bb7; else goto bb9;
	// ^ If( _3 : 7, 9)
bb7:
	var19 = & var9;	// _19 = Borrow(Shared, _9)
	var20.TAG = 1;	// _20 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	var21 = & var20;	// _21 = Borrow(Shared, _20)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var19, var21 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _19, _21, ), bb8, bb2)
	// ^ drop(_20)
	if(var13) goto bb26; else goto bb9;
	// ^ If( _13 : 26, 9)
bb9:
	var10 = var10 - var6;	// _10 = BinOp(_10 SUB _6)
	var13 = var3;	// _13 = Use(_3)
	if(var3) goto bb10; else goto bb11;
	// ^ If( _3 : 10, 11)
bb10:
	var22 = var2;	// _22 = Use(_2)
	goto bb12;
	// ^ Goto(12)
bb11:
	var22 = var2 - 0x1ull;	// _22 = BinOp(_2 SUB 0x1 usize)
	// ^ Goto(12)
bb12:
	var13 = var10 >= var22;	// _13 = BinOp(_10 GE _22)
	if(var13) goto bb13; else goto bb15;
	// ^ If( _13 : 13, 15)
bb13:
	var23 = & var9;	// _23 = Borrow(Shared, _9)
	var24.TAG = 0;	// _24 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #0, {})
	var25 = & var24;	// _25 = Borrow(Shared, _24)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var23, var25 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _23, _25, ), bb14, bb2)
	// ^ drop(_24)
	if(var13) goto bb23; else goto bb24;
	// ^ If( _13 : 23, 24)
bb15:
	var13 = var10 < var5;	// _13 = BinOp(_10 LT _5)
	if(var13) goto bb16; else goto bb17;
	// ^ If( _13 : 16, 17)
bb16:
	var26 = var5 - var10;	// _26 = BinOp(_5 SUB _10)
	var12 = var11 >> var26;	// _12 = BinOp(_11 BIT_SHR _26)
	goto bb18;
	// ^ Goto(18)
bb17:
	var27 = var10 - var5;	// _27 = BinOp(_10 SUB _5)
	var12 = var11 << var27;	// _12 = BinOp(_11 BIT_SHL _27)
	// ^ Goto(18)
bb18:
	var28 = & var9;	// _28 = Borrow(Shared, _9)
	var29.TAG = 1;	// _29 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	var30 = & var29;	// _30 = Borrow(Shared, _29)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var28, var30 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _28, _30, ), bb19, bb2)
	// ^ drop(_29)
	if(var13) goto bb20; else goto bb21;
	// ^ If( _13 : 20, 21)
bb20:
	var32 = ~var12;	// _32 = UniOp(_12 INV)
	__builtin_add_overflow(var32, 0x1ull, &var31);
	goto bb22;
	// ^ Call( _31 = "overflowing_add"::<u64,>( _32, 0x1 u64, ), bb22, bb2)
bb21:
	var31 = var12;	// _31 = Use(_12)
	// ^ Goto(22)
bb22:
	// ^ drop(_9)
	rv = var31;	// retval = Use(_31)
	return rv;
	// ^ Return
bb23:
	rv = var1;	// retval = Use(_1)
	goto bb25;
	// ^ Goto(25)
bb24:
	rv = var0;	// retval = Use(_0)
	// ^ Goto(25)
bb25:
	// ^ drop(_9)
	return rv;
	// ^ Return
bb26:
	rv = 0x0ull;	// retval = Constant(0x0 u64)
	// ^ drop(_9)
	return rv;
	// ^ Return
}
// ::"compiler_builtins-0_0_0_Hb"::float::conv::__fixunsdfsi
uint32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv12__fixunsdfsi0g(
		double arg0 // f64
		) // -> u32

{
	uint32_t rv;
	uint32_t var0;	// u32
	uint32_t var1;	// u32
	uintptr_t var2;	// usize
	RUST_BOOL var3;	// bool
	uint64_t var4;	// u64
	uintptr_t var5;	// usize
	uintptr_t var6;	// usize
	uint64_t var7;	// u64
	uint64_t var8;	// u64
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var9;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var10;	// usize
	uint64_t var11;	// u64
	uint32_t var12;	// u32
	RUST_BOOL var13;	// bool
	uint32_t var14;	// u32
	uint64_t var15;	// u64
	uint64_t var16;	// u64
	uint64_t var17;	// u64
	uint64_t var18;	// u64
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var19;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var20;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var21;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var22;	// usize
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var23;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var24;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var25;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uint64_t var26;	// u64
	uintptr_t var27;	// usize
	uint32_t var28;	// u32
	uintptr_t var29;	// usize
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var30;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var31;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var32;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uint32_t var33;	// u32
	uint32_t var34;	// u32
	var0 = 0x0;	// _0 = Constant(0x0 u32)
	var1 = 0xffffffff;	// _1 = Constant(0xffffffff u32)
	var2 = 0x20ull;	// _2 = Constant(0x20 usize)
	var3 = true;	// _3 = Constant(true)
	var4 = 0x8000000000000000ull;	// _4 = Constant(0x8000000000000000 u64)
	var5 = 0x34ull;	// _5 = Constant(0x34 usize)
	var14 = 0x3ff;	// _14 = Constant(0x3ff u32)
	var6 = (uintptr_t )var14;	// _6 = Cast(_14 as usize)
	memcpy( &var7, &arg0, sizeof(double ));
	// ^ Call( _7 = "transmute"::<f64,u64,>( a0, ), bb1, bb2)
	var15 = ~var4;	// _15 = UniOp(_4 INV)
	var8 = var7 & var15;	// _8 = BinOp(_7 BIT_AND _15)
	var16 = var7 & var4;	// _16 = BinOp(_7 BIT_AND _4)
	var13 = var16 == 0x0ull;	// _13 = BinOp(_16 EQ 0x0 u64)
	if(var13) goto bb3; else goto bb4;
	// ^ If( _13 : 3, 4)
bb2: _Unwind_Resume(); // Diverge
bb3:
	var9.TAG = 0;	// _9 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #0, {})
	goto bb5;
	// ^ Goto(5)
bb4:
	var9.TAG = 1;	// _9 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	// ^ Goto(5)
bb5:
	var17 = var8 >> var5;	// _17 = BinOp(_8 BIT_SHR _5)
	var10 = (uintptr_t )var17;	// _10 = Cast(_17 as usize)
	var18 = var8 & 0xfffffffffffffull;	// _18 = BinOp(_8 BIT_AND 0xfffffffffffff u64)
	var11 = var18 | 0x10000000000000ull;	// _11 = BinOp(_18 BIT_OR 0x10000000000000 u64)
	var13 = var10 < var6;	// _13 = BinOp(_10 LT _6)
	if(var13) goto bb26; else goto bb6;
	// ^ If( _13 : 26, 6)
bb6:
	var13 = var3;	// _13 = Use(_3)
	if(var3) goto bb7; else goto bb9;
	// ^ If( _3 : 7, 9)
bb7:
	var19 = & var9;	// _19 = Borrow(Shared, _9)
	var20.TAG = 1;	// _20 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	var21 = & var20;	// _21 = Borrow(Shared, _20)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var19, var21 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _19, _21, ), bb8, bb2)
	// ^ drop(_20)
	if(var13) goto bb26; else goto bb9;
	// ^ If( _13 : 26, 9)
bb9:
	var10 = var10 - var6;	// _10 = BinOp(_10 SUB _6)
	var13 = var3;	// _13 = Use(_3)
	if(var3) goto bb10; else goto bb11;
	// ^ If( _3 : 10, 11)
bb10:
	var22 = var2;	// _22 = Use(_2)
	goto bb12;
	// ^ Goto(12)
bb11:
	var22 = var2 - 0x1ull;	// _22 = BinOp(_2 SUB 0x1 usize)
	// ^ Goto(12)
bb12:
	var13 = var10 >= var22;	// _13 = BinOp(_10 GE _22)
	if(var13) goto bb13; else goto bb15;
	// ^ If( _13 : 13, 15)
bb13:
	var23 = & var9;	// _23 = Borrow(Shared, _9)
	var24.TAG = 0;	// _24 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #0, {})
	var25 = & var24;	// _25 = Borrow(Shared, _24)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var23, var25 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _23, _25, ), bb14, bb2)
	// ^ drop(_24)
	if(var13) goto bb23; else goto bb24;
	// ^ If( _13 : 23, 24)
bb15:
	var13 = var10 < var5;	// _13 = BinOp(_10 LT _5)
	if(var13) goto bb16; else goto bb17;
	// ^ If( _13 : 16, 17)
bb16:
	var27 = var5 - var10;	// _27 = BinOp(_5 SUB _10)
	var26 = var11 >> var27;	// _26 = BinOp(_11 BIT_SHR _27)
	var12 = (uint32_t )var26;	// _12 = Cast(_26 as u32)
	goto bb18;
	// ^ Goto(18)
bb17:
	var28 = (uint32_t )var11;	// _28 = Cast(_11 as u32)
	var29 = var10 - var5;	// _29 = BinOp(_10 SUB _5)
	var12 = var28 << var29;	// _12 = BinOp(_28 BIT_SHL _29)
	// ^ Goto(18)
bb18:
	var30 = & var9;	// _30 = Borrow(Shared, _9)
	var31.TAG = 1;	// _31 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	var32 = & var31;	// _32 = Borrow(Shared, _31)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var30, var32 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _30, _32, ), bb19, bb2)
	// ^ drop(_31)
	if(var13) goto bb20; else goto bb21;
	// ^ If( _13 : 20, 21)
bb20:
	var34 = ~var12;	// _34 = UniOp(_12 INV)
	__builtin_add_overflow(var34, 0x1, &var33);
	goto bb22;
	// ^ Call( _33 = "overflowing_add"::<u32,>( _34, 0x1 u32, ), bb22, bb2)
bb21:
	var33 = var12;	// _33 = Use(_12)
	// ^ Goto(22)
bb22:
	// ^ drop(_9)
	rv = var33;	// retval = Use(_33)
	return rv;
	// ^ Return
bb23:
	rv = var1;	// retval = Use(_1)
	goto bb25;
	// ^ Goto(25)
bb24:
	rv = var0;	// retval = Use(_0)
	// ^ Goto(25)
bb25:
	// ^ drop(_9)
	return rv;
	// ^ Return
bb26:
	rv = 0x0;	// retval = Constant(0x0 u32)
	// ^ drop(_9)
	return rv;
	// ^ Return
}
// ::"compiler_builtins-0_0_0_Hb"::float::conv::__fixunsdfti
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv12__fixunsdfti0g(
		double arg0 // f64
		) // -> u128

{
	uint128_t rv;
	uint128_t var0;	// u128
	uint128_t var1;	// u128
	uintptr_t var2;	// usize
	RUST_BOOL var3;	// bool
	uint64_t var4;	// u64
	uintptr_t var5;	// usize
	uintptr_t var6;	// usize
	uint64_t var7;	// u64
	uint64_t var8;	// u64
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var9;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var10;	// usize
	uint64_t var11;	// u64
	uint128_t var12;	// u128
	RUST_BOOL var13;	// bool
	uint32_t var14;	// u32
	uint64_t var15;	// u64
	uint64_t var16;	// u64
	uint64_t var17;	// u64
	uint64_t var18;	// u64
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var19;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var20;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var21;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var22;	// usize
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var23;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var24;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var25;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uint64_t var26;	// u64
	uintptr_t var27;	// usize
	uint128_t var28;	// u128
	uintptr_t var29;	// usize
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var30;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var31;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var32;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uint128_t var33;	// u128
	uint128_t var34;	// u128
	uint128_t var35;	// u128
	var0 = make128_raw(0ull, 0ull);	// _0 = Constant(0x0 u128)
	var34 = make128_raw(0ull, 0ull);	// _34 = Constant(0x0 u128)
	var1.lo = ~var34.lo; var1.hi = ~var34.hi;	// _1 = UniOp(_34 INV)
	var2 = 0x80ull;	// _2 = Constant(0x80 usize)
	var3 = true;	// _3 = Constant(true)
	var4 = 0x8000000000000000ull;	// _4 = Constant(0x8000000000000000 u64)
	var5 = 0x34ull;	// _5 = Constant(0x34 usize)
	var14 = 0x3ff;	// _14 = Constant(0x3ff u32)
	var6 = (uintptr_t )var14;	// _6 = Cast(_14 as usize)
	memcpy( &var7, &arg0, sizeof(double ));
	// ^ Call( _7 = "transmute"::<f64,u64,>( a0, ), bb1, bb2)
	var15 = ~var4;	// _15 = UniOp(_4 INV)
	var8 = var7 & var15;	// _8 = BinOp(_7 BIT_AND _15)
	var16 = var7 & var4;	// _16 = BinOp(_7 BIT_AND _4)
	var13 = var16 == 0x0ull;	// _13 = BinOp(_16 EQ 0x0 u64)
	if(var13) goto bb3; else goto bb4;
	// ^ If( _13 : 3, 4)
bb2: _Unwind_Resume(); // Diverge
bb3:
	var9.TAG = 0;	// _9 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #0, {})
	goto bb5;
	// ^ Goto(5)
bb4:
	var9.TAG = 1;	// _9 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	// ^ Goto(5)
bb5:
	var17 = var8 >> var5;	// _17 = BinOp(_8 BIT_SHR _5)
	var10 = (uintptr_t )var17;	// _10 = Cast(_17 as usize)
	var18 = var8 & 0xfffffffffffffull;	// _18 = BinOp(_8 BIT_AND 0xfffffffffffff u64)
	var11 = var18 | 0x10000000000000ull;	// _11 = BinOp(_18 BIT_OR 0x10000000000000 u64)
	var13 = var10 < var6;	// _13 = BinOp(_10 LT _6)
	if(var13) goto bb26; else goto bb6;
	// ^ If( _13 : 26, 6)
bb6:
	var13 = var3;	// _13 = Use(_3)
	if(var3) goto bb7; else goto bb9;
	// ^ If( _3 : 7, 9)
bb7:
	var19 = & var9;	// _19 = Borrow(Shared, _9)
	var20.TAG = 1;	// _20 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	var21 = & var20;	// _21 = Borrow(Shared, _20)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var19, var21 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _19, _21, ), bb8, bb2)
	// ^ drop(_20)
	if(var13) goto bb26; else goto bb9;
	// ^ If( _13 : 26, 9)
bb9:
	var10 = var10 - var6;	// _10 = BinOp(_10 SUB _6)
	var13 = var3;	// _13 = Use(_3)
	if(var3) goto bb10; else goto bb11;
	// ^ If( _3 : 10, 11)
bb10:
	var22 = var2;	// _22 = Use(_2)
	goto bb12;
	// ^ Goto(12)
bb11:
	var22 = var2 - 0x1ull;	// _22 = BinOp(_2 SUB 0x1 usize)
	// ^ Goto(12)
bb12:
	var13 = var10 >= var22;	// _13 = BinOp(_10 GE _22)
	if(var13) goto bb13; else goto bb15;
	// ^ If( _13 : 13, 15)
bb13:
	var23 = & var9;	// _23 = Borrow(Shared, _9)
	var24.TAG = 0;	// _24 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #0, {})
	var25 = & var24;	// _25 = Borrow(Shared, _24)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var23, var25 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _23, _25, ), bb14, bb2)
	// ^ drop(_24)
	if(var13) goto bb23; else goto bb24;
	// ^ If( _13 : 23, 24)
bb15:
	var13 = var10 < var5;	// _13 = BinOp(_10 LT _5)
	if(var13) goto bb16; else goto bb17;
	// ^ If( _13 : 16, 17)
bb16:
	var27 = var5 - var10;	// _27 = BinOp(_5 SUB _10)
	var26 = var11 >> var27;	// _26 = BinOp(_11 BIT_SHR _27)
	var12.lo = var26; var12.hi = var26 < 0 ? -1 : 0;	// _12 = Cast(_26 as u128)
	goto bb18;
	// ^ Goto(18)
bb17:
	var28.lo = var11; var28.hi = var11 < 0 ? -1 : 0;	// _28 = Cast(_11 as u128)
	var29 = var10 - var5;	// _29 = BinOp(_10 SUB _5)
	var12 = shl128(var28, var29);	// _12 = BinOp(_28 BIT_SHL _29)
	// ^ Goto(18)
bb18:
	var30 = & var9;	// _30 = Borrow(Shared, _9)
	var31.TAG = 1;	// _31 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	var32 = & var31;	// _32 = Borrow(Shared, _31)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var30, var32 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _30, _32, ), bb19, bb2)
	// ^ drop(_31)
	if(var13) goto bb20; else goto bb21;
	// ^ If( _13 : 20, 21)
bb20:
	var35.lo = ~var12.lo; var35.hi = ~var12.hi;	// _35 = UniOp(_12 INV)
	add128_o(var35, make128_raw(0ull, 1ull), &var33);
	goto bb22;
	// ^ Call( _33 = "overflowing_add"::<u128,>( _35, 0x1 u128, ), bb22, bb2)
bb21:
	var33 = var12;	// _33 = Use(_12)
	// ^ Goto(22)
bb22:
	// ^ drop(_9)
	rv = var33;	// retval = Use(_33)
	return rv;
	// ^ Return
bb23:
	rv = var1;	// retval = Use(_1)
	goto bb25;
	// ^ Goto(25)
bb24:
	rv = var0;	// retval = Use(_0)
	// ^ Goto(25)
bb25:
	// ^ drop(_9)
	return rv;
	// ^ Return
bb26:
	rv = make128_raw(0ull, 0ull);	// retval = Constant(0x0 u128)
	// ^ drop(_9)
	return rv;
	// ^ Return
}
// ::"compiler_builtins-0_0_0_Hb"::float::conv::__fixunssfdi
uint64_t  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv12__fixunssfdi0g(
		float arg0 // f32
		) // -> u64

{
	uint64_t rv;
	uint64_t var0;	// u64
	uint64_t var1;	// u64
	uintptr_t var2;	// usize
	RUST_BOOL var3;	// bool
	uint32_t var4;	// u32
	uintptr_t var5;	// usize
	uintptr_t var6;	// usize
	uint32_t var7;	// u32
	uint32_t var8;	// u32
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var9;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var10;	// usize
	uint32_t var11;	// u32
	uint64_t var12;	// u64
	RUST_BOOL var13;	// bool
	uint32_t var14;	// u32
	uint32_t var15;	// u32
	uint32_t var16;	// u32
	uint32_t var17;	// u32
	uint32_t var18;	// u32
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var19;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var20;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var21;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var22;	// usize
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var23;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var24;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var25;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uint32_t var26;	// u32
	uintptr_t var27;	// usize
	uint64_t var28;	// u64
	uintptr_t var29;	// usize
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var30;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var31;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var32;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uint64_t var33;	// u64
	uint64_t var34;	// u64
	var0 = 0x0ull;	// _0 = Constant(0x0 u64)
	var1 = 0xffffffffffffffffull;	// _1 = Constant(0xffffffffffffffff u64)
	var2 = 0x40ull;	// _2 = Constant(0x40 usize)
	var3 = true;	// _3 = Constant(true)
	var4 = 0x80000000;	// _4 = Constant(0x80000000 u32)
	var5 = 0x17ull;	// _5 = Constant(0x17 usize)
	var14 = 0x7f;	// _14 = Constant(0x7f u32)
	var6 = (uintptr_t )var14;	// _6 = Cast(_14 as usize)
	memcpy( &var7, &arg0, sizeof(float ));
	// ^ Call( _7 = "transmute"::<f32,u32,>( a0, ), bb1, bb2)
	var15 = ~var4;	// _15 = UniOp(_4 INV)
	var8 = var7 & var15;	// _8 = BinOp(_7 BIT_AND _15)
	var16 = var7 & var4;	// _16 = BinOp(_7 BIT_AND _4)
	var13 = var16 == 0x0;	// _13 = BinOp(_16 EQ 0x0 u32)
	if(var13) goto bb3; else goto bb4;
	// ^ If( _13 : 3, 4)
bb2: _Unwind_Resume(); // Diverge
bb3:
	var9.TAG = 0;	// _9 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #0, {})
	goto bb5;
	// ^ Goto(5)
bb4:
	var9.TAG = 1;	// _9 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	// ^ Goto(5)
bb5:
	var17 = var8 >> var5;	// _17 = BinOp(_8 BIT_SHR _5)
	var10 = (uintptr_t )var17;	// _10 = Cast(_17 as usize)
	var18 = var8 & 0x7fffff;	// _18 = BinOp(_8 BIT_AND 0x7fffff u32)
	var11 = var18 | 0x800000;	// _11 = BinOp(_18 BIT_OR 0x800000 u32)
	var13 = var10 < var6;	// _13 = BinOp(_10 LT _6)
	if(var13) goto bb26; else goto bb6;
	// ^ If( _13 : 26, 6)
bb6:
	var13 = var3;	// _13 = Use(_3)
	if(var3) goto bb7; else goto bb9;
	// ^ If( _3 : 7, 9)
bb7:
	var19 = & var9;	// _19 = Borrow(Shared, _9)
	var20.TAG = 1;	// _20 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	var21 = & var20;	// _21 = Borrow(Shared, _20)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var19, var21 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _19, _21, ), bb8, bb2)
	// ^ drop(_20)
	if(var13) goto bb26; else goto bb9;
	// ^ If( _13 : 26, 9)
bb9:
	var10 = var10 - var6;	// _10 = BinOp(_10 SUB _6)
	var13 = var3;	// _13 = Use(_3)
	if(var3) goto bb10; else goto bb11;
	// ^ If( _3 : 10, 11)
bb10:
	var22 = var2;	// _22 = Use(_2)
	goto bb12;
	// ^ Goto(12)
bb11:
	var22 = var2 - 0x1ull;	// _22 = BinOp(_2 SUB 0x1 usize)
	// ^ Goto(12)
bb12:
	var13 = var10 >= var22;	// _13 = BinOp(_10 GE _22)
	if(var13) goto bb13; else goto bb15;
	// ^ If( _13 : 13, 15)
bb13:
	var23 = & var9;	// _23 = Borrow(Shared, _9)
	var24.TAG = 0;	// _24 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #0, {})
	var25 = & var24;	// _25 = Borrow(Shared, _24)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var23, var25 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _23, _25, ), bb14, bb2)
	// ^ drop(_24)
	if(var13) goto bb23; else goto bb24;
	// ^ If( _13 : 23, 24)
bb15:
	var13 = var10 < var5;	// _13 = BinOp(_10 LT _5)
	if(var13) goto bb16; else goto bb17;
	// ^ If( _13 : 16, 17)
bb16:
	var27 = var5 - var10;	// _27 = BinOp(_5 SUB _10)
	var26 = var11 >> var27;	// _26 = BinOp(_11 BIT_SHR _27)
	var12 = (uint64_t )var26;	// _12 = Cast(_26 as u64)
	goto bb18;
	// ^ Goto(18)
bb17:
	var28 = (uint64_t )var11;	// _28 = Cast(_11 as u64)
	var29 = var10 - var5;	// _29 = BinOp(_10 SUB _5)
	var12 = var28 << var29;	// _12 = BinOp(_28 BIT_SHL _29)
	// ^ Goto(18)
bb18:
	var30 = & var9;	// _30 = Borrow(Shared, _9)
	var31.TAG = 1;	// _31 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	var32 = & var31;	// _32 = Borrow(Shared, _31)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var30, var32 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _30, _32, ), bb19, bb2)
	// ^ drop(_31)
	if(var13) goto bb20; else goto bb21;
	// ^ If( _13 : 20, 21)
bb20:
	var34 = ~var12;	// _34 = UniOp(_12 INV)
	__builtin_add_overflow(var34, 0x1ull, &var33);
	goto bb22;
	// ^ Call( _33 = "overflowing_add"::<u64,>( _34, 0x1 u64, ), bb22, bb2)
bb21:
	var33 = var12;	// _33 = Use(_12)
	// ^ Goto(22)
bb22:
	// ^ drop(_9)
	rv = var33;	// retval = Use(_33)
	return rv;
	// ^ Return
bb23:
	rv = var1;	// retval = Use(_1)
	goto bb25;
	// ^ Goto(25)
bb24:
	rv = var0;	// retval = Use(_0)
	// ^ Goto(25)
bb25:
	// ^ drop(_9)
	return rv;
	// ^ Return
bb26:
	rv = 0x0ull;	// retval = Constant(0x0 u64)
	// ^ drop(_9)
	return rv;
	// ^ Return
}
// ::"compiler_builtins-0_0_0_Hb"::float::conv::__fixunssfsi
uint32_t  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv12__fixunssfsi0g(
		float arg0 // f32
		) // -> u32

{
	uint32_t rv;
	uint32_t var0;	// u32
	uint32_t var1;	// u32
	uintptr_t var2;	// usize
	RUST_BOOL var3;	// bool
	uint32_t var4;	// u32
	uintptr_t var5;	// usize
	uintptr_t var6;	// usize
	uint32_t var7;	// u32
	uint32_t var8;	// u32
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var9;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var10;	// usize
	uint32_t var11;	// u32
	uint32_t var12;	// u32
	RUST_BOOL var13;	// bool
	uint32_t var14;	// u32
	uint32_t var15;	// u32
	uint32_t var16;	// u32
	uint32_t var17;	// u32
	uint32_t var18;	// u32
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var19;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var20;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var21;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var22;	// usize
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var23;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var24;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var25;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var26;	// usize
	uintptr_t var27;	// usize
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var28;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var29;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var30;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uint32_t var31;	// u32
	uint32_t var32;	// u32
	var0 = 0x0;	// _0 = Constant(0x0 u32)
	var1 = 0xffffffff;	// _1 = Constant(0xffffffff u32)
	var2 = 0x20ull;	// _2 = Constant(0x20 usize)
	var3 = true;	// _3 = Constant(true)
	var4 = 0x80000000;	// _4 = Constant(0x80000000 u32)
	var5 = 0x17ull;	// _5 = Constant(0x17 usize)
	var14 = 0x7f;	// _14 = Constant(0x7f u32)
	var6 = (uintptr_t )var14;	// _6 = Cast(_14 as usize)
	memcpy( &var7, &arg0, sizeof(float ));
	// ^ Call( _7 = "transmute"::<f32,u32,>( a0, ), bb1, bb2)
	var15 = ~var4;	// _15 = UniOp(_4 INV)
	var8 = var7 & var15;	// _8 = BinOp(_7 BIT_AND _15)
	var16 = var7 & var4;	// _16 = BinOp(_7 BIT_AND _4)
	var13 = var16 == 0x0;	// _13 = BinOp(_16 EQ 0x0 u32)
	if(var13) goto bb3; else goto bb4;
	// ^ If( _13 : 3, 4)
bb2: _Unwind_Resume(); // Diverge
bb3:
	var9.TAG = 0;	// _9 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #0, {})
	goto bb5;
	// ^ Goto(5)
bb4:
	var9.TAG = 1;	// _9 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	// ^ Goto(5)
bb5:
	var17 = var8 >> var5;	// _17 = BinOp(_8 BIT_SHR _5)
	var10 = (uintptr_t )var17;	// _10 = Cast(_17 as usize)
	var18 = var8 & 0x7fffff;	// _18 = BinOp(_8 BIT_AND 0x7fffff u32)
	var11 = var18 | 0x800000;	// _11 = BinOp(_18 BIT_OR 0x800000 u32)
	var13 = var10 < var6;	// _13 = BinOp(_10 LT _6)
	if(var13) goto bb26; else goto bb6;
	// ^ If( _13 : 26, 6)
bb6:
	var13 = var3;	// _13 = Use(_3)
	if(var3) goto bb7; else goto bb9;
	// ^ If( _3 : 7, 9)
bb7:
	var19 = & var9;	// _19 = Borrow(Shared, _9)
	var20.TAG = 1;	// _20 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	var21 = & var20;	// _21 = Borrow(Shared, _20)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var19, var21 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _19, _21, ), bb8, bb2)
	// ^ drop(_20)
	if(var13) goto bb26; else goto bb9;
	// ^ If( _13 : 26, 9)
bb9:
	var10 = var10 - var6;	// _10 = BinOp(_10 SUB _6)
	var13 = var3;	// _13 = Use(_3)
	if(var3) goto bb10; else goto bb11;
	// ^ If( _3 : 10, 11)
bb10:
	var22 = var2;	// _22 = Use(_2)
	goto bb12;
	// ^ Goto(12)
bb11:
	var22 = var2 - 0x1ull;	// _22 = BinOp(_2 SUB 0x1 usize)
	// ^ Goto(12)
bb12:
	var13 = var10 >= var22;	// _13 = BinOp(_10 GE _22)
	if(var13) goto bb13; else goto bb15;
	// ^ If( _13 : 13, 15)
bb13:
	var23 = & var9;	// _23 = Borrow(Shared, _9)
	var24.TAG = 0;	// _24 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #0, {})
	var25 = & var24;	// _25 = Borrow(Shared, _24)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var23, var25 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _23, _25, ), bb14, bb2)
	// ^ drop(_24)
	if(var13) goto bb23; else goto bb24;
	// ^ If( _13 : 23, 24)
bb15:
	var13 = var10 < var5;	// _13 = BinOp(_10 LT _5)
	if(var13) goto bb16; else goto bb17;
	// ^ If( _13 : 16, 17)
bb16:
	var26 = var5 - var10;	// _26 = BinOp(_5 SUB _10)
	var12 = var11 >> var26;	// _12 = BinOp(_11 BIT_SHR _26)
	goto bb18;
	// ^ Goto(18)
bb17:
	var27 = var10 - var5;	// _27 = BinOp(_10 SUB _5)
	var12 = var11 << var27;	// _12 = BinOp(_11 BIT_SHL _27)
	// ^ Goto(18)
bb18:
	var28 = & var9;	// _28 = Borrow(Shared, _9)
	var29.TAG = 1;	// _29 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	var30 = & var29;	// _30 = Borrow(Shared, _29)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var28, var30 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _28, _30, ), bb19, bb2)
	// ^ drop(_29)
	if(var13) goto bb20; else goto bb21;
	// ^ If( _13 : 20, 21)
bb20:
	var32 = ~var12;	// _32 = UniOp(_12 INV)
	__builtin_add_overflow(var32, 0x1, &var31);
	goto bb22;
	// ^ Call( _31 = "overflowing_add"::<u32,>( _32, 0x1 u32, ), bb22, bb2)
bb21:
	var31 = var12;	// _31 = Use(_12)
	// ^ Goto(22)
bb22:
	// ^ drop(_9)
	rv = var31;	// retval = Use(_31)
	return rv;
	// ^ Return
bb23:
	rv = var1;	// retval = Use(_1)
	goto bb25;
	// ^ Goto(25)
bb24:
	rv = var0;	// retval = Use(_0)
	// ^ Goto(25)
bb25:
	// ^ drop(_9)
	return rv;
	// ^ Return
bb26:
	rv = 0x0;	// retval = Constant(0x0 u32)
	// ^ drop(_9)
	return rv;
	// ^ Return
}
// ::"compiler_builtins-0_0_0_Hb"::float::conv::__fixunssfti
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv12__fixunssfti0g(
		float arg0 // f32
		) // -> u128

{
	uint128_t rv;
	uint128_t var0;	// u128
	uint128_t var1;	// u128
	uintptr_t var2;	// usize
	RUST_BOOL var3;	// bool
	uint32_t var4;	// u32
	uintptr_t var5;	// usize
	uintptr_t var6;	// usize
	uint32_t var7;	// u32
	uint32_t var8;	// u32
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var9;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var10;	// usize
	uint32_t var11;	// u32
	uint128_t var12;	// u128
	RUST_BOOL var13;	// bool
	uint32_t var14;	// u32
	uint32_t var15;	// u32
	uint32_t var16;	// u32
	uint32_t var17;	// u32
	uint32_t var18;	// u32
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var19;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var20;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var21;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uintptr_t var22;	// usize
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var23;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var24;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var25;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uint32_t var26;	// u32
	uintptr_t var27;	// usize
	uint128_t var28;	// u128
	uintptr_t var29;	// usize
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var30;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g var31;	// ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var32;	// &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	uint128_t var33;	// u128
	uint128_t var34;	// u128
	uint128_t var35;	// u128
	var0 = make128_raw(0ull, 0ull);	// _0 = Constant(0x0 u128)
	var34 = make128_raw(0ull, 0ull);	// _34 = Constant(0x0 u128)
	var1.lo = ~var34.lo; var1.hi = ~var34.hi;	// _1 = UniOp(_34 INV)
	var2 = 0x80ull;	// _2 = Constant(0x80 usize)
	var3 = true;	// _3 = Constant(true)
	var4 = 0x80000000;	// _4 = Constant(0x80000000 u32)
	var5 = 0x17ull;	// _5 = Constant(0x17 usize)
	var14 = 0x7f;	// _14 = Constant(0x7f u32)
	var6 = (uintptr_t )var14;	// _6 = Cast(_14 as usize)
	memcpy( &var7, &arg0, sizeof(float ));
	// ^ Call( _7 = "transmute"::<f32,u32,>( a0, ), bb1, bb2)
	var15 = ~var4;	// _15 = UniOp(_4 INV)
	var8 = var7 & var15;	// _8 = BinOp(_7 BIT_AND _15)
	var16 = var7 & var4;	// _16 = BinOp(_7 BIT_AND _4)
	var13 = var16 == 0x0;	// _13 = BinOp(_16 EQ 0x0 u32)
	if(var13) goto bb3; else goto bb4;
	// ^ If( _13 : 3, 4)
bb2: _Unwind_Resume(); // Diverge
bb3:
	var9.TAG = 0;	// _9 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #0, {})
	goto bb5;
	// ^ Goto(5)
bb4:
	var9.TAG = 1;	// _9 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	// ^ Goto(5)
bb5:
	var17 = var8 >> var5;	// _17 = BinOp(_8 BIT_SHR _5)
	var10 = (uintptr_t )var17;	// _10 = Cast(_17 as usize)
	var18 = var8 & 0x7fffff;	// _18 = BinOp(_8 BIT_AND 0x7fffff u32)
	var11 = var18 | 0x800000;	// _11 = BinOp(_18 BIT_OR 0x800000 u32)
	var13 = var10 < var6;	// _13 = BinOp(_10 LT _6)
	if(var13) goto bb26; else goto bb6;
	// ^ If( _13 : 26, 6)
bb6:
	var13 = var3;	// _13 = Use(_3)
	if(var3) goto bb7; else goto bb9;
	// ^ If( _3 : 7, 9)
bb7:
	var19 = & var9;	// _19 = Borrow(Shared, _9)
	var20.TAG = 1;	// _20 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	var21 = & var20;	// _21 = Borrow(Shared, _20)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var19, var21 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _19, _21, ), bb8, bb2)
	// ^ drop(_20)
	if(var13) goto bb26; else goto bb9;
	// ^ If( _13 : 26, 9)
bb9:
	var10 = var10 - var6;	// _10 = BinOp(_10 SUB _6)
	var13 = var3;	// _13 = Use(_3)
	if(var3) goto bb10; else goto bb11;
	// ^ If( _3 : 10, 11)
bb10:
	var22 = var2;	// _22 = Use(_2)
	goto bb12;
	// ^ Goto(12)
bb11:
	var22 = var2 - 0x1ull;	// _22 = BinOp(_2 SUB 0x1 usize)
	// ^ Goto(12)
bb12:
	var13 = var10 >= var22;	// _13 = BinOp(_10 GE _22)
	if(var13) goto bb13; else goto bb15;
	// ^ If( _13 : 13, 15)
bb13:
	var23 = & var9;	// _23 = Borrow(Shared, _9)
	var24.TAG = 0;	// _24 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #0, {})
	var25 = & var24;	// _25 = Borrow(Shared, _24)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var23, var25 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _23, _25, ), bb14, bb2)
	// ^ drop(_24)
	if(var13) goto bb23; else goto bb24;
	// ^ If( _13 : 23, 24)
bb15:
	var13 = var10 < var5;	// _13 = BinOp(_10 LT _5)
	if(var13) goto bb16; else goto bb17;
	// ^ If( _13 : 16, 17)
bb16:
	var27 = var5 - var10;	// _27 = BinOp(_5 SUB _10)
	var26 = var11 >> var27;	// _26 = BinOp(_11 BIT_SHR _27)
	var12.lo = var26; var12.hi = var26 < 0 ? -1 : 0;	// _12 = Cast(_26 as u128)
	goto bb18;
	// ^ Goto(18)
bb17:
	var28.lo = var11; var28.hi = var11 < 0 ? -1 : 0;	// _28 = Cast(_11 as u128)
	var29 = var10 - var5;	// _29 = BinOp(_10 SUB _5)
	var12 = shl128(var28, var29);	// _12 = BinOp(_28 BIT_SHL _29)
	// ^ Goto(18)
bb18:
	var30 = & var9;	// _30 = Borrow(Shared, _9)
	var31.TAG = 1;	// _31 = Variant(::"compiler_builtins-0_0_0_Hb"::float::conv::Sign #1, {})
	var32 = & var31;	// _32 = Borrow(Shared, _31)
	var13 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( var30, var32 );
	// ^ Call( _13 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( _30, _32, ), bb19, bb2)
	// ^ drop(_31)
	if(var13) goto bb20; else goto bb21;
	// ^ If( _13 : 20, 21)
bb20:
	var35.lo = ~var12.lo; var35.hi = ~var12.hi;	// _35 = UniOp(_12 INV)
	add128_o(var35, make128_raw(0ull, 1ull), &var33);
	goto bb22;
	// ^ Call( _33 = "overflowing_add"::<u128,>( _35, 0x1 u128, ), bb22, bb2)
bb21:
	var33 = var12;	// _33 = Use(_12)
	// ^ Goto(22)
bb22:
	// ^ drop(_9)
	rv = var33;	// retval = Use(_33)
	return rv;
	// ^ Return
bb23:
	rv = var1;	// retval = Use(_1)
	goto bb25;
	// ^ Goto(25)
bb24:
	rv = var0;	// retval = Use(_0)
	// ^ Goto(25)
bb25:
	// ^ drop(_9)
	return rv;
	// ^ Return
bb26:
	rv = make128_raw(0ull, 0ull);	// retval = Constant(0x0 u128)
	// ^ drop(_9)
	return rv;
	// ^ Return
}
// ::"compiler_builtins-0_0_0_Hb"::float::conv::__floatdidf
double  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv11__floatdidf0g(
		int64_t arg0 // i64
		) // -> f64

{
	double rv;
	rv = (double )arg0;	// retval = Cast(a0 as f64)
	return rv;
	// ^ Return
}
// ::"compiler_builtins-0_0_0_Hb"::float::conv::__floatdisf
float  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv11__floatdisf0g(
		int64_t arg0 // i64
		) // -> f32

{
	float rv;
	rv = (float )arg0;	// retval = Cast(a0 as f32)
	return rv;
	// ^ Return
}
// ::"compiler_builtins-0_0_0_Hb"::float::conv::__floatsidf
double  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv11__floatsidf0g(
		int32_t arg0 // i32
		) // -> f64

{
	double rv;
	int32_t var0;	// i32
	uint32_t var1;	// u32
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	RUST_BOOL var4;	// bool
	uint32_t var5;	// u32
	uint32_t var6;	// u32
	uint32_t var7;	// u32
	uint32_t var8;	// u32
	uint32_t var9;	// u32
	RUST_BOOL var10;	// bool
	TUP_2_ZRTCw_ZRTCe var11;	// (bool, u32, )
	uint32_t var12;	// u32
	uint32_t var13;	// u32
	uint64_t var14;	// u64
	uint32_t var15;	// u32
	uint32_t var16;	// u32
	uint32_t var17;	// u32
	uint32_t var18;	// u32
	uint32_t var19;	// u32
	uint32_t var20;	// u32
	RUST_BOOL var21;	// bool
	uint32_t var22;	// u32
	uint32_t var23;	// u32
	uint32_t var24;	// u32
	RUST_BOOL var25;	// bool
	uint32_t var26;	// u32
	uint32_t var27;	// u32
	uint32_t var28;	// u32
	uint32_t var29;	// u32
	uint32_t var30;	// u32
	uint64_t var31;	// u64
	uint64_t var32;	// u64
	uint64_t var33;	// u64
	uint64_t var34;	// u64
	uint64_t var35;	// u64
	uint64_t var36;	// u64
	uint64_t var37;	// u64
	uint64_t var38;	// u64
	uint32_t var39;	// u32
	uint32_t var40;	// u32
	uint64_t var41;	// u64
	uint64_t var42;	// u64
	uint64_t var43;	// u64
	uint64_t var44;	// u64
	uint64_t var45;	// u64
	uint64_t var46;	// u64
	uint64_t var47;	// u64
	uint64_t var48;	// u64
	uint32_t var49;	// u32
	uint32_t var50;	// u32
	uint32_t var51;	// u32
	uint64_t var52;	// u64
	uint64_t var53;	// u64
	var0 = arg0;	// _0 = Use(a0)
	var10 = arg0 == 0;	// _10 = BinOp(a0 EQ +0 i32)
	if(var10) goto bb1; else goto bb2;
	// ^ If( _10 : 1, 2)
bb1:
	rv = 0.000000000000000000e+00;	// retval = Constant(0x0p+0 f64)
	return rv;
	// ^ Return
bb2:
	var1 = 0x35;	// _1 = Constant(0x35 u32)
	var2 = 0x3ff;	// _2 = Constant(0x3ff u32)
	var3 = 0x20;	// _3 = Constant(0x20 u32)
	var11 = ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g12extract_sign0g( var0 );
	// ^ Call( _11 = <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::extract_sign( _0, ), bb3, bb5)
	var5 = var11._1;	// _5 = Use(_11.1)
	var4 = var11._0;	// _4 = Use(_11.0)
	var12 = (var5 != 0 ? __builtin_clz(var5) : sizeof(uint32_t )*8);
	// ^ Call( _12 = "ctlz"::<u32,>( _5, ), bb4, bb5)
	var6 = var3 - var12;	// _6 = BinOp(_3 SUB _12)
	var7 = var6 - 0x1;	// _7 = BinOp(_6 SUB 0x1 u32)
	var10 = 0x20 < var1;	// _10 = BinOp(0x20 u32 LT _1)
	if(var10) goto bb6; else goto bb7;
	// ^ If( _10 : 6, 7)
bb5: _Unwind_Resume(); // Diverge
bb6:
	var13 = var7 + var2;	// _13 = BinOp(_7 ADD _2)
	var37 = (uint64_t )var13;	// _37 = Cast(_13 as u64)
	var14 = (uint64_t )var5;	// _14 = Cast(_5 as u64)
	var16 = var1 - var7;	// _16 = BinOp(_1 SUB _7)
	var15 = var16 - 0x1;	// _15 = BinOp(_16 SUB 0x1 u32)
	var38 = var14 << var15;	// _38 = BinOp(_14 BIT_SHL _15)
	var33 = (uint64_t )var4;	// _33 = Cast(_4 as u64)
	var32 = var33 << 0x3f;	// _32 = BinOp(_33 BIT_SHL 0x3f u32)
	var35 = var37 << 0x34;	// _35 = BinOp(_37 BIT_SHL 0x34 u32)
	var34 = var35 & 0x7ff0000000000000ull;	// _34 = BinOp(_35 BIT_AND 0x7ff0000000000000 u64)
	var31 = var32 | var34;	// _31 = BinOp(_32 BIT_OR _34)
	var36 = var38 & 0xfffffffffffffull;	// _36 = BinOp(_38 BIT_AND 0xfffffffffffff u64)
	var52 = var31 | var36;	// _52 = BinOp(_31 BIT_OR _36)
	memcpy( &rv, &var52, sizeof(uint64_t ));
	goto bb11;
	// ^ Call( retval = "transmute"::<u64,f64,>( _52, ), bb11, bb5)
bb7:
	var10 = var6 > var1;	// _10 = BinOp(_6 GT _1)
	if(var10) goto bb8; else goto bb9;
	// ^ If( _10 : 8, 9)
bb8:
	var8 = var1 + 0x1;	// _8 = BinOp(_1 ADD 0x1 u32)
	var9 = var1 + 0x2;	// _9 = BinOp(_1 ADD 0x2 u32)
	var10 = var6 == var8;	// _10 = BinOp(_6 EQ _8)
	if(var10) goto bb12; else goto bb13;
	// ^ If( _10 : 12, 13)
bb9:
	var40 = var1 - var6;	// _40 = BinOp(_1 SUB _6)
	var39 = var40 & 0x1f;	// _39 = BinOp(_40 BIT_AND 0x1f u32)
	var17 = var5 << var39;
	// ^ Call( _17 = "unchecked_shl"::<u32,>( _5, _39, ), bb10, bb5)
bb10:
	var5 = var17;	// _5 = Use(_17)
	var30 = var7 + var2;	// _30 = BinOp(_7 ADD _2)
	var47 = (uint64_t )var30;	// _47 = Cast(_30 as u64)
	var48 = (uint64_t )var17;	// _48 = Cast(_17 as u64)
	var43 = (uint64_t )var4;	// _43 = Cast(_4 as u64)
	var42 = var43 << 0x3f;	// _42 = BinOp(_43 BIT_SHL 0x3f u32)
	var45 = var47 << 0x34;	// _45 = BinOp(_47 BIT_SHL 0x34 u32)
	var44 = var45 & 0x7ff0000000000000ull;	// _44 = BinOp(_45 BIT_AND 0x7ff0000000000000 u64)
	var41 = var42 | var44;	// _41 = BinOp(_42 BIT_OR _44)
	var46 = var48 & 0xfffffffffffffull;	// _46 = BinOp(_48 BIT_AND 0xfffffffffffff u64)
	var53 = var41 | var46;	// _53 = BinOp(_41 BIT_OR _46)
	memcpy( &rv, &var53, sizeof(uint64_t ));
	// ^ Call( retval = "transmute"::<u64,f64,>( _53, ), bb11, bb5)
bb11:
	return rv;
	// ^ Return
bb12:
	var18 = var5 << 1;	// _18 = BinOp(_5 BIT_SHL +1 i32)
	goto bb17;
	// ^ Goto(17)
bb13:
	var10 = var6 == var9;	// _10 = BinOp(_6 EQ _9)
	if(var10) goto bb14; else goto bb15;
	// ^ If( _10 : 14, 15)
bb14:
	var18 = var5;	// _18 = Use(_5)
	goto bb17;
	// ^ Goto(17)
bb15:
	var20 = var6 - var9;	// _20 = BinOp(_6 SUB _9)
	var19 = var5 >> var20;	// _19 = BinOp(_5 BIT_SHR _20)
	var50 = var5 & 0xffffffff;	// _50 = BinOp(_5 BIT_AND 0xffffffff u32)
	var22 = var3 + var9;	// _22 = BinOp(_3 ADD _9)
	var51 = var22 - var6;	// _51 = BinOp(_22 SUB _6)
	var49 = var51 & 0x1f;	// _49 = BinOp(_51 BIT_AND 0x1f u32)
	var23 = var50 << var49;
	// ^ Call( _23 = "unchecked_shl"::<u32,>( _50, _49, ), bb16, bb5)
	var21 = var23 != 0x0;	// _21 = BinOp(_23 NE 0x0 u32)
	var24 = (uint32_t )var21;	// _24 = Cast(_21 as u32)
	var18 = var19 | var24;	// _18 = BinOp(_19 BIT_OR _24)
	// ^ Goto(17)
bb17:
	var5 = var18;	// _5 = Use(_18)
	var26 = var18 & 0x4;	// _26 = BinOp(_18 BIT_AND 0x4 u32)
	var25 = var26 != 0x0;	// _25 = BinOp(_26 NE 0x0 u32)
	var27 = (uint32_t )var25;	// _27 = Cast(_25 as u32)
	var5 = var5 | var27;	// _5 = BinOp(_5 BIT_OR _27)
	var5 = var5 + 0x1;	// _5 = BinOp(_5 ADD 0x1 u32)
	var5 = var5 >> 2;	// _5 = BinOp(_5 BIT_SHR +2 i32)
	var29 = 0x1 << var1;	// _29 = BinOp(0x1 u32 BIT_SHL _1)
	var28 = var5 & var29;	// _28 = BinOp(_5 BIT_AND _29)
	var10 = var28 != 0x0;	// _10 = BinOp(_28 NE 0x0 u32)
	if(var10) goto bb18; else goto bb19;
	// ^ If( _10 : 18, 19)
bb18:
	var5 = var5 >> 1;	// _5 = BinOp(_5 BIT_SHR +1 i32)
	var7 = var7 + 0x1;	// _7 = BinOp(_7 ADD 0x1 u32)
	// ^ Goto(19)
bb19:
	var17 = var5;	// _17 = Use(_5)
	goto bb10;
	// ^ Goto(10)
}
// ::"compiler_builtins-0_0_0_Hb"::float::conv::__floatsisf
float  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv11__floatsisf0g(
		int32_t arg0 // i32
		) // -> f32

{
	float rv;
	int32_t var0;	// i32
	uint32_t var1;	// u32
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	RUST_BOOL var4;	// bool
	uint32_t var5;	// u32
	uint32_t var6;	// u32
	uint32_t var7;	// u32
	uint32_t var8;	// u32
	uint32_t var9;	// u32
	RUST_BOOL var10;	// bool
	TUP_2_ZRTCw_ZRTCe var11;	// (bool, u32, )
	uint32_t var12;	// u32
	uint32_t var13;	// u32
	uint32_t var14;	// u32
	uint32_t var15;	// u32
	uint32_t var16;	// u32
	uint32_t var17;	// u32
	uint32_t var18;	// u32
	RUST_BOOL var19;	// bool
	uint32_t var20;	// u32
	uint32_t var21;	// u32
	uint32_t var22;	// u32
	RUST_BOOL var23;	// bool
	uint32_t var24;	// u32
	uint32_t var25;	// u32
	uint32_t var26;	// u32
	uint32_t var27;	// u32
	uint32_t var28;	// u32
	uint32_t var29;	// u32
	uint32_t var30;	// u32
	uint32_t var31;	// u32
	uint32_t var32;	// u32
	uint32_t var33;	// u32
	uint32_t var34;	// u32
	uint32_t var35;	// u32
	uint32_t var36;	// u32
	uint32_t var37;	// u32
	uint32_t var38;	// u32
	uint32_t var39;	// u32
	uint32_t var40;	// u32
	uint32_t var41;	// u32
	uint32_t var42;	// u32
	uint32_t var43;	// u32
	uint32_t var44;	// u32
	uint32_t var45;	// u32
	uint32_t var46;	// u32
	uint32_t var47;	// u32
	uint32_t var48;	// u32
	uint32_t var49;	// u32
	var0 = arg0;	// _0 = Use(a0)
	var10 = arg0 == 0;	// _10 = BinOp(a0 EQ +0 i32)
	if(var10) goto bb1; else goto bb2;
	// ^ If( _10 : 1, 2)
bb1:
	rv = 0.0000000000e+00f;	// retval = Constant(0x0p+0 f32)
	return rv;
	// ^ Return
bb2:
	var1 = 0x18;	// _1 = Constant(0x18 u32)
	var2 = 0x7f;	// _2 = Constant(0x7f u32)
	var3 = 0x20;	// _3 = Constant(0x20 u32)
	var11 = ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g12extract_sign0g( var0 );
	// ^ Call( _11 = <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::extract_sign( _0, ), bb3, bb5)
	var5 = var11._1;	// _5 = Use(_11.1)
	var4 = var11._0;	// _4 = Use(_11.0)
	var12 = (var5 != 0 ? __builtin_clz(var5) : sizeof(uint32_t )*8);
	// ^ Call( _12 = "ctlz"::<u32,>( _5, ), bb4, bb5)
	var6 = var3 - var12;	// _6 = BinOp(_3 SUB _12)
	var7 = var6 - 0x1;	// _7 = BinOp(_6 SUB 0x1 u32)
	var10 = 0x20 < var1;	// _10 = BinOp(0x20 u32 LT _1)
	if(var10) goto bb6; else goto bb7;
	// ^ If( _10 : 6, 7)
bb5: _Unwind_Resume(); // Diverge
bb6:
	var34 = var7 + var2;	// _34 = BinOp(_7 ADD _2)
	var14 = var1 - var7;	// _14 = BinOp(_1 SUB _7)
	var13 = var14 - 0x1;	// _13 = BinOp(_14 SUB 0x1 u32)
	var35 = var5 << var13;	// _35 = BinOp(_5 BIT_SHL _13)
	var30 = (uint32_t )var4;	// _30 = Cast(_4 as u32)
	var29 = var30 << 0x1f;	// _29 = BinOp(_30 BIT_SHL 0x1f u32)
	var32 = var34 << 0x17;	// _32 = BinOp(_34 BIT_SHL 0x17 u32)
	var31 = var32 & 0x7f800000;	// _31 = BinOp(_32 BIT_AND 0x7f800000 u32)
	var28 = var29 | var31;	// _28 = BinOp(_29 BIT_OR _31)
	var33 = var35 & 0x7fffff;	// _33 = BinOp(_35 BIT_AND 0x7fffff u32)
	var48 = var28 | var33;	// _48 = BinOp(_28 BIT_OR _33)
	memcpy( &rv, &var48, sizeof(uint32_t ));
	goto bb11;
	// ^ Call( retval = "transmute"::<u32,f32,>( _48, ), bb11, bb5)
bb7:
	var10 = var6 > var1;	// _10 = BinOp(_6 GT _1)
	if(var10) goto bb8; else goto bb9;
	// ^ If( _10 : 8, 9)
bb8:
	var8 = var1 + 0x1;	// _8 = BinOp(_1 ADD 0x1 u32)
	var9 = var1 + 0x2;	// _9 = BinOp(_1 ADD 0x2 u32)
	var10 = var6 == var8;	// _10 = BinOp(_6 EQ _8)
	if(var10) goto bb12; else goto bb13;
	// ^ If( _10 : 12, 13)
bb9:
	var37 = var1 - var6;	// _37 = BinOp(_1 SUB _6)
	var36 = var37 & 0x1f;	// _36 = BinOp(_37 BIT_AND 0x1f u32)
	var15 = var5 << var36;
	// ^ Call( _15 = "unchecked_shl"::<u32,>( _5, _36, ), bb10, bb5)
bb10:
	var5 = var15;	// _5 = Use(_15)
	var44 = var7 + var2;	// _44 = BinOp(_7 ADD _2)
	var40 = (uint32_t )var4;	// _40 = Cast(_4 as u32)
	var39 = var40 << 0x1f;	// _39 = BinOp(_40 BIT_SHL 0x1f u32)
	var42 = var44 << 0x17;	// _42 = BinOp(_44 BIT_SHL 0x17 u32)
	var41 = var42 & 0x7f800000;	// _41 = BinOp(_42 BIT_AND 0x7f800000 u32)
	var38 = var39 | var41;	// _38 = BinOp(_39 BIT_OR _41)
	var43 = var15 & 0x7fffff;	// _43 = BinOp(_15 BIT_AND 0x7fffff u32)
	var49 = var38 | var43;	// _49 = BinOp(_38 BIT_OR _43)
	memcpy( &rv, &var49, sizeof(uint32_t ));
	// ^ Call( retval = "transmute"::<u32,f32,>( _49, ), bb11, bb5)
bb11:
	return rv;
	// ^ Return
bb12:
	var16 = var5 << 1;	// _16 = BinOp(_5 BIT_SHL +1 i32)
	goto bb17;
	// ^ Goto(17)
bb13:
	var10 = var6 == var9;	// _10 = BinOp(_6 EQ _9)
	if(var10) goto bb14; else goto bb15;
	// ^ If( _10 : 14, 15)
bb14:
	var16 = var5;	// _16 = Use(_5)
	goto bb17;
	// ^ Goto(17)
bb15:
	var18 = var6 - var9;	// _18 = BinOp(_6 SUB _9)
	var17 = var5 >> var18;	// _17 = BinOp(_5 BIT_SHR _18)
	var46 = var5 & 0xffffffff;	// _46 = BinOp(_5 BIT_AND 0xffffffff u32)
	var20 = var3 + var9;	// _20 = BinOp(_3 ADD _9)
	var47 = var20 - var6;	// _47 = BinOp(_20 SUB _6)
	var45 = var47 & 0x1f;	// _45 = BinOp(_47 BIT_AND 0x1f u32)
	var21 = var46 << var45;
	// ^ Call( _21 = "unchecked_shl"::<u32,>( _46, _45, ), bb16, bb5)
	var19 = var21 != 0x0;	// _19 = BinOp(_21 NE 0x0 u32)
	var22 = (uint32_t )var19;	// _22 = Cast(_19 as u32)
	var16 = var17 | var22;	// _16 = BinOp(_17 BIT_OR _22)
	// ^ Goto(17)
bb17:
	var5 = var16;	// _5 = Use(_16)
	var24 = var16 & 0x4;	// _24 = BinOp(_16 BIT_AND 0x4 u32)
	var23 = var24 != 0x0;	// _23 = BinOp(_24 NE 0x0 u32)
	var25 = (uint32_t )var23;	// _25 = Cast(_23 as u32)
	var5 = var5 | var25;	// _5 = BinOp(_5 BIT_OR _25)
	var5 = var5 + 0x1;	// _5 = BinOp(_5 ADD 0x1 u32)
	var5 = var5 >> 2;	// _5 = BinOp(_5 BIT_SHR +2 i32)
	var27 = 0x1 << var1;	// _27 = BinOp(0x1 u32 BIT_SHL _1)
	var26 = var5 & var27;	// _26 = BinOp(_5 BIT_AND _27)
	var10 = var26 != 0x0;	// _10 = BinOp(_26 NE 0x0 u32)
	if(var10) goto bb18; else goto bb19;
	// ^ If( _10 : 18, 19)
bb18:
	var5 = var5 >> 1;	// _5 = BinOp(_5 BIT_SHR +1 i32)
	var7 = var7 + 0x1;	// _7 = BinOp(_7 ADD 0x1 u32)
	// ^ Goto(19)
bb19:
	var15 = var5;	// _15 = Use(_5)
	goto bb10;
	// ^ Goto(10)
}
// ::"compiler_builtins-0_0_0_Hb"::float::conv::__floattidf
double  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv11__floattidf0g(
		int128_t arg0 // i128
		) // -> f64

{
	double rv;
	int128_t var0;	// i128
	uint32_t var1;	// u32
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	RUST_BOOL var4;	// bool
	uint128_t var5;	// u128
	uint32_t var6;	// u32
	uint32_t var7;	// u32
	uint32_t var8;	// u32
	uint32_t var9;	// u32
	RUST_BOOL var10;	// bool
	TUP_2_ZRTCw_ZRTCi var11;	// (bool, u128, )
	uint32_t var12;	// u32
	uint32_t var13;	// u32
	uint64_t var14;	// u64
	uint32_t var15;	// u32
	uint32_t var16;	// u32
	uint128_t var17;	// u128
	uint128_t var18;	// u128
	uint128_t var19;	// u128
	uint32_t var20;	// u32
	RUST_BOOL var21;	// bool
	uint128_t var22;	// u128
	uint32_t var23;	// u32
	uint128_t var24;	// u128
	uint128_t var25;	// u128
	RUST_BOOL var26;	// bool
	uint128_t var27;	// u128
	uint128_t var28;	// u128
	uint128_t var29;	// u128
	uint128_t var30;	// u128
	uint32_t var31;	// u32
	uint128_t var32;	// u128
	uint64_t var33;	// u64
	uint64_t var34;	// u64
	uint64_t var35;	// u64
	uint64_t var36;	// u64
	uint64_t var37;	// u64
	uint64_t var38;	// u64
	uint64_t var39;	// u64
	uint64_t var40;	// u64
	uint32_t var41;	// u32
	uint128_t var42;	// u128
	uint32_t var43;	// u32
	uint64_t var44;	// u64
	uint64_t var45;	// u64
	uint64_t var46;	// u64
	uint64_t var47;	// u64
	uint64_t var48;	// u64
	uint64_t var49;	// u64
	uint64_t var50;	// u64
	uint64_t var51;	// u64
	uint128_t var52;	// u128
	uint32_t var53;	// u32
	uint128_t var54;	// u128
	uint128_t var55;	// u128
	uint32_t var56;	// u32
	uint64_t var57;	// u64
	uint64_t var58;	// u64
	var0 = arg0;	// _0 = Use(a0)
	var10 = 0 == cmp128s(make128s_raw(0ull, 0ull), arg0);	// _10 = BinOp(a0 EQ +0 i128)
	if(var10) goto bb1; else goto bb2;
	// ^ If( _10 : 1, 2)
bb1:
	rv = 0.000000000000000000e+00;	// retval = Constant(0x0p+0 f64)
	return rv;
	// ^ Return
bb2:
	var1 = 0x35;	// _1 = Constant(0x35 u32)
	var2 = 0x3ff;	// _2 = Constant(0x3ff u32)
	var3 = 0x80;	// _3 = Constant(0x80 u32)
	var11 = ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g12extract_sign0g( var0 );
	// ^ Call( _11 = <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::extract_sign( _0, ), bb3, bb5)
	var5 = var11._1;	// _5 = Use(_11.1)
	var4 = var11._0;	// _4 = Use(_11.0)
	var32 = (intrinsic_ctlz_u128(var5));	// ^ Call( _32 = "ctlz"::<u128,>( _5, ), bb4, bb5)
	var12 = var32.lo;	// _12 = Cast(_32 as u32)
	var6 = var3 - var12;	// _6 = BinOp(_3 SUB _12)
	var7 = var6 - 0x1;	// _7 = BinOp(_6 SUB 0x1 u32)
	var10 = 0x80 < var1;	// _10 = BinOp(0x80 u32 LT _1)
	if(var10) goto bb6; else goto bb7;
	// ^ If( _10 : 6, 7)
bb5: _Unwind_Resume(); // Diverge
bb6:
	var13 = var7 + var2;	// _13 = BinOp(_7 ADD _2)
	var39 = (uint64_t )var13;	// _39 = Cast(_13 as u64)
	var14 = var5.lo;	// _14 = Cast(_5 as u64)
	var16 = var1 - var7;	// _16 = BinOp(_1 SUB _7)
	var15 = var16 - 0x1;	// _15 = BinOp(_16 SUB 0x1 u32)
	var40 = var14 << var15;	// _40 = BinOp(_14 BIT_SHL _15)
	var35 = (uint64_t )var4;	// _35 = Cast(_4 as u64)
	var34 = var35 << 0x3f;	// _34 = BinOp(_35 BIT_SHL 0x3f u32)
	var37 = var39 << 0x34;	// _37 = BinOp(_39 BIT_SHL 0x34 u32)
	var36 = var37 & 0x7ff0000000000000ull;	// _36 = BinOp(_37 BIT_AND 0x7ff0000000000000 u64)
	var33 = var34 | var36;	// _33 = BinOp(_34 BIT_OR _36)
	var38 = var40 & 0xfffffffffffffull;	// _38 = BinOp(_40 BIT_AND 0xfffffffffffff u64)
	var57 = var33 | var38;	// _57 = BinOp(_33 BIT_OR _38)
	memcpy( &rv, &var57, sizeof(uint64_t ));
	goto bb11;
	// ^ Call( retval = "transmute"::<u64,f64,>( _57, ), bb11, bb5)
bb7:
	var10 = var6 > var1;	// _10 = BinOp(_6 GT _1)
	if(var10) goto bb8; else goto bb9;
	// ^ If( _10 : 8, 9)
bb8:
	var8 = var1 + 0x1;	// _8 = BinOp(_1 ADD 0x1 u32)
	var9 = var1 + 0x2;	// _9 = BinOp(_1 ADD 0x2 u32)
	var10 = var6 == var8;	// _10 = BinOp(_6 EQ _8)
	if(var10) goto bb12; else goto bb13;
	// ^ If( _10 : 12, 13)
bb9:
	var43 = var1 - var6;	// _43 = BinOp(_1 SUB _6)
	var41 = var43 & 0x7f;	// _41 = BinOp(_43 BIT_AND 0x7f u32)
	var42.lo = var41; var42.hi = var41 < 0 ? -1 : 0;	// _42 = Cast(_41 as u128)
	var17 = shl128(var5, var42.lo);
	// ^ Call( _17 = "unchecked_shl"::<u128,>( _5, _42, ), bb10, bb5)
bb10:
	var5 = var17;	// _5 = Use(_17)
	var31 = var7 + var2;	// _31 = BinOp(_7 ADD _2)
	var50 = (uint64_t )var31;	// _50 = Cast(_31 as u64)
	var51 = var17.lo;	// _51 = Cast(_17 as u64)
	var46 = (uint64_t )var4;	// _46 = Cast(_4 as u64)
	var45 = var46 << 0x3f;	// _45 = BinOp(_46 BIT_SHL 0x3f u32)
	var48 = var50 << 0x34;	// _48 = BinOp(_50 BIT_SHL 0x34 u32)
	var47 = var48 & 0x7ff0000000000000ull;	// _47 = BinOp(_48 BIT_AND 0x7ff0000000000000 u64)
	var44 = var45 | var47;	// _44 = BinOp(_45 BIT_OR _47)
	var49 = var51 & 0xfffffffffffffull;	// _49 = BinOp(_51 BIT_AND 0xfffffffffffff u64)
	var58 = var44 | var49;	// _58 = BinOp(_44 BIT_OR _49)
	memcpy( &rv, &var58, sizeof(uint64_t ));
	// ^ Call( retval = "transmute"::<u64,f64,>( _58, ), bb11, bb5)
bb11:
	return rv;
	// ^ Return
bb12:
	var18 = shl128(var5, 1);	// _18 = BinOp(_5 BIT_SHL +1 i32)
	goto bb17;
	// ^ Goto(17)
bb13:
	var10 = var6 == var9;	// _10 = BinOp(_6 EQ _9)
	if(var10) goto bb14; else goto bb15;
	// ^ If( _10 : 14, 15)
bb14:
	var18 = var5;	// _18 = Use(_5)
	goto bb17;
	// ^ Goto(17)
bb15:
	var20 = var6 - var9;	// _20 = BinOp(_6 SUB _9)
	var19 = shr128(var5, var20);	// _19 = BinOp(_5 BIT_SHR _20)
	var52 = make128_raw(0ull, 0ull);	// _52 = Constant(0x0 u128)
	var22.lo = ~var52.lo; var22.hi = ~var52.hi;	// _22 = UniOp(_52 INV)
	var55 = and128(var5, var22);	// _55 = BinOp(_5 BIT_AND _22)
	var23 = var3 + var9;	// _23 = BinOp(_3 ADD _9)
	var56 = var23 - var6;	// _56 = BinOp(_23 SUB _6)
	var53 = var56 & 0x7f;	// _53 = BinOp(_56 BIT_AND 0x7f u32)
	var54.lo = var53; var54.hi = var53 < 0 ? -1 : 0;	// _54 = Cast(_53 as u128)
	var24 = shl128(var55, var54.lo);
	// ^ Call( _24 = "unchecked_shl"::<u128,>( _55, _54, ), bb16, bb5)
	var21 = 0 != cmp128(make128_raw(0ull, 0ull), var24);	// _21 = BinOp(_24 NE 0x0 u128)
	var25.lo = var21; var25.hi = var21 < 0 ? -1 : 0;	// _25 = Cast(_21 as u128)
	var18 = or128(var19, var25);	// _18 = BinOp(_19 BIT_OR _25)
	// ^ Goto(17)
bb17:
	var5 = var18;	// _5 = Use(_18)
	var27 = and128(var18, make128_raw(0ull, 4ull));	// _27 = BinOp(_18 BIT_AND 0x4 u128)
	var26 = 0 != cmp128(make128_raw(0ull, 0ull), var27);	// _26 = BinOp(_27 NE 0x0 u128)
	var28.lo = var26; var28.hi = var26 < 0 ? -1 : 0;	// _28 = Cast(_26 as u128)
	var5 = or128(var5, var28);	// _5 = BinOp(_5 BIT_OR _28)
	var5 = add128(var5, make128_raw(0ull, 1ull));	// _5 = BinOp(_5 ADD 0x1 u128)
	var5 = shr128(var5, 2);	// _5 = BinOp(_5 BIT_SHR +2 i32)
	var30 = shl128(make128_raw(0ull, 1ull), var1);	// _30 = BinOp(0x1 u128 BIT_SHL _1)
	var29 = and128(var5, var30);	// _29 = BinOp(_5 BIT_AND _30)
	var10 = 0 != cmp128(make128_raw(0ull, 0ull), var29);	// _10 = BinOp(_29 NE 0x0 u128)
	if(var10) goto bb18; else goto bb19;
	// ^ If( _10 : 18, 19)
bb18:
	var5 = shr128(var5, 1);	// _5 = BinOp(_5 BIT_SHR +1 i32)
	var7 = var7 + 0x1;	// _7 = BinOp(_7 ADD 0x1 u32)
	// ^ Goto(19)
bb19:
	var17 = var5;	// _17 = Use(_5)
	goto bb10;
	// ^ Goto(10)
}
// ::"compiler_builtins-0_0_0_Hb"::float::conv::__floattisf
float  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv11__floattisf0g(
		int128_t arg0 // i128
		) // -> f32

{
	float rv;
	int128_t var0;	// i128
	uint32_t var1;	// u32
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	RUST_BOOL var4;	// bool
	uint128_t var5;	// u128
	uint32_t var6;	// u32
	uint32_t var7;	// u32
	uint32_t var8;	// u32
	uint32_t var9;	// u32
	RUST_BOOL var10;	// bool
	TUP_2_ZRTCw_ZRTCi var11;	// (bool, u128, )
	uint32_t var12;	// u32
	uint32_t var13;	// u32
	uint32_t var14;	// u32
	uint32_t var15;	// u32
	uint128_t var16;	// u128
	uint128_t var17;	// u128
	uint128_t var18;	// u128
	uint32_t var19;	// u32
	RUST_BOOL var20;	// bool
	uint128_t var21;	// u128
	uint32_t var22;	// u32
	uint128_t var23;	// u128
	uint128_t var24;	// u128
	RUST_BOOL var25;	// bool
	uint128_t var26;	// u128
	uint128_t var27;	// u128
	uint128_t var28;	// u128
	uint128_t var29;	// u128
	uint128_t var30;	// u128
	uint32_t var31;	// u32
	uint32_t var32;	// u32
	uint32_t var33;	// u32
	uint32_t var34;	// u32
	uint32_t var35;	// u32
	uint32_t var36;	// u32
	uint32_t var37;	// u32
	uint32_t var38;	// u32
	uint32_t var39;	// u32
	uint128_t var40;	// u128
	uint32_t var41;	// u32
	uint32_t var42;	// u32
	uint32_t var43;	// u32
	uint32_t var44;	// u32
	uint32_t var45;	// u32
	uint32_t var46;	// u32
	uint32_t var47;	// u32
	uint32_t var48;	// u32
	uint32_t var49;	// u32
	uint128_t var50;	// u128
	uint32_t var51;	// u32
	uint128_t var52;	// u128
	uint128_t var53;	// u128
	uint32_t var54;	// u32
	uint32_t var55;	// u32
	uint32_t var56;	// u32
	var0 = arg0;	// _0 = Use(a0)
	var10 = 0 == cmp128s(make128s_raw(0ull, 0ull), arg0);	// _10 = BinOp(a0 EQ +0 i128)
	if(var10) goto bb1; else goto bb2;
	// ^ If( _10 : 1, 2)
bb1:
	rv = 0.0000000000e+00f;	// retval = Constant(0x0p+0 f32)
	return rv;
	// ^ Return
bb2:
	var1 = 0x18;	// _1 = Constant(0x18 u32)
	var2 = 0x7f;	// _2 = Constant(0x7f u32)
	var3 = 0x80;	// _3 = Constant(0x80 u32)
	var11 = ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g12extract_sign0g( var0 );
	// ^ Call( _11 = <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::extract_sign( _0, ), bb3, bb5)
	var5 = var11._1;	// _5 = Use(_11.1)
	var4 = var11._0;	// _4 = Use(_11.0)
	var30 = (intrinsic_ctlz_u128(var5));	// ^ Call( _30 = "ctlz"::<u128,>( _5, ), bb4, bb5)
	var12 = var30.lo;	// _12 = Cast(_30 as u32)
	var6 = var3 - var12;	// _6 = BinOp(_3 SUB _12)
	var7 = var6 - 0x1;	// _7 = BinOp(_6 SUB 0x1 u32)
	var10 = 0x80 < var1;	// _10 = BinOp(0x80 u32 LT _1)
	if(var10) goto bb6; else goto bb7;
	// ^ If( _10 : 6, 7)
bb5: _Unwind_Resume(); // Diverge
bb6:
	var37 = var7 + var2;	// _37 = BinOp(_7 ADD _2)
	var13 = var5.lo;	// _13 = Cast(_5 as u32)
	var15 = var1 - var7;	// _15 = BinOp(_1 SUB _7)
	var14 = var15 - 0x1;	// _14 = BinOp(_15 SUB 0x1 u32)
	var38 = var13 << var14;	// _38 = BinOp(_13 BIT_SHL _14)
	var33 = (uint32_t )var4;	// _33 = Cast(_4 as u32)
	var32 = var33 << 0x1f;	// _32 = BinOp(_33 BIT_SHL 0x1f u32)
	var35 = var37 << 0x17;	// _35 = BinOp(_37 BIT_SHL 0x17 u32)
	var34 = var35 & 0x7f800000;	// _34 = BinOp(_35 BIT_AND 0x7f800000 u32)
	var31 = var32 | var34;	// _31 = BinOp(_32 BIT_OR _34)
	var36 = var38 & 0x7fffff;	// _36 = BinOp(_38 BIT_AND 0x7fffff u32)
	var55 = var31 | var36;	// _55 = BinOp(_31 BIT_OR _36)
	memcpy( &rv, &var55, sizeof(uint32_t ));
	goto bb11;
	// ^ Call( retval = "transmute"::<u32,f32,>( _55, ), bb11, bb5)
bb7:
	var10 = var6 > var1;	// _10 = BinOp(_6 GT _1)
	if(var10) goto bb8; else goto bb9;
	// ^ If( _10 : 8, 9)
bb8:
	var8 = var1 + 0x1;	// _8 = BinOp(_1 ADD 0x1 u32)
	var9 = var1 + 0x2;	// _9 = BinOp(_1 ADD 0x2 u32)
	var10 = var6 == var8;	// _10 = BinOp(_6 EQ _8)
	if(var10) goto bb12; else goto bb13;
	// ^ If( _10 : 12, 13)
bb9:
	var41 = var1 - var6;	// _41 = BinOp(_1 SUB _6)
	var39 = var41 & 0x7f;	// _39 = BinOp(_41 BIT_AND 0x7f u32)
	var40.lo = var39; var40.hi = var39 < 0 ? -1 : 0;	// _40 = Cast(_39 as u128)
	var16 = shl128(var5, var40.lo);
	// ^ Call( _16 = "unchecked_shl"::<u128,>( _5, _40, ), bb10, bb5)
bb10:
	var5 = var16;	// _5 = Use(_16)
	var48 = var7 + var2;	// _48 = BinOp(_7 ADD _2)
	var49 = var16.lo;	// _49 = Cast(_16 as u32)
	var44 = (uint32_t )var4;	// _44 = Cast(_4 as u32)
	var43 = var44 << 0x1f;	// _43 = BinOp(_44 BIT_SHL 0x1f u32)
	var46 = var48 << 0x17;	// _46 = BinOp(_48 BIT_SHL 0x17 u32)
	var45 = var46 & 0x7f800000;	// _45 = BinOp(_46 BIT_AND 0x7f800000 u32)
	var42 = var43 | var45;	// _42 = BinOp(_43 BIT_OR _45)
	var47 = var49 & 0x7fffff;	// _47 = BinOp(_49 BIT_AND 0x7fffff u32)
	var56 = var42 | var47;	// _56 = BinOp(_42 BIT_OR _47)
	memcpy( &rv, &var56, sizeof(uint32_t ));
	// ^ Call( retval = "transmute"::<u32,f32,>( _56, ), bb11, bb5)
bb11:
	return rv;
	// ^ Return
bb12:
	var17 = shl128(var5, 1);	// _17 = BinOp(_5 BIT_SHL +1 i32)
	goto bb17;
	// ^ Goto(17)
bb13:
	var10 = var6 == var9;	// _10 = BinOp(_6 EQ _9)
	if(var10) goto bb14; else goto bb15;
	// ^ If( _10 : 14, 15)
bb14:
	var17 = var5;	// _17 = Use(_5)
	goto bb17;
	// ^ Goto(17)
bb15:
	var19 = var6 - var9;	// _19 = BinOp(_6 SUB _9)
	var18 = shr128(var5, var19);	// _18 = BinOp(_5 BIT_SHR _19)
	var50 = make128_raw(0ull, 0ull);	// _50 = Constant(0x0 u128)
	var21.lo = ~var50.lo; var21.hi = ~var50.hi;	// _21 = UniOp(_50 INV)
	var53 = and128(var5, var21);	// _53 = BinOp(_5 BIT_AND _21)
	var22 = var3 + var9;	// _22 = BinOp(_3 ADD _9)
	var54 = var22 - var6;	// _54 = BinOp(_22 SUB _6)
	var51 = var54 & 0x7f;	// _51 = BinOp(_54 BIT_AND 0x7f u32)
	var52.lo = var51; var52.hi = var51 < 0 ? -1 : 0;	// _52 = Cast(_51 as u128)
	var23 = shl128(var53, var52.lo);
	// ^ Call( _23 = "unchecked_shl"::<u128,>( _53, _52, ), bb16, bb5)
	var20 = 0 != cmp128(make128_raw(0ull, 0ull), var23);	// _20 = BinOp(_23 NE 0x0 u128)
	var24.lo = var20; var24.hi = var20 < 0 ? -1 : 0;	// _24 = Cast(_20 as u128)
	var17 = or128(var18, var24);	// _17 = BinOp(_18 BIT_OR _24)
	// ^ Goto(17)
bb17:
	var5 = var17;	// _5 = Use(_17)
	var26 = and128(var17, make128_raw(0ull, 4ull));	// _26 = BinOp(_17 BIT_AND 0x4 u128)
	var25 = 0 != cmp128(make128_raw(0ull, 0ull), var26);	// _25 = BinOp(_26 NE 0x0 u128)
	var27.lo = var25; var27.hi = var25 < 0 ? -1 : 0;	// _27 = Cast(_25 as u128)
	var5 = or128(var5, var27);	// _5 = BinOp(_5 BIT_OR _27)
	var5 = add128(var5, make128_raw(0ull, 1ull));	// _5 = BinOp(_5 ADD 0x1 u128)
	var5 = shr128(var5, 2);	// _5 = BinOp(_5 BIT_SHR +2 i32)
	var29 = shl128(make128_raw(0ull, 1ull), var1);	// _29 = BinOp(0x1 u128 BIT_SHL _1)
	var28 = and128(var5, var29);	// _28 = BinOp(_5 BIT_AND _29)
	var10 = 0 != cmp128(make128_raw(0ull, 0ull), var28);	// _10 = BinOp(_28 NE 0x0 u128)
	if(var10) goto bb18; else goto bb19;
	// ^ If( _10 : 18, 19)
bb18:
	var5 = shr128(var5, 1);	// _5 = BinOp(_5 BIT_SHR +1 i32)
	var7 = var7 + 0x1;	// _7 = BinOp(_7 ADD 0x1 u32)
	// ^ Goto(19)
bb19:
	var16 = var5;	// _16 = Use(_5)
	goto bb10;
	// ^ Goto(10)
}
// ::"compiler_builtins-0_0_0_Hb"::float::conv::__floatundidf
double  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv13__floatundidf0g(
		uint64_t arg0 // u64
		) // -> f64

{
	double rv;
	uint64_t var0;	// u64
	uint32_t var1;	// u32
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	RUST_BOOL var4;	// bool
	uint64_t var5;	// u64
	uint32_t var6;	// u32
	uint32_t var7;	// u32
	uint32_t var8;	// u32
	uint32_t var9;	// u32
	RUST_BOOL var10;	// bool
	uint32_t var11;	// u32
	uint32_t var12;	// u32
	uint32_t var13;	// u32
	uint32_t var14;	// u32
	uint64_t var15;	// u64
	uint64_t var16;	// u64
	uint64_t var17;	// u64
	uint32_t var18;	// u32
	RUST_BOOL var19;	// bool
	uint32_t var20;	// u32
	uint64_t var21;	// u64
	uint64_t var22;	// u64
	RUST_BOOL var23;	// bool
	uint64_t var24;	// u64
	uint64_t var25;	// u64
	uint64_t var26;	// u64
	uint64_t var27;	// u64
	uint32_t var28;	// u32
	uint64_t var29;	// u64
	uint64_t var30;	// u64
	uint64_t var31;	// u64
	uint64_t var32;	// u64
	uint64_t var33;	// u64
	uint64_t var34;	// u64
	uint64_t var35;	// u64
	uint64_t var36;	// u64
	uint64_t var37;	// u64
	uint32_t var38;	// u32
	uint64_t var39;	// u64
	uint32_t var40;	// u32
	uint64_t var41;	// u64
	uint64_t var42;	// u64
	uint64_t var43;	// u64
	uint64_t var44;	// u64
	uint64_t var45;	// u64
	uint64_t var46;	// u64
	uint64_t var47;	// u64
	uint32_t var48;	// u32
	uint64_t var49;	// u64
	uint64_t var50;	// u64
	uint32_t var51;	// u32
	uint64_t var52;	// u64
	uint64_t var53;	// u64
	var0 = arg0;	// _0 = Use(a0)
	var10 = arg0 == 0x0ull;	// _10 = BinOp(a0 EQ 0x0 u64)
	if(var10) goto bb1; else goto bb2;
	// ^ If( _10 : 1, 2)
bb1:
	rv = 0.000000000000000000e+00;	// retval = Constant(0x0p+0 f64)
	return rv;
	// ^ Return
bb2:
	var1 = 0x35;	// _1 = Constant(0x35 u32)
	var2 = 0x3ff;	// _2 = Constant(0x3ff u32)
	var3 = 0x40;	// _3 = Constant(0x40 u32)
	var5 = var0;	// _5 = Use(_0)
	var4 = false;	// _4 = Constant(false)
	var29 = (var0 != 0 ? __builtin_clz64(var0) : sizeof(uint64_t )*8);
	// ^ Call( _29 = "ctlz"::<u64,>( _0, ), bb3, bb4)
	var11 = (uint32_t )var29;	// _11 = Cast(_29 as u32)
	var6 = var3 - var11;	// _6 = BinOp(_3 SUB _11)
	var7 = var6 - 0x1;	// _7 = BinOp(_6 SUB 0x1 u32)
	var10 = 0x40 < var1;	// _10 = BinOp(0x40 u32 LT _1)
	if(var10) goto bb5; else goto bb6;
	// ^ If( _10 : 5, 6)
bb4: _Unwind_Resume(); // Diverge
bb5:
	var12 = var7 + var2;	// _12 = BinOp(_7 ADD _2)
	var36 = (uint64_t )var12;	// _36 = Cast(_12 as u64)
	var14 = var1 - var7;	// _14 = BinOp(_1 SUB _7)
	var13 = var14 - 0x1;	// _13 = BinOp(_14 SUB 0x1 u32)
	var37 = var5 << var13;	// _37 = BinOp(_5 BIT_SHL _13)
	var32 = (uint64_t )var4;	// _32 = Cast(_4 as u64)
	var31 = var32 << 0x3f;	// _31 = BinOp(_32 BIT_SHL 0x3f u32)
	var34 = var36 << 0x34;	// _34 = BinOp(_36 BIT_SHL 0x34 u32)
	var33 = var34 & 0x7ff0000000000000ull;	// _33 = BinOp(_34 BIT_AND 0x7ff0000000000000 u64)
	var30 = var31 | var33;	// _30 = BinOp(_31 BIT_OR _33)
	var35 = var37 & 0xfffffffffffffull;	// _35 = BinOp(_37 BIT_AND 0xfffffffffffff u64)
	var52 = var30 | var35;	// _52 = BinOp(_30 BIT_OR _35)
	memcpy( &rv, &var52, sizeof(uint64_t ));
	goto bb10;
	// ^ Call( retval = "transmute"::<u64,f64,>( _52, ), bb10, bb4)
bb6:
	var10 = var6 > var1;	// _10 = BinOp(_6 GT _1)
	if(var10) goto bb7; else goto bb8;
	// ^ If( _10 : 7, 8)
bb7:
	var8 = var1 + 0x1;	// _8 = BinOp(_1 ADD 0x1 u32)
	var9 = var1 + 0x2;	// _9 = BinOp(_1 ADD 0x2 u32)
	var10 = var6 == var8;	// _10 = BinOp(_6 EQ _8)
	if(var10) goto bb11; else goto bb12;
	// ^ If( _10 : 11, 12)
bb8:
	var40 = var1 - var6;	// _40 = BinOp(_1 SUB _6)
	var38 = var40 & 0x3f;	// _38 = BinOp(_40 BIT_AND 0x3f u32)
	var39 = (uint64_t )var38;	// _39 = Cast(_38 as u64)
	var15 = var5 << var39;
	// ^ Call( _15 = "unchecked_shl"::<u64,>( _5, _39, ), bb9, bb4)
bb9:
	var5 = var15;	// _5 = Use(_15)
	var28 = var7 + var2;	// _28 = BinOp(_7 ADD _2)
	var47 = (uint64_t )var28;	// _47 = Cast(_28 as u64)
	var43 = (uint64_t )var4;	// _43 = Cast(_4 as u64)
	var42 = var43 << 0x3f;	// _42 = BinOp(_43 BIT_SHL 0x3f u32)
	var45 = var47 << 0x34;	// _45 = BinOp(_47 BIT_SHL 0x34 u32)
	var44 = var45 & 0x7ff0000000000000ull;	// _44 = BinOp(_45 BIT_AND 0x7ff0000000000000 u64)
	var41 = var42 | var44;	// _41 = BinOp(_42 BIT_OR _44)
	var46 = var15 & 0xfffffffffffffull;	// _46 = BinOp(_15 BIT_AND 0xfffffffffffff u64)
	var53 = var41 | var46;	// _53 = BinOp(_41 BIT_OR _46)
	memcpy( &rv, &var53, sizeof(uint64_t ));
	// ^ Call( retval = "transmute"::<u64,f64,>( _53, ), bb10, bb4)
bb10:
	return rv;
	// ^ Return
bb11:
	var16 = var5 << 1;	// _16 = BinOp(_5 BIT_SHL +1 i32)
	goto bb16;
	// ^ Goto(16)
bb12:
	var10 = var6 == var9;	// _10 = BinOp(_6 EQ _9)
	if(var10) goto bb13; else goto bb14;
	// ^ If( _10 : 13, 14)
bb13:
	var16 = var5;	// _16 = Use(_5)
	goto bb16;
	// ^ Goto(16)
bb14:
	var18 = var6 - var9;	// _18 = BinOp(_6 SUB _9)
	var17 = var5 >> var18;	// _17 = BinOp(_5 BIT_SHR _18)
	var50 = var5 & 0xffffffffffffffffull;	// _50 = BinOp(_5 BIT_AND 0xffffffffffffffff u64)
	var20 = var3 + var9;	// _20 = BinOp(_3 ADD _9)
	var51 = var20 - var6;	// _51 = BinOp(_20 SUB _6)
	var48 = var51 & 0x3f;	// _48 = BinOp(_51 BIT_AND 0x3f u32)
	var49 = (uint64_t )var48;	// _49 = Cast(_48 as u64)
	var21 = var50 << var49;
	// ^ Call( _21 = "unchecked_shl"::<u64,>( _50, _49, ), bb15, bb4)
	var19 = var21 != 0x0ull;	// _19 = BinOp(_21 NE 0x0 u64)
	var22 = (uint64_t )var19;	// _22 = Cast(_19 as u64)
	var16 = var17 | var22;	// _16 = BinOp(_17 BIT_OR _22)
	// ^ Goto(16)
bb16:
	var5 = var16;	// _5 = Use(_16)
	var24 = var16 & 0x4ull;	// _24 = BinOp(_16 BIT_AND 0x4 u64)
	var23 = var24 != 0x0ull;	// _23 = BinOp(_24 NE 0x0 u64)
	var25 = (uint64_t )var23;	// _25 = Cast(_23 as u64)
	var5 = var5 | var25;	// _5 = BinOp(_5 BIT_OR _25)
	var5 = var5 + 0x1ull;	// _5 = BinOp(_5 ADD 0x1 u64)
	var5 = var5 >> 2;	// _5 = BinOp(_5 BIT_SHR +2 i32)
	var27 = 0x1ull << var1;	// _27 = BinOp(0x1 u64 BIT_SHL _1)
	var26 = var5 & var27;	// _26 = BinOp(_5 BIT_AND _27)
	var10 = var26 != 0x0ull;	// _10 = BinOp(_26 NE 0x0 u64)
	if(var10) goto bb17; else goto bb18;
	// ^ If( _10 : 17, 18)
bb17:
	var5 = var5 >> 1;	// _5 = BinOp(_5 BIT_SHR +1 i32)
	var7 = var7 + 0x1;	// _7 = BinOp(_7 ADD 0x1 u32)
	// ^ Goto(18)
bb18:
	var15 = var5;	// _15 = Use(_5)
	goto bb9;
	// ^ Goto(9)
}
// ::"compiler_builtins-0_0_0_Hb"::float::conv::__floatundisf
float  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv13__floatundisf0g(
		uint64_t arg0 // u64
		) // -> f32

{
	float rv;
	uint64_t var0;	// u64
	uint32_t var1;	// u32
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	RUST_BOOL var4;	// bool
	uint64_t var5;	// u64
	uint32_t var6;	// u32
	uint32_t var7;	// u32
	uint32_t var8;	// u32
	uint32_t var9;	// u32
	RUST_BOOL var10;	// bool
	uint32_t var11;	// u32
	uint32_t var12;	// u32
	uint32_t var13;	// u32
	uint32_t var14;	// u32
	uint64_t var15;	// u64
	uint64_t var16;	// u64
	uint64_t var17;	// u64
	uint32_t var18;	// u32
	RUST_BOOL var19;	// bool
	uint32_t var20;	// u32
	uint64_t var21;	// u64
	uint64_t var22;	// u64
	RUST_BOOL var23;	// bool
	uint64_t var24;	// u64
	uint64_t var25;	// u64
	uint64_t var26;	// u64
	uint64_t var27;	// u64
	uint64_t var28;	// u64
	uint32_t var29;	// u32
	uint32_t var30;	// u32
	uint32_t var31;	// u32
	uint32_t var32;	// u32
	uint32_t var33;	// u32
	uint32_t var34;	// u32
	uint32_t var35;	// u32
	uint32_t var36;	// u32
	uint32_t var37;	// u32
	uint64_t var38;	// u64
	uint32_t var39;	// u32
	uint32_t var40;	// u32
	uint32_t var41;	// u32
	uint32_t var42;	// u32
	uint32_t var43;	// u32
	uint32_t var44;	// u32
	uint32_t var45;	// u32
	uint32_t var46;	// u32
	uint32_t var47;	// u32
	uint32_t var48;	// u32
	uint64_t var49;	// u64
	uint64_t var50;	// u64
	uint32_t var51;	// u32
	uint32_t var52;	// u32
	uint32_t var53;	// u32
	var0 = arg0;	// _0 = Use(a0)
	var10 = arg0 == 0x0ull;	// _10 = BinOp(a0 EQ 0x0 u64)
	if(var10) goto bb1; else goto bb2;
	// ^ If( _10 : 1, 2)
bb1:
	rv = 0.0000000000e+00f;	// retval = Constant(0x0p+0 f32)
	return rv;
	// ^ Return
bb2:
	var1 = 0x18;	// _1 = Constant(0x18 u32)
	var2 = 0x7f;	// _2 = Constant(0x7f u32)
	var3 = 0x40;	// _3 = Constant(0x40 u32)
	var5 = var0;	// _5 = Use(_0)
	var4 = false;	// _4 = Constant(false)
	var28 = (var0 != 0 ? __builtin_clz64(var0) : sizeof(uint64_t )*8);
	// ^ Call( _28 = "ctlz"::<u64,>( _0, ), bb3, bb4)
	var11 = (uint32_t )var28;	// _11 = Cast(_28 as u32)
	var6 = var3 - var11;	// _6 = BinOp(_3 SUB _11)
	var7 = var6 - 0x1;	// _7 = BinOp(_6 SUB 0x1 u32)
	var10 = 0x40 < var1;	// _10 = BinOp(0x40 u32 LT _1)
	if(var10) goto bb5; else goto bb6;
	// ^ If( _10 : 5, 6)
bb4: _Unwind_Resume(); // Diverge
bb5:
	var35 = var7 + var2;	// _35 = BinOp(_7 ADD _2)
	var12 = (uint32_t )var5;	// _12 = Cast(_5 as u32)
	var14 = var1 - var7;	// _14 = BinOp(_1 SUB _7)
	var13 = var14 - 0x1;	// _13 = BinOp(_14 SUB 0x1 u32)
	var36 = var12 << var13;	// _36 = BinOp(_12 BIT_SHL _13)
	var31 = (uint32_t )var4;	// _31 = Cast(_4 as u32)
	var30 = var31 << 0x1f;	// _30 = BinOp(_31 BIT_SHL 0x1f u32)
	var33 = var35 << 0x17;	// _33 = BinOp(_35 BIT_SHL 0x17 u32)
	var32 = var33 & 0x7f800000;	// _32 = BinOp(_33 BIT_AND 0x7f800000 u32)
	var29 = var30 | var32;	// _29 = BinOp(_30 BIT_OR _32)
	var34 = var36 & 0x7fffff;	// _34 = BinOp(_36 BIT_AND 0x7fffff u32)
	var52 = var29 | var34;	// _52 = BinOp(_29 BIT_OR _34)
	memcpy( &rv, &var52, sizeof(uint32_t ));
	goto bb10;
	// ^ Call( retval = "transmute"::<u32,f32,>( _52, ), bb10, bb4)
bb6:
	var10 = var6 > var1;	// _10 = BinOp(_6 GT _1)
	if(var10) goto bb7; else goto bb8;
	// ^ If( _10 : 7, 8)
bb7:
	var8 = var1 + 0x1;	// _8 = BinOp(_1 ADD 0x1 u32)
	var9 = var1 + 0x2;	// _9 = BinOp(_1 ADD 0x2 u32)
	var10 = var6 == var8;	// _10 = BinOp(_6 EQ _8)
	if(var10) goto bb11; else goto bb12;
	// ^ If( _10 : 11, 12)
bb8:
	var39 = var1 - var6;	// _39 = BinOp(_1 SUB _6)
	var37 = var39 & 0x3f;	// _37 = BinOp(_39 BIT_AND 0x3f u32)
	var38 = (uint64_t )var37;	// _38 = Cast(_37 as u64)
	var15 = var5 << var38;
	// ^ Call( _15 = "unchecked_shl"::<u64,>( _5, _38, ), bb9, bb4)
bb9:
	var5 = var15;	// _5 = Use(_15)
	var46 = var7 + var2;	// _46 = BinOp(_7 ADD _2)
	var47 = (uint32_t )var15;	// _47 = Cast(_15 as u32)
	var42 = (uint32_t )var4;	// _42 = Cast(_4 as u32)
	var41 = var42 << 0x1f;	// _41 = BinOp(_42 BIT_SHL 0x1f u32)
	var44 = var46 << 0x17;	// _44 = BinOp(_46 BIT_SHL 0x17 u32)
	var43 = var44 & 0x7f800000;	// _43 = BinOp(_44 BIT_AND 0x7f800000 u32)
	var40 = var41 | var43;	// _40 = BinOp(_41 BIT_OR _43)
	var45 = var47 & 0x7fffff;	// _45 = BinOp(_47 BIT_AND 0x7fffff u32)
	var53 = var40 | var45;	// _53 = BinOp(_40 BIT_OR _45)
	memcpy( &rv, &var53, sizeof(uint32_t ));
	// ^ Call( retval = "transmute"::<u32,f32,>( _53, ), bb10, bb4)
bb10:
	return rv;
	// ^ Return
bb11:
	var16 = var5 << 1;	// _16 = BinOp(_5 BIT_SHL +1 i32)
	goto bb16;
	// ^ Goto(16)
bb12:
	var10 = var6 == var9;	// _10 = BinOp(_6 EQ _9)
	if(var10) goto bb13; else goto bb14;
	// ^ If( _10 : 13, 14)
bb13:
	var16 = var5;	// _16 = Use(_5)
	goto bb16;
	// ^ Goto(16)
bb14:
	var18 = var6 - var9;	// _18 = BinOp(_6 SUB _9)
	var17 = var5 >> var18;	// _17 = BinOp(_5 BIT_SHR _18)
	var50 = var5 & 0xffffffffffffffffull;	// _50 = BinOp(_5 BIT_AND 0xffffffffffffffff u64)
	var20 = var3 + var9;	// _20 = BinOp(_3 ADD _9)
	var51 = var20 - var6;	// _51 = BinOp(_20 SUB _6)
	var48 = var51 & 0x3f;	// _48 = BinOp(_51 BIT_AND 0x3f u32)
	var49 = (uint64_t )var48;	// _49 = Cast(_48 as u64)
	var21 = var50 << var49;
	// ^ Call( _21 = "unchecked_shl"::<u64,>( _50, _49, ), bb15, bb4)
	var19 = var21 != 0x0ull;	// _19 = BinOp(_21 NE 0x0 u64)
	var22 = (uint64_t )var19;	// _22 = Cast(_19 as u64)
	var16 = var17 | var22;	// _16 = BinOp(_17 BIT_OR _22)
	// ^ Goto(16)
bb16:
	var5 = var16;	// _5 = Use(_16)
	var24 = var16 & 0x4ull;	// _24 = BinOp(_16 BIT_AND 0x4 u64)
	var23 = var24 != 0x0ull;	// _23 = BinOp(_24 NE 0x0 u64)
	var25 = (uint64_t )var23;	// _25 = Cast(_23 as u64)
	var5 = var5 | var25;	// _5 = BinOp(_5 BIT_OR _25)
	var5 = var5 + 0x1ull;	// _5 = BinOp(_5 ADD 0x1 u64)
	var5 = var5 >> 2;	// _5 = BinOp(_5 BIT_SHR +2 i32)
	var27 = 0x1ull << var1;	// _27 = BinOp(0x1 u64 BIT_SHL _1)
	var26 = var5 & var27;	// _26 = BinOp(_5 BIT_AND _27)
	var10 = var26 != 0x0ull;	// _10 = BinOp(_26 NE 0x0 u64)
	if(var10) goto bb17; else goto bb18;
	// ^ If( _10 : 17, 18)
bb17:
	var5 = var5 >> 1;	// _5 = BinOp(_5 BIT_SHR +1 i32)
	var7 = var7 + 0x1;	// _7 = BinOp(_7 ADD 0x1 u32)
	// ^ Goto(18)
bb18:
	var15 = var5;	// _15 = Use(_5)
	goto bb9;
	// ^ Goto(9)
}
// ::"compiler_builtins-0_0_0_Hb"::float::conv::__floatunsidf
double  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv13__floatunsidf0g(
		uint32_t arg0 // u32
		) // -> f64

{
	double rv;
	uint32_t var0;	// u32
	uint32_t var1;	// u32
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	RUST_BOOL var4;	// bool
	uint32_t var5;	// u32
	uint32_t var6;	// u32
	uint32_t var7;	// u32
	uint32_t var8;	// u32
	uint32_t var9;	// u32
	RUST_BOOL var10;	// bool
	uint32_t var11;	// u32
	uint32_t var12;	// u32
	uint64_t var13;	// u64
	uint32_t var14;	// u32
	uint32_t var15;	// u32
	uint32_t var16;	// u32
	uint32_t var17;	// u32
	uint32_t var18;	// u32
	uint32_t var19;	// u32
	RUST_BOOL var20;	// bool
	uint32_t var21;	// u32
	uint32_t var22;	// u32
	uint32_t var23;	// u32
	RUST_BOOL var24;	// bool
	uint32_t var25;	// u32
	uint32_t var26;	// u32
	uint32_t var27;	// u32
	uint32_t var28;	// u32
	uint32_t var29;	// u32
	uint64_t var30;	// u64
	uint64_t var31;	// u64
	uint64_t var32;	// u64
	uint64_t var33;	// u64
	uint64_t var34;	// u64
	uint64_t var35;	// u64
	uint64_t var36;	// u64
	uint64_t var37;	// u64
	uint32_t var38;	// u32
	uint32_t var39;	// u32
	uint64_t var40;	// u64
	uint64_t var41;	// u64
	uint64_t var42;	// u64
	uint64_t var43;	// u64
	uint64_t var44;	// u64
	uint64_t var45;	// u64
	uint64_t var46;	// u64
	uint64_t var47;	// u64
	uint32_t var48;	// u32
	uint32_t var49;	// u32
	uint32_t var50;	// u32
	uint64_t var51;	// u64
	uint64_t var52;	// u64
	var0 = arg0;	// _0 = Use(a0)
	var10 = arg0 == 0x0;	// _10 = BinOp(a0 EQ 0x0 u32)
	if(var10) goto bb1; else goto bb2;
	// ^ If( _10 : 1, 2)
bb1:
	rv = 0.000000000000000000e+00;	// retval = Constant(0x0p+0 f64)
	return rv;
	// ^ Return
bb2:
	var1 = 0x35;	// _1 = Constant(0x35 u32)
	var2 = 0x3ff;	// _2 = Constant(0x3ff u32)
	var3 = 0x20;	// _3 = Constant(0x20 u32)
	var5 = var0;	// _5 = Use(_0)
	var4 = false;	// _4 = Constant(false)
	var11 = (var0 != 0 ? __builtin_clz(var0) : sizeof(uint32_t )*8);
	// ^ Call( _11 = "ctlz"::<u32,>( _0, ), bb3, bb4)
	var6 = var3 - var11;	// _6 = BinOp(_3 SUB _11)
	var7 = var6 - 0x1;	// _7 = BinOp(_6 SUB 0x1 u32)
	var10 = 0x20 < var1;	// _10 = BinOp(0x20 u32 LT _1)
	if(var10) goto bb5; else goto bb6;
	// ^ If( _10 : 5, 6)
bb4: _Unwind_Resume(); // Diverge
bb5:
	var12 = var7 + var2;	// _12 = BinOp(_7 ADD _2)
	var36 = (uint64_t )var12;	// _36 = Cast(_12 as u64)
	var13 = (uint64_t )var5;	// _13 = Cast(_5 as u64)
	var15 = var1 - var7;	// _15 = BinOp(_1 SUB _7)
	var14 = var15 - 0x1;	// _14 = BinOp(_15 SUB 0x1 u32)
	var37 = var13 << var14;	// _37 = BinOp(_13 BIT_SHL _14)
	var32 = (uint64_t )var4;	// _32 = Cast(_4 as u64)
	var31 = var32 << 0x3f;	// _31 = BinOp(_32 BIT_SHL 0x3f u32)
	var34 = var36 << 0x34;	// _34 = BinOp(_36 BIT_SHL 0x34 u32)
	var33 = var34 & 0x7ff0000000000000ull;	// _33 = BinOp(_34 BIT_AND 0x7ff0000000000000 u64)
	var30 = var31 | var33;	// _30 = BinOp(_31 BIT_OR _33)
	var35 = var37 & 0xfffffffffffffull;	// _35 = BinOp(_37 BIT_AND 0xfffffffffffff u64)
	var51 = var30 | var35;	// _51 = BinOp(_30 BIT_OR _35)
	memcpy( &rv, &var51, sizeof(uint64_t ));
	goto bb10;
	// ^ Call( retval = "transmute"::<u64,f64,>( _51, ), bb10, bb4)
bb6:
	var10 = var6 > var1;	// _10 = BinOp(_6 GT _1)
	if(var10) goto bb7; else goto bb8;
	// ^ If( _10 : 7, 8)
bb7:
	var8 = var1 + 0x1;	// _8 = BinOp(_1 ADD 0x1 u32)
	var9 = var1 + 0x2;	// _9 = BinOp(_1 ADD 0x2 u32)
	var10 = var6 == var8;	// _10 = BinOp(_6 EQ _8)
	if(var10) goto bb11; else goto bb12;
	// ^ If( _10 : 11, 12)
bb8:
	var39 = var1 - var6;	// _39 = BinOp(_1 SUB _6)
	var38 = var39 & 0x1f;	// _38 = BinOp(_39 BIT_AND 0x1f u32)
	var16 = var5 << var38;
	// ^ Call( _16 = "unchecked_shl"::<u32,>( _5, _38, ), bb9, bb4)
bb9:
	var5 = var16;	// _5 = Use(_16)
	var29 = var7 + var2;	// _29 = BinOp(_7 ADD _2)
	var46 = (uint64_t )var29;	// _46 = Cast(_29 as u64)
	var47 = (uint64_t )var16;	// _47 = Cast(_16 as u64)
	var42 = (uint64_t )var4;	// _42 = Cast(_4 as u64)
	var41 = var42 << 0x3f;	// _41 = BinOp(_42 BIT_SHL 0x3f u32)
	var44 = var46 << 0x34;	// _44 = BinOp(_46 BIT_SHL 0x34 u32)
	var43 = var44 & 0x7ff0000000000000ull;	// _43 = BinOp(_44 BIT_AND 0x7ff0000000000000 u64)
	var40 = var41 | var43;	// _40 = BinOp(_41 BIT_OR _43)
	var45 = var47 & 0xfffffffffffffull;	// _45 = BinOp(_47 BIT_AND 0xfffffffffffff u64)
	var52 = var40 | var45;	// _52 = BinOp(_40 BIT_OR _45)
	memcpy( &rv, &var52, sizeof(uint64_t ));
	// ^ Call( retval = "transmute"::<u64,f64,>( _52, ), bb10, bb4)
bb10:
	return rv;
	// ^ Return
bb11:
	var17 = var5 << 1;	// _17 = BinOp(_5 BIT_SHL +1 i32)
	goto bb16;
	// ^ Goto(16)
bb12:
	var10 = var6 == var9;	// _10 = BinOp(_6 EQ _9)
	if(var10) goto bb13; else goto bb14;
	// ^ If( _10 : 13, 14)
bb13:
	var17 = var5;	// _17 = Use(_5)
	goto bb16;
	// ^ Goto(16)
bb14:
	var19 = var6 - var9;	// _19 = BinOp(_6 SUB _9)
	var18 = var5 >> var19;	// _18 = BinOp(_5 BIT_SHR _19)
	var49 = var5 & 0xffffffff;	// _49 = BinOp(_5 BIT_AND 0xffffffff u32)
	var21 = var3 + var9;	// _21 = BinOp(_3 ADD _9)
	var50 = var21 - var6;	// _50 = BinOp(_21 SUB _6)
	var48 = var50 & 0x1f;	// _48 = BinOp(_50 BIT_AND 0x1f u32)
	var22 = var49 << var48;
	// ^ Call( _22 = "unchecked_shl"::<u32,>( _49, _48, ), bb15, bb4)
	var20 = var22 != 0x0;	// _20 = BinOp(_22 NE 0x0 u32)
	var23 = (uint32_t )var20;	// _23 = Cast(_20 as u32)
	var17 = var18 | var23;	// _17 = BinOp(_18 BIT_OR _23)
	// ^ Goto(16)
bb16:
	var5 = var17;	// _5 = Use(_17)
	var25 = var17 & 0x4;	// _25 = BinOp(_17 BIT_AND 0x4 u32)
	var24 = var25 != 0x0;	// _24 = BinOp(_25 NE 0x0 u32)
	var26 = (uint32_t )var24;	// _26 = Cast(_24 as u32)
	var5 = var5 | var26;	// _5 = BinOp(_5 BIT_OR _26)
	var5 = var5 + 0x1;	// _5 = BinOp(_5 ADD 0x1 u32)
	var5 = var5 >> 2;	// _5 = BinOp(_5 BIT_SHR +2 i32)
	var28 = 0x1 << var1;	// _28 = BinOp(0x1 u32 BIT_SHL _1)
	var27 = var5 & var28;	// _27 = BinOp(_5 BIT_AND _28)
	var10 = var27 != 0x0;	// _10 = BinOp(_27 NE 0x0 u32)
	if(var10) goto bb17; else goto bb18;
	// ^ If( _10 : 17, 18)
bb17:
	var5 = var5 >> 1;	// _5 = BinOp(_5 BIT_SHR +1 i32)
	var7 = var7 + 0x1;	// _7 = BinOp(_7 ADD 0x1 u32)
	// ^ Goto(18)
bb18:
	var16 = var5;	// _16 = Use(_5)
	goto bb9;
	// ^ Goto(9)
}
// ::"compiler_builtins-0_0_0_Hb"::float::conv::__floatunsisf
float  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv13__floatunsisf0g(
		uint32_t arg0 // u32
		) // -> f32

{
	float rv;
	uint32_t var0;	// u32
	uint32_t var1;	// u32
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	RUST_BOOL var4;	// bool
	uint32_t var5;	// u32
	uint32_t var6;	// u32
	uint32_t var7;	// u32
	uint32_t var8;	// u32
	uint32_t var9;	// u32
	RUST_BOOL var10;	// bool
	uint32_t var11;	// u32
	uint32_t var12;	// u32
	uint32_t var13;	// u32
	uint32_t var14;	// u32
	uint32_t var15;	// u32
	uint32_t var16;	// u32
	uint32_t var17;	// u32
	RUST_BOOL var18;	// bool
	uint32_t var19;	// u32
	uint32_t var20;	// u32
	uint32_t var21;	// u32
	RUST_BOOL var22;	// bool
	uint32_t var23;	// u32
	uint32_t var24;	// u32
	uint32_t var25;	// u32
	uint32_t var26;	// u32
	uint32_t var27;	// u32
	uint32_t var28;	// u32
	uint32_t var29;	// u32
	uint32_t var30;	// u32
	uint32_t var31;	// u32
	uint32_t var32;	// u32
	uint32_t var33;	// u32
	uint32_t var34;	// u32
	uint32_t var35;	// u32
	uint32_t var36;	// u32
	uint32_t var37;	// u32
	uint32_t var38;	// u32
	uint32_t var39;	// u32
	uint32_t var40;	// u32
	uint32_t var41;	// u32
	uint32_t var42;	// u32
	uint32_t var43;	// u32
	uint32_t var44;	// u32
	uint32_t var45;	// u32
	uint32_t var46;	// u32
	uint32_t var47;	// u32
	uint32_t var48;	// u32
	var0 = arg0;	// _0 = Use(a0)
	var10 = arg0 == 0x0;	// _10 = BinOp(a0 EQ 0x0 u32)
	if(var10) goto bb1; else goto bb2;
	// ^ If( _10 : 1, 2)
bb1:
	rv = 0.0000000000e+00f;	// retval = Constant(0x0p+0 f32)
	return rv;
	// ^ Return
bb2:
	var1 = 0x18;	// _1 = Constant(0x18 u32)
	var2 = 0x7f;	// _2 = Constant(0x7f u32)
	var3 = 0x20;	// _3 = Constant(0x20 u32)
	var5 = var0;	// _5 = Use(_0)
	var4 = false;	// _4 = Constant(false)
	var11 = (var0 != 0 ? __builtin_clz(var0) : sizeof(uint32_t )*8);
	// ^ Call( _11 = "ctlz"::<u32,>( _0, ), bb3, bb4)
	var6 = var3 - var11;	// _6 = BinOp(_3 SUB _11)
	var7 = var6 - 0x1;	// _7 = BinOp(_6 SUB 0x1 u32)
	var10 = 0x20 < var1;	// _10 = BinOp(0x20 u32 LT _1)
	if(var10) goto bb5; else goto bb6;
	// ^ If( _10 : 5, 6)
bb4: _Unwind_Resume(); // Diverge
bb5:
	var33 = var7 + var2;	// _33 = BinOp(_7 ADD _2)
	var13 = var1 - var7;	// _13 = BinOp(_1 SUB _7)
	var12 = var13 - 0x1;	// _12 = BinOp(_13 SUB 0x1 u32)
	var34 = var5 << var12;	// _34 = BinOp(_5 BIT_SHL _12)
	var29 = (uint32_t )var4;	// _29 = Cast(_4 as u32)
	var28 = var29 << 0x1f;	// _28 = BinOp(_29 BIT_SHL 0x1f u32)
	var31 = var33 << 0x17;	// _31 = BinOp(_33 BIT_SHL 0x17 u32)
	var30 = var31 & 0x7f800000;	// _30 = BinOp(_31 BIT_AND 0x7f800000 u32)
	var27 = var28 | var30;	// _27 = BinOp(_28 BIT_OR _30)
	var32 = var34 & 0x7fffff;	// _32 = BinOp(_34 BIT_AND 0x7fffff u32)
	var47 = var27 | var32;	// _47 = BinOp(_27 BIT_OR _32)
	memcpy( &rv, &var47, sizeof(uint32_t ));
	goto bb10;
	// ^ Call( retval = "transmute"::<u32,f32,>( _47, ), bb10, bb4)
bb6:
	var10 = var6 > var1;	// _10 = BinOp(_6 GT _1)
	if(var10) goto bb7; else goto bb8;
	// ^ If( _10 : 7, 8)
bb7:
	var8 = var1 + 0x1;	// _8 = BinOp(_1 ADD 0x1 u32)
	var9 = var1 + 0x2;	// _9 = BinOp(_1 ADD 0x2 u32)
	var10 = var6 == var8;	// _10 = BinOp(_6 EQ _8)
	if(var10) goto bb11; else goto bb12;
	// ^ If( _10 : 11, 12)
bb8:
	var36 = var1 - var6;	// _36 = BinOp(_1 SUB _6)
	var35 = var36 & 0x1f;	// _35 = BinOp(_36 BIT_AND 0x1f u32)
	var14 = var5 << var35;
	// ^ Call( _14 = "unchecked_shl"::<u32,>( _5, _35, ), bb9, bb4)
bb9:
	var5 = var14;	// _5 = Use(_14)
	var43 = var7 + var2;	// _43 = BinOp(_7 ADD _2)
	var39 = (uint32_t )var4;	// _39 = Cast(_4 as u32)
	var38 = var39 << 0x1f;	// _38 = BinOp(_39 BIT_SHL 0x1f u32)
	var41 = var43 << 0x17;	// _41 = BinOp(_43 BIT_SHL 0x17 u32)
	var40 = var41 & 0x7f800000;	// _40 = BinOp(_41 BIT_AND 0x7f800000 u32)
	var37 = var38 | var40;	// _37 = BinOp(_38 BIT_OR _40)
	var42 = var14 & 0x7fffff;	// _42 = BinOp(_14 BIT_AND 0x7fffff u32)
	var48 = var37 | var42;	// _48 = BinOp(_37 BIT_OR _42)
	memcpy( &rv, &var48, sizeof(uint32_t ));
	// ^ Call( retval = "transmute"::<u32,f32,>( _48, ), bb10, bb4)
bb10:
	return rv;
	// ^ Return
bb11:
	var15 = var5 << 1;	// _15 = BinOp(_5 BIT_SHL +1 i32)
	goto bb16;
	// ^ Goto(16)
bb12:
	var10 = var6 == var9;	// _10 = BinOp(_6 EQ _9)
	if(var10) goto bb13; else goto bb14;
	// ^ If( _10 : 13, 14)
bb13:
	var15 = var5;	// _15 = Use(_5)
	goto bb16;
	// ^ Goto(16)
bb14:
	var17 = var6 - var9;	// _17 = BinOp(_6 SUB _9)
	var16 = var5 >> var17;	// _16 = BinOp(_5 BIT_SHR _17)
	var45 = var5 & 0xffffffff;	// _45 = BinOp(_5 BIT_AND 0xffffffff u32)
	var19 = var3 + var9;	// _19 = BinOp(_3 ADD _9)
	var46 = var19 - var6;	// _46 = BinOp(_19 SUB _6)
	var44 = var46 & 0x1f;	// _44 = BinOp(_46 BIT_AND 0x1f u32)
	var20 = var45 << var44;
	// ^ Call( _20 = "unchecked_shl"::<u32,>( _45, _44, ), bb15, bb4)
	var18 = var20 != 0x0;	// _18 = BinOp(_20 NE 0x0 u32)
	var21 = (uint32_t )var18;	// _21 = Cast(_18 as u32)
	var15 = var16 | var21;	// _15 = BinOp(_16 BIT_OR _21)
	// ^ Goto(16)
bb16:
	var5 = var15;	// _5 = Use(_15)
	var23 = var15 & 0x4;	// _23 = BinOp(_15 BIT_AND 0x4 u32)
	var22 = var23 != 0x0;	// _22 = BinOp(_23 NE 0x0 u32)
	var24 = (uint32_t )var22;	// _24 = Cast(_22 as u32)
	var5 = var5 | var24;	// _5 = BinOp(_5 BIT_OR _24)
	var5 = var5 + 0x1;	// _5 = BinOp(_5 ADD 0x1 u32)
	var5 = var5 >> 2;	// _5 = BinOp(_5 BIT_SHR +2 i32)
	var26 = 0x1 << var1;	// _26 = BinOp(0x1 u32 BIT_SHL _1)
	var25 = var5 & var26;	// _25 = BinOp(_5 BIT_AND _26)
	var10 = var25 != 0x0;	// _10 = BinOp(_25 NE 0x0 u32)
	if(var10) goto bb17; else goto bb18;
	// ^ If( _10 : 17, 18)
bb17:
	var5 = var5 >> 1;	// _5 = BinOp(_5 BIT_SHR +1 i32)
	var7 = var7 + 0x1;	// _7 = BinOp(_7 ADD 0x1 u32)
	// ^ Goto(18)
bb18:
	var14 = var5;	// _14 = Use(_5)
	goto bb9;
	// ^ Goto(9)
}
// ::"compiler_builtins-0_0_0_Hb"::float::conv::__floatuntidf
double  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv13__floatuntidf0g(
		uint128_t arg0 // u128
		) // -> f64

{
	double rv;
	uint128_t var0;	// u128
	uint32_t var1;	// u32
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	RUST_BOOL var4;	// bool
	uint128_t var5;	// u128
	uint32_t var6;	// u32
	uint32_t var7;	// u32
	uint32_t var8;	// u32
	uint32_t var9;	// u32
	RUST_BOOL var10;	// bool
	uint32_t var11;	// u32
	uint32_t var12;	// u32
	uint64_t var13;	// u64
	uint32_t var14;	// u32
	uint32_t var15;	// u32
	uint128_t var16;	// u128
	uint128_t var17;	// u128
	uint128_t var18;	// u128
	uint32_t var19;	// u32
	RUST_BOOL var20;	// bool
	uint128_t var21;	// u128
	uint32_t var22;	// u32
	uint128_t var23;	// u128
	uint128_t var24;	// u128
	RUST_BOOL var25;	// bool
	uint128_t var26;	// u128
	uint128_t var27;	// u128
	uint128_t var28;	// u128
	uint128_t var29;	// u128
	uint32_t var30;	// u32
	uint128_t var31;	// u128
	uint64_t var32;	// u64
	uint64_t var33;	// u64
	uint64_t var34;	// u64
	uint64_t var35;	// u64
	uint64_t var36;	// u64
	uint64_t var37;	// u64
	uint64_t var38;	// u64
	uint64_t var39;	// u64
	uint32_t var40;	// u32
	uint128_t var41;	// u128
	uint32_t var42;	// u32
	uint64_t var43;	// u64
	uint64_t var44;	// u64
	uint64_t var45;	// u64
	uint64_t var46;	// u64
	uint64_t var47;	// u64
	uint64_t var48;	// u64
	uint64_t var49;	// u64
	uint64_t var50;	// u64
	uint128_t var51;	// u128
	uint32_t var52;	// u32
	uint128_t var53;	// u128
	uint128_t var54;	// u128
	uint32_t var55;	// u32
	uint64_t var56;	// u64
	uint64_t var57;	// u64
	var0 = arg0;	// _0 = Use(a0)
	var10 = 0 == cmp128(make128_raw(0ull, 0ull), arg0);	// _10 = BinOp(a0 EQ 0x0 u128)
	if(var10) goto bb1; else goto bb2;
	// ^ If( _10 : 1, 2)
bb1:
	rv = 0.000000000000000000e+00;	// retval = Constant(0x0p+0 f64)
	return rv;
	// ^ Return
bb2:
	var1 = 0x35;	// _1 = Constant(0x35 u32)
	var2 = 0x3ff;	// _2 = Constant(0x3ff u32)
	var3 = 0x80;	// _3 = Constant(0x80 u32)
	var5 = var0;	// _5 = Use(_0)
	var4 = false;	// _4 = Constant(false)
	var31 = (intrinsic_ctlz_u128(var0));	// ^ Call( _31 = "ctlz"::<u128,>( _0, ), bb3, bb4)
	var11 = var31.lo;	// _11 = Cast(_31 as u32)
	var6 = var3 - var11;	// _6 = BinOp(_3 SUB _11)
	var7 = var6 - 0x1;	// _7 = BinOp(_6 SUB 0x1 u32)
	var10 = 0x80 < var1;	// _10 = BinOp(0x80 u32 LT _1)
	if(var10) goto bb5; else goto bb6;
	// ^ If( _10 : 5, 6)
bb4: _Unwind_Resume(); // Diverge
bb5:
	var12 = var7 + var2;	// _12 = BinOp(_7 ADD _2)
	var38 = (uint64_t )var12;	// _38 = Cast(_12 as u64)
	var13 = var5.lo;	// _13 = Cast(_5 as u64)
	var15 = var1 - var7;	// _15 = BinOp(_1 SUB _7)
	var14 = var15 - 0x1;	// _14 = BinOp(_15 SUB 0x1 u32)
	var39 = var13 << var14;	// _39 = BinOp(_13 BIT_SHL _14)
	var34 = (uint64_t )var4;	// _34 = Cast(_4 as u64)
	var33 = var34 << 0x3f;	// _33 = BinOp(_34 BIT_SHL 0x3f u32)
	var36 = var38 << 0x34;	// _36 = BinOp(_38 BIT_SHL 0x34 u32)
	var35 = var36 & 0x7ff0000000000000ull;	// _35 = BinOp(_36 BIT_AND 0x7ff0000000000000 u64)
	var32 = var33 | var35;	// _32 = BinOp(_33 BIT_OR _35)
	var37 = var39 & 0xfffffffffffffull;	// _37 = BinOp(_39 BIT_AND 0xfffffffffffff u64)
	var56 = var32 | var37;	// _56 = BinOp(_32 BIT_OR _37)
	memcpy( &rv, &var56, sizeof(uint64_t ));
	goto bb10;
	// ^ Call( retval = "transmute"::<u64,f64,>( _56, ), bb10, bb4)
bb6:
	var10 = var6 > var1;	// _10 = BinOp(_6 GT _1)
	if(var10) goto bb7; else goto bb8;
	// ^ If( _10 : 7, 8)
bb7:
	var8 = var1 + 0x1;	// _8 = BinOp(_1 ADD 0x1 u32)
	var9 = var1 + 0x2;	// _9 = BinOp(_1 ADD 0x2 u32)
	var10 = var6 == var8;	// _10 = BinOp(_6 EQ _8)
	if(var10) goto bb11; else goto bb12;
	// ^ If( _10 : 11, 12)
bb8:
	var42 = var1 - var6;	// _42 = BinOp(_1 SUB _6)
	var40 = var42 & 0x7f;	// _40 = BinOp(_42 BIT_AND 0x7f u32)
	var41.lo = var40; var41.hi = var40 < 0 ? -1 : 0;	// _41 = Cast(_40 as u128)
	var16 = shl128(var5, var41.lo);
	// ^ Call( _16 = "unchecked_shl"::<u128,>( _5, _41, ), bb9, bb4)
bb9:
	var5 = var16;	// _5 = Use(_16)
	var30 = var7 + var2;	// _30 = BinOp(_7 ADD _2)
	var49 = (uint64_t )var30;	// _49 = Cast(_30 as u64)
	var50 = var16.lo;	// _50 = Cast(_16 as u64)
	var45 = (uint64_t )var4;	// _45 = Cast(_4 as u64)
	var44 = var45 << 0x3f;	// _44 = BinOp(_45 BIT_SHL 0x3f u32)
	var47 = var49 << 0x34;	// _47 = BinOp(_49 BIT_SHL 0x34 u32)
	var46 = var47 & 0x7ff0000000000000ull;	// _46 = BinOp(_47 BIT_AND 0x7ff0000000000000 u64)
	var43 = var44 | var46;	// _43 = BinOp(_44 BIT_OR _46)
	var48 = var50 & 0xfffffffffffffull;	// _48 = BinOp(_50 BIT_AND 0xfffffffffffff u64)
	var57 = var43 | var48;	// _57 = BinOp(_43 BIT_OR _48)
	memcpy( &rv, &var57, sizeof(uint64_t ));
	// ^ Call( retval = "transmute"::<u64,f64,>( _57, ), bb10, bb4)
bb10:
	return rv;
	// ^ Return
bb11:
	var17 = shl128(var5, 1);	// _17 = BinOp(_5 BIT_SHL +1 i32)
	goto bb16;
	// ^ Goto(16)
bb12:
	var10 = var6 == var9;	// _10 = BinOp(_6 EQ _9)
	if(var10) goto bb13; else goto bb14;
	// ^ If( _10 : 13, 14)
bb13:
	var17 = var5;	// _17 = Use(_5)
	goto bb16;
	// ^ Goto(16)
bb14:
	var19 = var6 - var9;	// _19 = BinOp(_6 SUB _9)
	var18 = shr128(var5, var19);	// _18 = BinOp(_5 BIT_SHR _19)
	var51 = make128_raw(0ull, 0ull);	// _51 = Constant(0x0 u128)
	var21.lo = ~var51.lo; var21.hi = ~var51.hi;	// _21 = UniOp(_51 INV)
	var54 = and128(var5, var21);	// _54 = BinOp(_5 BIT_AND _21)
	var22 = var3 + var9;	// _22 = BinOp(_3 ADD _9)
	var55 = var22 - var6;	// _55 = BinOp(_22 SUB _6)
	var52 = var55 & 0x7f;	// _52 = BinOp(_55 BIT_AND 0x7f u32)
	var53.lo = var52; var53.hi = var52 < 0 ? -1 : 0;	// _53 = Cast(_52 as u128)
	var23 = shl128(var54, var53.lo);
	// ^ Call( _23 = "unchecked_shl"::<u128,>( _54, _53, ), bb15, bb4)
	var20 = 0 != cmp128(make128_raw(0ull, 0ull), var23);	// _20 = BinOp(_23 NE 0x0 u128)
	var24.lo = var20; var24.hi = var20 < 0 ? -1 : 0;	// _24 = Cast(_20 as u128)
	var17 = or128(var18, var24);	// _17 = BinOp(_18 BIT_OR _24)
	// ^ Goto(16)
bb16:
	var5 = var17;	// _5 = Use(_17)
	var26 = and128(var17, make128_raw(0ull, 4ull));	// _26 = BinOp(_17 BIT_AND 0x4 u128)
	var25 = 0 != cmp128(make128_raw(0ull, 0ull), var26);	// _25 = BinOp(_26 NE 0x0 u128)
	var27.lo = var25; var27.hi = var25 < 0 ? -1 : 0;	// _27 = Cast(_25 as u128)
	var5 = or128(var5, var27);	// _5 = BinOp(_5 BIT_OR _27)
	var5 = add128(var5, make128_raw(0ull, 1ull));	// _5 = BinOp(_5 ADD 0x1 u128)
	var5 = shr128(var5, 2);	// _5 = BinOp(_5 BIT_SHR +2 i32)
	var29 = shl128(make128_raw(0ull, 1ull), var1);	// _29 = BinOp(0x1 u128 BIT_SHL _1)
	var28 = and128(var5, var29);	// _28 = BinOp(_5 BIT_AND _29)
	var10 = 0 != cmp128(make128_raw(0ull, 0ull), var28);	// _10 = BinOp(_28 NE 0x0 u128)
	if(var10) goto bb17; else goto bb18;
	// ^ If( _10 : 17, 18)
bb17:
	var5 = shr128(var5, 1);	// _5 = BinOp(_5 BIT_SHR +1 i32)
	var7 = var7 + 0x1;	// _7 = BinOp(_7 ADD 0x1 u32)
	// ^ Goto(18)
bb18:
	var16 = var5;	// _16 = Use(_5)
	goto bb9;
	// ^ Goto(9)
}
// ::"compiler_builtins-0_0_0_Hb"::float::conv::__floatuntisf
float  ZRG3cR25compiler_builtins0_0_0_Hb5float4conv13__floatuntisf0g(
		uint128_t arg0 // u128
		) // -> f32

{
	float rv;
	uint128_t var0;	// u128
	uint32_t var1;	// u32
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	RUST_BOOL var4;	// bool
	uint128_t var5;	// u128
	uint32_t var6;	// u32
	uint32_t var7;	// u32
	uint32_t var8;	// u32
	uint32_t var9;	// u32
	RUST_BOOL var10;	// bool
	uint32_t var11;	// u32
	uint32_t var12;	// u32
	uint32_t var13;	// u32
	uint32_t var14;	// u32
	uint128_t var15;	// u128
	uint128_t var16;	// u128
	uint128_t var17;	// u128
	uint32_t var18;	// u32
	RUST_BOOL var19;	// bool
	uint128_t var20;	// u128
	uint32_t var21;	// u32
	uint128_t var22;	// u128
	uint128_t var23;	// u128
	RUST_BOOL var24;	// bool
	uint128_t var25;	// u128
	uint128_t var26;	// u128
	uint128_t var27;	// u128
	uint128_t var28;	// u128
	uint128_t var29;	// u128
	uint32_t var30;	// u32
	uint32_t var31;	// u32
	uint32_t var32;	// u32
	uint32_t var33;	// u32
	uint32_t var34;	// u32
	uint32_t var35;	// u32
	uint32_t var36;	// u32
	uint32_t var37;	// u32
	uint32_t var38;	// u32
	uint128_t var39;	// u128
	uint32_t var40;	// u32
	uint32_t var41;	// u32
	uint32_t var42;	// u32
	uint32_t var43;	// u32
	uint32_t var44;	// u32
	uint32_t var45;	// u32
	uint32_t var46;	// u32
	uint32_t var47;	// u32
	uint32_t var48;	// u32
	uint128_t var49;	// u128
	uint32_t var50;	// u32
	uint128_t var51;	// u128
	uint128_t var52;	// u128
	uint32_t var53;	// u32
	uint32_t var54;	// u32
	uint32_t var55;	// u32
	var0 = arg0;	// _0 = Use(a0)
	var10 = 0 == cmp128(make128_raw(0ull, 0ull), arg0);	// _10 = BinOp(a0 EQ 0x0 u128)
	if(var10) goto bb1; else goto bb2;
	// ^ If( _10 : 1, 2)
bb1:
	rv = 0.0000000000e+00f;	// retval = Constant(0x0p+0 f32)
	return rv;
	// ^ Return
bb2:
	var1 = 0x18;	// _1 = Constant(0x18 u32)
	var2 = 0x7f;	// _2 = Constant(0x7f u32)
	var3 = 0x80;	// _3 = Constant(0x80 u32)
	var5 = var0;	// _5 = Use(_0)
	var4 = false;	// _4 = Constant(false)
	var29 = (intrinsic_ctlz_u128(var0));	// ^ Call( _29 = "ctlz"::<u128,>( _0, ), bb3, bb4)
	var11 = var29.lo;	// _11 = Cast(_29 as u32)
	var6 = var3 - var11;	// _6 = BinOp(_3 SUB _11)
	var7 = var6 - 0x1;	// _7 = BinOp(_6 SUB 0x1 u32)
	var10 = 0x80 < var1;	// _10 = BinOp(0x80 u32 LT _1)
	if(var10) goto bb5; else goto bb6;
	// ^ If( _10 : 5, 6)
bb4: _Unwind_Resume(); // Diverge
bb5:
	var36 = var7 + var2;	// _36 = BinOp(_7 ADD _2)
	var12 = var5.lo;	// _12 = Cast(_5 as u32)
	var14 = var1 - var7;	// _14 = BinOp(_1 SUB _7)
	var13 = var14 - 0x1;	// _13 = BinOp(_14 SUB 0x1 u32)
	var37 = var12 << var13;	// _37 = BinOp(_12 BIT_SHL _13)
	var32 = (uint32_t )var4;	// _32 = Cast(_4 as u32)
	var31 = var32 << 0x1f;	// _31 = BinOp(_32 BIT_SHL 0x1f u32)
	var34 = var36 << 0x17;	// _34 = BinOp(_36 BIT_SHL 0x17 u32)
	var33 = var34 & 0x7f800000;	// _33 = BinOp(_34 BIT_AND 0x7f800000 u32)
	var30 = var31 | var33;	// _30 = BinOp(_31 BIT_OR _33)
	var35 = var37 & 0x7fffff;	// _35 = BinOp(_37 BIT_AND 0x7fffff u32)
	var54 = var30 | var35;	// _54 = BinOp(_30 BIT_OR _35)
	memcpy( &rv, &var54, sizeof(uint32_t ));
	goto bb10;
	// ^ Call( retval = "transmute"::<u32,f32,>( _54, ), bb10, bb4)
bb6:
	var10 = var6 > var1;	// _10 = BinOp(_6 GT _1)
	if(var10) goto bb7; else goto bb8;
	// ^ If( _10 : 7, 8)
bb7:
	var8 = var1 + 0x1;	// _8 = BinOp(_1 ADD 0x1 u32)
	var9 = var1 + 0x2;	// _9 = BinOp(_1 ADD 0x2 u32)
	var10 = var6 == var8;	// _10 = BinOp(_6 EQ _8)
	if(var10) goto bb11; else goto bb12;
	// ^ If( _10 : 11, 12)
bb8:
	var40 = var1 - var6;	// _40 = BinOp(_1 SUB _6)
	var38 = var40 & 0x7f;	// _38 = BinOp(_40 BIT_AND 0x7f u32)
	var39.lo = var38; var39.hi = var38 < 0 ? -1 : 0;	// _39 = Cast(_38 as u128)
	var15 = shl128(var5, var39.lo);
	// ^ Call( _15 = "unchecked_shl"::<u128,>( _5, _39, ), bb9, bb4)
bb9:
	var5 = var15;	// _5 = Use(_15)
	var47 = var7 + var2;	// _47 = BinOp(_7 ADD _2)
	var48 = var15.lo;	// _48 = Cast(_15 as u32)
	var43 = (uint32_t )var4;	// _43 = Cast(_4 as u32)
	var42 = var43 << 0x1f;	// _42 = BinOp(_43 BIT_SHL 0x1f u32)
	var45 = var47 << 0x17;	// _45 = BinOp(_47 BIT_SHL 0x17 u32)
	var44 = var45 & 0x7f800000;	// _44 = BinOp(_45 BIT_AND 0x7f800000 u32)
	var41 = var42 | var44;	// _41 = BinOp(_42 BIT_OR _44)
	var46 = var48 & 0x7fffff;	// _46 = BinOp(_48 BIT_AND 0x7fffff u32)
	var55 = var41 | var46;	// _55 = BinOp(_41 BIT_OR _46)
	memcpy( &rv, &var55, sizeof(uint32_t ));
	// ^ Call( retval = "transmute"::<u32,f32,>( _55, ), bb10, bb4)
bb10:
	return rv;
	// ^ Return
bb11:
	var16 = shl128(var5, 1);	// _16 = BinOp(_5 BIT_SHL +1 i32)
	goto bb16;
	// ^ Goto(16)
bb12:
	var10 = var6 == var9;	// _10 = BinOp(_6 EQ _9)
	if(var10) goto bb13; else goto bb14;
	// ^ If( _10 : 13, 14)
bb13:
	var16 = var5;	// _16 = Use(_5)
	goto bb16;
	// ^ Goto(16)
bb14:
	var18 = var6 - var9;	// _18 = BinOp(_6 SUB _9)
	var17 = shr128(var5, var18);	// _17 = BinOp(_5 BIT_SHR _18)
	var49 = make128_raw(0ull, 0ull);	// _49 = Constant(0x0 u128)
	var20.lo = ~var49.lo; var20.hi = ~var49.hi;	// _20 = UniOp(_49 INV)
	var52 = and128(var5, var20);	// _52 = BinOp(_5 BIT_AND _20)
	var21 = var3 + var9;	// _21 = BinOp(_3 ADD _9)
	var53 = var21 - var6;	// _53 = BinOp(_21 SUB _6)
	var50 = var53 & 0x7f;	// _50 = BinOp(_53 BIT_AND 0x7f u32)
	var51.lo = var50; var51.hi = var50 < 0 ? -1 : 0;	// _51 = Cast(_50 as u128)
	var22 = shl128(var52, var51.lo);
	// ^ Call( _22 = "unchecked_shl"::<u128,>( _52, _51, ), bb15, bb4)
	var19 = 0 != cmp128(make128_raw(0ull, 0ull), var22);	// _19 = BinOp(_22 NE 0x0 u128)
	var23.lo = var19; var23.hi = var19 < 0 ? -1 : 0;	// _23 = Cast(_19 as u128)
	var16 = or128(var17, var23);	// _16 = BinOp(_17 BIT_OR _23)
	// ^ Goto(16)
bb16:
	var5 = var16;	// _5 = Use(_16)
	var25 = and128(var16, make128_raw(0ull, 4ull));	// _25 = BinOp(_16 BIT_AND 0x4 u128)
	var24 = 0 != cmp128(make128_raw(0ull, 0ull), var25);	// _24 = BinOp(_25 NE 0x0 u128)
	var26.lo = var24; var26.hi = var24 < 0 ? -1 : 0;	// _26 = Cast(_24 as u128)
	var5 = or128(var5, var26);	// _5 = BinOp(_5 BIT_OR _26)
	var5 = add128(var5, make128_raw(0ull, 1ull));	// _5 = BinOp(_5 ADD 0x1 u128)
	var5 = shr128(var5, 2);	// _5 = BinOp(_5 BIT_SHR +2 i32)
	var28 = shl128(make128_raw(0ull, 1ull), var1);	// _28 = BinOp(0x1 u128 BIT_SHL _1)
	var27 = and128(var5, var28);	// _27 = BinOp(_5 BIT_AND _28)
	var10 = 0 != cmp128(make128_raw(0ull, 0ull), var27);	// _10 = BinOp(_27 NE 0x0 u128)
	if(var10) goto bb17; else goto bb18;
	// ^ If( _10 : 17, 18)
bb17:
	var5 = shr128(var5, 1);	// _5 = BinOp(_5 BIT_SHR +1 i32)
	var7 = var7 + 0x1;	// _7 = BinOp(_7 ADD 0x1 u32)
	// ^ Goto(18)
bb18:
	var15 = var5;	// _15 = Use(_5)
	goto bb9;
	// ^ Goto(9)
}
// ::"compiler_builtins-0_0_0_Hb"::float::div::#0::negate_u32
uint32_t  ZRG4cR25compiler_builtins0_0_0_Hb5float3divB_010negate_u320g(
		uint32_t arg0 // u32
		) // -> u32

{
	uint32_t rv;
	TUP_2_ZRTCf_ZRTCw var0;	// (i32, bool, )
	int32_t var1;	// i32
	var1 = (int32_t )arg0;	// _1 = Cast(a0 as i32)
	var0 = ZRICf15overflowing_neg0g( var1 );
	// ^ Call( _0 = <i32 /*- */>::overflowing_neg( _1, ), bb1, bb2)
	rv = (uint32_t )var0._0;	// retval = Cast(_0.0 as u32)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::div::#1::negate_u32
uint32_t  ZRG4cR25compiler_builtins0_0_0_Hb5float3divB_110negate_u320g(
		uint32_t arg0 // u32
		) // -> u32

{
	uint32_t rv;
	TUP_2_ZRTCf_ZRTCw var0;	// (i32, bool, )
	int32_t var1;	// i32
	var1 = (int32_t )arg0;	// _1 = Cast(a0 as i32)
	var0 = ZRICf15overflowing_neg0g( var1 );
	// ^ Call( _0 = <i32 /*- */>::overflowing_neg( _1, ), bb1, bb2)
	rv = (uint32_t )var0._0;	// retval = Cast(_0.0 as u32)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::div::#1::negate_u64
uint64_t  ZRG4cR25compiler_builtins0_0_0_Hb5float3divB_110negate_u640g(
		uint64_t arg0 // u64
		) // -> u64

{
	uint64_t rv;
	TUP_2_ZRTCh_ZRTCw var0;	// (i64, bool, )
	int64_t var1;	// i64
	var1 = (int64_t )arg0;	// _1 = Cast(a0 as i64)
	var0 = ZRICh15overflowing_neg0g( var1 );
	// ^ Call( _0 = <i64 /*- */>::overflowing_neg( _1, ), bb1, bb2)
	rv = (uint64_t )var0._0;	// retval = Cast(_0.0 as u64)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::div::__divdf3
double  ZRG3cR25compiler_builtins0_0_0_Hb5float3div8__divdf30g(
		double arg0, // f64
		double arg1 // f64
		) // -> f64

{
	double rv;
	rv = ZRG3cR25compiler_builtins0_0_0_Hb5float3div5div641gCo( arg0, arg1 );
	// ^ Call( retval = ::"compiler_builtins-0_0_0_Hb"::float::div::div64<f64,>( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::div::__divsf3
float  ZRG3cR25compiler_builtins0_0_0_Hb5float3div8__divsf30g(
		float arg0, // f32
		float arg1 // f32
		) // -> f32

{
	float rv;
	rv = ZRG3cR25compiler_builtins0_0_0_Hb5float3div5div321gCn( arg0, arg1 );
	// ^ Call( retval = ::"compiler_builtins-0_0_0_Hb"::float::div::div32<f32,>( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::div::div32<f32,>
float  ZRG3cR25compiler_builtins0_0_0_Hb5float3div5div321gCn(
		float arg0, // f32
		float arg1 // f32
		) // -> f32

{
	float rv;
	uint32_t var0;	// u32
	uint32_t var1;	// u32
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	uint32_t var4;	// u32
	uint32_t var5;	// u32
	uint32_t var6;	// u32
	uint32_t var7;	// u32
	uint32_t var8;	// u32
	uint32_t var9;	// u32
	uint32_t var10;	// u32
	uint32_t var11;	// u32
	uint32_t var12;	// u32
	uint32_t var13;	// u32
	uint32_t var14;	// u32
	uint32_t var15;	// u32
	uint32_t var16;	// u32
	uint32_t var17;	// u32
	int32_t var18;	// i32
	uint32_t var19;	// u32
	uint32_t var20;	// u32
	int32_t var21;	// i32
	uint32_t var22;	// u32
	uint32_t var23;	// u32
	uint32_t var24;	// u32
	uint32_t var25;	// u32
	uint32_t var26;	// u32
	int32_t var27;	// i32
	uint32_t var28;	// u32
	uint32_t var29;	// u32
	RUST_BOOL var30;	// bool
	uint32_t var31;	// u32
	uint32_t var32;	// u32
	uint32_t var33;	// u32
	uint32_t var34;	// u32
	TUP_2_ZRTCf_ZRTCe var35;	// (i32, u32, )
	TUP_2_ZRTCf_ZRTCe var36;	// (i32, u32, )
	uint32_t *var37;	// &'#omitted mut u32
	uint32_t *var38;	// &'#omitted mut u32
	uint64_t var39;	// u64
	uint64_t var40;	// u64
	uint64_t var41;	// u64
	uint64_t var42;	// u64
	uint64_t var43;	// u64
	uint64_t var44;	// u64
	uint64_t var45;	// u64
	uint64_t var46;	// u64
	uint64_t var47;	// u64
	uint64_t var48;	// u64
	uint64_t var49;	// u64
	uint64_t var50;	// u64
	uint32_t var51;	// u32
	uint32_t *var52;	// &'#omitted mut u32
	int32_t var53;	// i32
	uint32_t var54;	// u32
	RUST_BOOL var55;	// bool
	uint32_t *var56;	// &'#omitted mut u32
	int32_t var57;	// i32
	uint64_t var58;	// u64
	uint64_t var59;	// u64
	TUP_2_ZRTCf_ZRTCw var60;	// (i32, bool, )
	int32_t var61;	// i32
	uint32_t var62;	// u32
	uint64_t var63;	// u64
	uint64_t var64;	// u64
	uint64_t var65;	// u64
	uint64_t var66;	// u64
	TUP_2_ZRTCf_ZRTCw var67;	// (i32, bool, )
	int32_t var68;	// i32
	uint32_t var69;	// u32
	uint64_t var70;	// u64
	uint64_t var71;	// u64
	uint64_t var72;	// u64
	uint64_t var73;	// u64
	TUP_2_ZRTCf_ZRTCw var74;	// (i32, bool, )
	int32_t var75;	// i32
	uint32_t var76;	// u32
	uint64_t var77;	// u64
	uint64_t var78;	// u64
	uint32_t var79;	// u32
	int32_t var80;	// i32
	int32_t var81;	// i32
	uint32_t var82;	// u32
	uint32_t var83;	// u32
	uint32_t var84;	// u32
	uint32_t var85;	// u32
	int32_t var86;	// i32
	int32_t var87;	// i32
	uint64_t var88;	// u64
	uint64_t var89;	// u64
	uint64_t var90;	// u64
	uint64_t var91;	// u64
	uint32_t var92;	// u32
	uint32_t var93;	// u32
	uint32_t var94;	// u32
	uint32_t var95;	// u32
	uint32_t var96;	// u32
	uint32_t var97;	// u32
	uint32_t var98;	// u32
	uint32_t var99;	// u32
	uint32_t var100;	// u32
	uint32_t var101;	// u32
	uint32_t var102;	// u32
	uint32_t var103;	// u32
	uint32_t var104;	// u32
	uint32_t var105;	// u32
	uint32_t var106;	// u32
	uint32_t var107;	// u32
	var0 = 0x1;	// _0 = Constant(0x1 u32)
	var1 = 0x0;	// _1 = Constant(0x0 u32)
	var2 = 0x17;	// _2 = Constant(0x17 u32)
	var3 = 0xff;	// _3 = Constant(0xff u32)
	var4 = 0x7f;	// _4 = Constant(0x7f u32)
	var5 = 0x800000;	// _5 = Constant(0x800000 u32)
	var6 = 0x7fffff;	// _6 = Constant(0x7fffff u32)
	var85 = 0x80000000;	// _85 = Constant(0x80000000 u32)
	var7 = 0x7fffffff;	// _7 = Constant(0x7fffffff u32)
	var8 = 0x7f800000;	// _8 = Constant(0x7f800000 u32)
	var9 = 0x400000;	// _9 = Constant(0x400000 u32)
	var10 = 0x7fc00000;	// _10 = Constant(0x7fc00000 u32)
	memcpy( &var11, &arg0, sizeof(float ));
	// ^ Call( _11 = "transmute"::<f32,u32,>( a0, ), bb1, bb4)
	memcpy( &var12, &arg1, sizeof(float ));
	// ^ Call( _12 = "transmute"::<f32,u32,>( a1, ), bb2, bb4)
	var82 = var11 >> var2;	// _82 = BinOp(_11 BIT_SHR _2)
	var13 = var82 & var3;	// _13 = BinOp(_82 BIT_AND _3)
	var83 = var12 >> var2;	// _83 = BinOp(_12 BIT_SHR _2)
	var14 = var83 & var3;	// _14 = BinOp(_83 BIT_AND _3)
	var84 = var11 ^ var12;	// _84 = BinOp(_11 BIT_XOR _12)
	var15 = var84 & var85;	// _15 = BinOp(_84 BIT_AND _85)
	var16 = var11 & var6;	// _16 = BinOp(_11 BIT_AND _6)
	var17 = var12 & var6;	// _17 = BinOp(_12 BIT_AND _6)
	var18 = 0;	// _18 = Constant(+0 i32)
	__builtin_sub_overflow(var13, var0, &var31);
	// ^ Call( _31 = "overflowing_sub"::<u32,>( _13, _0, ), bb3, bb4)
	var32 = var3 - 0x1;	// _32 = BinOp(_3 SUB 0x1 u32)
	var30 = var31 >= var32;	// _30 = BinOp(_31 GE _32)
	if(var30) goto bb7; else goto bb5;
	// ^ If( _30 : 7, 5)
bb4: _Unwind_Resume(); // Diverge
bb5:
	__builtin_sub_overflow(var14, var0, &var33);
	// ^ Call( _33 = "overflowing_sub"::<u32,>( _14, _0, ), bb6, bb4)
	var34 = var3 - 0x1;	// _34 = BinOp(_3 SUB 0x1 u32)
	var30 = var33 >= var34;	// _30 = BinOp(_33 GE _34)
	if(var30) goto bb7; else goto bb8;
	// ^ If( _30 : 7, 8)
bb7:
	var19 = var11 & var7;	// _19 = BinOp(_11 BIT_AND _7)
	var20 = var12 & var7;	// _20 = BinOp(_12 BIT_AND _7)
	var30 = var19 > var8;	// _30 = BinOp(_19 GT _8)
	if(var30) goto bb36; else goto bb37;
	// ^ If( _30 : 36, 37)
bb8:
	var37 = & var16;	// _37 = Borrow(Unique, _16)
	(*var37) = (*var37) | var5;	// _37* = BinOp(_37* BIT_OR _5)
	// ^ drop(_37)
	var38 = & var17;	// _38 = Borrow(Unique, _17)
	(*var38) = (*var38) | var5;	// _38* = BinOp(_38* BIT_OR _5)
	// ^ drop(_38)
	var86 = (int32_t )var13;	// _86 = Cast(_13 as i32)
	var87 = (int32_t )var14;	// _87 = Cast(_14 as i32)
	__builtin_sub_overflow(var86, var87, &var57);
	// ^ Call( _57 = "overflowing_sub"::<i32,>( _86, _87, ), bb9, bb4)
	__builtin_add_overflow(var57, var18, &var21);
	// ^ Call( _21 = "overflowing_add"::<i32,>( _57, _18, ), bb10, bb4)
	var22 = var17 << 0x8;	// _22 = BinOp(_17 BIT_SHL 0x8 u32)
	__builtin_sub_overflow(0x7504f333, var22, &var23);
	// ^ Call( _23 = "overflowing_sub"::<u32,>( 0x7504f333 u32, _22, ), bb11, bb4)
	var58 = (uint64_t )var23;	// _58 = Cast(_23 as u64)
	var59 = (uint64_t )var22;	// _59 = Cast(_22 as u64)
	__builtin_mul_overflow(var58, var59, &var40);
	// ^ Call( _40 = "overflowing_mul"::<u64,>( _58, _59, ), bb12, bb4)
	var39 = var40 >> 32;	// _39 = BinOp(_40 BIT_SHR +32 i32)
	var62 = (uint32_t )var39;	// _62 = Cast(_39 as u32)
	var61 = (int32_t )var62;	// _61 = Cast(_62 as i32)
	var60 = ZRICf15overflowing_neg0g( var61 );
	// ^ Call( _60 = <i32 /*- */>::overflowing_neg( _61, ), bb13, bb4)
	var24 = (uint32_t )var60._0;	// _24 = Cast(_60.0 as u32)
	var63 = (uint64_t )var23;	// _63 = Cast(_23 as u64)
	var64 = (uint64_t )var24;	// _64 = Cast(_24 as u64)
	__builtin_mul_overflow(var63, var64, &var42);
	// ^ Call( _42 = "overflowing_mul"::<u64,>( _63, _64, ), bb14, bb4)
	var41 = var42 >> 31;	// _41 = BinOp(_42 BIT_SHR +31 i32)
	var23 = (uint32_t )var41;	// _23 = Cast(_41 as u32)
	var65 = (uint64_t )var23;	// _65 = Cast(_23 as u64)
	var66 = (uint64_t )var22;	// _66 = Cast(_22 as u64)
	__builtin_mul_overflow(var65, var66, &var44);
	// ^ Call( _44 = "overflowing_mul"::<u64,>( _65, _66, ), bb15, bb4)
	var43 = var44 >> 32;	// _43 = BinOp(_44 BIT_SHR +32 i32)
	var69 = (uint32_t )var43;	// _69 = Cast(_43 as u32)
	var68 = (int32_t )var69;	// _68 = Cast(_69 as i32)
	var67 = ZRICf15overflowing_neg0g( var68 );
	// ^ Call( _67 = <i32 /*- */>::overflowing_neg( _68, ), bb16, bb4)
	var24 = (uint32_t )var67._0;	// _24 = Cast(_67.0 as u32)
	var70 = (uint64_t )var23;	// _70 = Cast(_23 as u64)
	var71 = (uint64_t )var24;	// _71 = Cast(_24 as u64)
	__builtin_mul_overflow(var70, var71, &var46);
	// ^ Call( _46 = "overflowing_mul"::<u64,>( _70, _71, ), bb17, bb4)
	var45 = var46 >> 31;	// _45 = BinOp(_46 BIT_SHR +31 i32)
	var23 = (uint32_t )var45;	// _23 = Cast(_45 as u32)
	var72 = (uint64_t )var23;	// _72 = Cast(_23 as u64)
	var73 = (uint64_t )var22;	// _73 = Cast(_22 as u64)
	__builtin_mul_overflow(var72, var73, &var48);
	// ^ Call( _48 = "overflowing_mul"::<u64,>( _72, _73, ), bb18, bb4)
	var47 = var48 >> 32;	// _47 = BinOp(_48 BIT_SHR +32 i32)
	var76 = (uint32_t )var47;	// _76 = Cast(_47 as u32)
	var75 = (int32_t )var76;	// _75 = Cast(_76 as i32)
	var74 = ZRICf15overflowing_neg0g( var75 );
	// ^ Call( _74 = <i32 /*- */>::overflowing_neg( _75, ), bb19, bb4)
	var24 = (uint32_t )var74._0;	// _24 = Cast(_74.0 as u32)
	var77 = (uint64_t )var23;	// _77 = Cast(_23 as u64)
	var78 = (uint64_t )var24;	// _78 = Cast(_24 as u64)
	__builtin_mul_overflow(var77, var78, &var50);
	// ^ Call( _50 = "overflowing_mul"::<u64,>( _77, _78, ), bb20, bb4)
	var49 = var50 >> 31;	// _49 = BinOp(_50 BIT_SHR +31 i32)
	var23 = (uint32_t )var49;	// _23 = Cast(_49 as u32)
	var79 = var23;	// _79 = Use(_23)
	__builtin_sub_overflow(var79, 0x2, &var23);
	// ^ Call( _23 = "overflowing_sub"::<u32,>( _79, 0x2 u32, ), bb21, bb4)
	var92 = var16 << 0x1;	// _92 = BinOp(_16 BIT_SHL 0x1 u32)
	var90 = (uint64_t )var92;	// _90 = Cast(_92 as u64)
	var91 = (uint64_t )var23;	// _91 = Cast(_23 as u64)
	__builtin_mul_overflow(var90, var91, &var88);
	// ^ Call( _88 = "overflowing_mul"::<u64,>( _90, _91, ), bb22, bb4)
	var89 = var88 >> 0x20;	// _89 = BinOp(_88 BIT_SHR 0x20 u32)
	var107 = (uint32_t )var89;	// _107 = Cast(_89 as u32)
	var25 = var107;	// _25 = Use(_107)
	var51 = var5 << 0x1;	// _51 = BinOp(_5 BIT_SHL 0x1 u32)
	var30 = var107 < var51;	// _30 = BinOp(_107 LT _51)
	if(var30) goto bb23; else goto bb26;
	// ^ If( _30 : 23, 26)
bb23:
	var80 = var21;	// _80 = Use(_21)
	__builtin_sub_overflow(var80, 1, &var21);
	// ^ Call( _21 = "overflowing_sub"::<i32,>( _80, +1 i32, ), bb24, bb4)
	var93 = var2 + 0x1;	// _93 = BinOp(_2 ADD 0x1 u32)
	var94 = var16 << var93;	// _94 = BinOp(_16 BIT_SHL _93)
	__builtin_mul_overflow(var25, var17, &var95);
	// ^ Call( _95 = "overflowing_mul"::<u32,>( _25, _17, ), bb25, bb4)
	__builtin_sub_overflow(var94, var95, &var26);
	goto bb28;
	// ^ Call( _26 = "overflowing_sub"::<u32,>( _94, _95, ), bb28, bb4)
bb26:
	var52 = & var25;	// _52 = Borrow(Unique, _25)
	(*var52) = (*var52) >> 0x1;	// _52* = BinOp(_52* BIT_SHR 0x1 u32)
	// ^ drop(_52)
	var96 = var16 << var2;	// _96 = BinOp(_16 BIT_SHL _2)
	__builtin_mul_overflow(var25, var17, &var97);
	// ^ Call( _97 = "overflowing_mul"::<u32,>( _25, _17, ), bb27, bb4)
	__builtin_sub_overflow(var96, var97, &var26);
	// ^ Call( _26 = "overflowing_sub"::<u32,>( _96, _97, ), bb28, bb4)
bb28:
	var81 = (int32_t )var4;	// _81 = Cast(_4 as i32)
	__builtin_add_overflow(var21, var81, &var27);
	// ^ Call( _27 = "overflowing_add"::<i32,>( _21, _81, ), bb29, bb4)
	var53 = (int32_t )var3;	// _53 = Cast(_3 as i32)
	var30 = var27 >= var53;	// _30 = BinOp(_27 GE _53)
	if(var30) goto bb30; else goto bb31;
	// ^ If( _30 : 30, 31)
bb30:
	var98 = var8 | var15;	// _98 = BinOp(_8 BIT_OR _15)
	memcpy( &rv, &var98, sizeof(uint32_t ));
	goto bb35;
	// ^ Call( retval = "transmute"::<u32,f32,>( _98, ), bb35, bb4)
bb31:
	var30 = var27 < 1;	// _30 = BinOp(_27 LT +1 i32)
	if(var30) goto bb32; else goto bb33;
	// ^ If( _30 : 32, 33)
bb32:
	memcpy( &rv, &var15, sizeof(uint32_t ));
	goto bb35;
	// ^ Call( retval = "transmute"::<u32,f32,>( _15, ), bb35, bb4)
bb33:
	var54 = var26 << 0x1;	// _54 = BinOp(_26 BIT_SHL 0x1 u32)
	var55 = var54 > var17;	// _55 = BinOp(_54 GT _17)
	var28 = (uint32_t )var55;	// _28 = Cast(_55 as u32)
	var29 = var25 & var6;	// _29 = BinOp(_25 BIT_AND _6)
	var56 = & var29;	// _56 = Borrow(Unique, _29)
	var99 = (uint32_t )var27;	// _99 = Cast(_27 as u32)
	var100 = var99 << var2;	// _100 = BinOp(_99 BIT_SHL _2)
	(*var56) = (*var56) | var100;	// _56* = BinOp(_56* BIT_OR _100)
	// ^ drop(_56)
	var101 = var29;	// _101 = Use(_29)
	__builtin_add_overflow(var101, var28, &var29);
	// ^ Call( _29 = "overflowing_add"::<u32,>( _101, _28, ), bb34, bb4)
	var102 = var29 | var15;	// _102 = BinOp(_29 BIT_OR _15)
	memcpy( &rv, &var102, sizeof(uint32_t ));
	// ^ Call( retval = "transmute"::<u32,f32,>( _102, ), bb35, bb4)
bb35:
	return rv;
	// ^ Return
bb36:
	var103 = var11 | var9;	// _103 = BinOp(_11 BIT_OR _9)
	memcpy( &rv, &var103, sizeof(uint32_t ));
	goto bb35;
	// ^ Call( retval = "transmute"::<u32,f32,>( _103, ), bb35, bb4)
bb37:
	var30 = var20 > var8;	// _30 = BinOp(_20 GT _8)
	if(var30) goto bb38; else goto bb39;
	// ^ If( _30 : 38, 39)
bb38:
	var104 = var12 | var9;	// _104 = BinOp(_12 BIT_OR _9)
	memcpy( &rv, &var104, sizeof(uint32_t ));
	goto bb35;
	// ^ Call( retval = "transmute"::<u32,f32,>( _104, ), bb35, bb4)
bb39:
	var30 = var19 == var8;	// _30 = BinOp(_19 EQ _8)
	if(var30) goto bb40; else goto bb41;
	// ^ If( _30 : 40, 41)
bb40:
	var30 = var20 == var8;	// _30 = BinOp(_20 EQ _8)
	if(var30) goto bb52; else goto bb53;
	// ^ If( _30 : 52, 53)
bb41:
	var30 = var20 == var8;	// _30 = BinOp(_20 EQ _8)
	if(var30) goto bb32; else goto bb42;
	// ^ If( _30 : 32, 42)
bb42:
	var30 = var19 == var1;	// _30 = BinOp(_19 EQ _1)
	if(var30) goto bb43; else goto bb44;
	// ^ If( _30 : 43, 44)
bb43:
	var30 = var20 == var1;	// _30 = BinOp(_20 EQ _1)
	if(var30) goto bb52; else goto bb32;
	// ^ If( _30 : 52, 32)
bb44:
	var30 = var20 == var1;	// _30 = BinOp(_20 EQ _1)
	if(var30) goto bb45; else goto bb46;
	// ^ If( _30 : 45, 46)
bb45:
	var105 = var8 | var15;	// _105 = BinOp(_8 BIT_OR _15)
	memcpy( &rv, &var105, sizeof(uint32_t ));
	goto bb35;
	// ^ Call( retval = "transmute"::<u32,f32,>( _105, ), bb35, bb4)
bb46:
	var30 = var19 < var5;	// _30 = BinOp(_19 LT _5)
	if(var30) goto bb47; else goto bb49;
	// ^ If( _30 : 47, 49)
bb47:
	var35 = ZRQCn2cR25compiler_builtins0_0_0_Hb5float5Float0g9normalize0g( var16 );
	// ^ Call( _35 = <f32 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::normalize( _16, ), bb48, bb4)
	var16 = var35._1;	// _16 = Use(_35.1)
	var18 = var18 + var35._0;	// _18 = BinOp(_18 ADD _35.0)
	// ^ Goto(49)
bb49:
	var30 = var20 < var5;	// _30 = BinOp(_20 LT _5)
	if(var30) goto bb50; else goto bb8;
	// ^ If( _30 : 50, 8)
bb50:
	var36 = ZRQCn2cR25compiler_builtins0_0_0_Hb5float5Float0g9normalize0g( var17 );
	// ^ Call( _36 = <f32 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::normalize( _17, ), bb51, bb4)
	var17 = var36._1;	// _17 = Use(_36.1)
	var18 = var18 - var36._0;	// _18 = BinOp(_18 SUB _36.0)
	goto bb8;
	// ^ Goto(8)
bb52:
	memcpy( &rv, &var10, sizeof(uint32_t ));
	goto bb35;
	// ^ Call( retval = "transmute"::<u32,f32,>( _10, ), bb35, bb4)
bb53:
	var106 = var19 | var15;	// _106 = BinOp(_19 BIT_OR _15)
	memcpy( &rv, &var106, sizeof(uint32_t ));
	goto bb35;
	// ^ Call( retval = "transmute"::<u32,f32,>( _106, ), bb35, bb4)
}
// ::"compiler_builtins-0_0_0_Hb"::float::div::div64<f64,>
double  ZRG3cR25compiler_builtins0_0_0_Hb5float3div5div641gCo(
		double arg0, // f64
		double arg1 // f64
		) // -> f64

{
	double rv;
	uint64_t var0;	// u64
	uint64_t var1;	// u64
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	uint32_t var4;	// u32
	uint64_t var5;	// u64
	uint64_t var6;	// u64
	uint64_t var7;	// u64
	uint64_t var8;	// u64
	uint64_t var9;	// u64
	uint64_t var10;	// u64
	uint64_t var11;	// u64
	uint64_t var12;	// u64
	uint64_t var13;	// u64
	uint64_t var14;	// u64
	uint64_t var15;	// u64
	uint64_t var16;	// u64
	uint64_t var17;	// u64
	int32_t var18;	// i32
	uint64_t var19;	// u64
	uint64_t var20;	// u64
	int32_t var21;	// i32
	uint32_t var22;	// u32
	uint32_t var23;	// u32
	uint32_t var24;	// u32
	uint32_t var25;	// u32
	uint64_t var26;	// u64
	uint64_t var27;	// u64
	uint32_t var28;	// u32
	uint32_t var29;	// u32
	uint64_t var30;	// u64
	uint64_t var31;	// u64
	int32_t var32;	// i32
	uint32_t var33;	// u32
	uint64_t var34;	// u64
	RUST_BOOL var35;	// bool
	uint64_t var36;	// u64
	uint64_t var37;	// u64
	uint64_t var38;	// u64
	uint64_t var39;	// u64
	TUP_2_ZRTCf_ZRTCg var40;	// (i32, u64, )
	TUP_2_ZRTCf_ZRTCg var41;	// (i32, u64, )
	uint64_t *var42;	// &'#omitted mut u64
	uint64_t *var43;	// &'#omitted mut u64
	uint64_t var44;	// u64
	uint64_t var45;	// u64
	uint64_t var46;	// u64
	uint64_t var47;	// u64
	uint64_t var48;	// u64
	uint64_t var49;	// u64
	uint64_t var50;	// u64
	uint64_t var51;	// u64
	uint64_t var52;	// u64
	uint64_t var53;	// u64
	uint64_t var54;	// u64
	uint64_t var55;	// u64
	uint64_t var56;	// u64
	uint64_t var57;	// u64
	uint64_t var58;	// u64
	uint64_t var59;	// u64
	uint64_t *var60;	// &'#omitted mut u64
	int32_t var61;	// i32
	uint64_t var62;	// u64
	RUST_BOOL var63;	// bool
	uint64_t *var64;	// &'#omitted mut u64
	int32_t var65;	// i32
	uint64_t var66;	// u64
	uint64_t var67;	// u64
	TUP_2_ZRTCf_ZRTCw var68;	// (i32, bool, )
	int32_t var69;	// i32
	uint32_t var70;	// u32
	uint64_t var71;	// u64
	uint64_t var72;	// u64
	uint64_t var73;	// u64
	uint64_t var74;	// u64
	TUP_2_ZRTCf_ZRTCw var75;	// (i32, bool, )
	int32_t var76;	// i32
	uint32_t var77;	// u32
	uint64_t var78;	// u64
	uint64_t var79;	// u64
	uint64_t var80;	// u64
	uint64_t var81;	// u64
	TUP_2_ZRTCf_ZRTCw var82;	// (i32, bool, )
	int32_t var83;	// i32
	uint32_t var84;	// u32
	uint64_t var85;	// u64
	uint64_t var86;	// u64
	uint32_t var87;	// u32
	uint64_t var88;	// u64
	uint64_t var89;	// u64
	uint64_t var90;	// u64
	uint64_t var91;	// u64
	uint64_t var92;	// u64
	uint64_t var93;	// u64
	TUP_2_ZRTCh_ZRTCw var94;	// (i64, bool, )
	int64_t var95;	// i64
	uint64_t var96;	// u64
	uint64_t var97;	// u64
	uint64_t var98;	// u64
	uint64_t var99;	// u64
	uint64_t var100;	// u64
	uint64_t var101;	// u64
	uint64_t var102;	// u64
	uint64_t var103;	// u64
	int32_t var104;	// i32
	int32_t var105;	// i32
	uint64_t var106;	// u64
	uint64_t var107;	// u64
	uint64_t var108;	// u64
	uint64_t var109;	// u64
	uint64_t var110;	// u64
	uint64_t var111;	// u64
	uint32_t var112;	// u32
	uint32_t var113;	// u32
	int32_t var114;	// i32
	int32_t var115;	// i32
	uint64_t var116;	// u64
	uint64_t var117;	// u64
	uint128_t var118;	// u128
	uint128_t var119;	// u128
	uint128_t var120;	// u128
	uint128_t var121;	// u128
	uint64_t var122;	// u64
	uint32_t var123;	// u32
	uint64_t var124;	// u64
	uint64_t var125;	// u64
	uint64_t var126;	// u64
	uint64_t var127;	// u64
	uint64_t var128;	// u64
	uint64_t var129;	// u64
	uint64_t var130;	// u64
	uint64_t var131;	// u64
	uint64_t var132;	// u64
	uint64_t var133;	// u64
	uint64_t var134;	// u64
	uint64_t var135;	// u64
	uint64_t var136;	// u64
	uint64_t var137;	// u64
	uint64_t var138;	// u64
	var0 = 0x1ull;	// _0 = Constant(0x1 u64)
	var1 = 0x0ull;	// _1 = Constant(0x0 u64)
	var2 = 0x34;	// _2 = Constant(0x34 u32)
	var3 = 0x7ff;	// _3 = Constant(0x7ff u32)
	var4 = 0x3ff;	// _4 = Constant(0x3ff u32)
	var5 = 0x10000000000000ull;	// _5 = Constant(0x10000000000000 u64)
	var6 = 0xfffffffffffffull;	// _6 = Constant(0xfffffffffffff u64)
	var111 = 0x8000000000000000ull;	// _111 = Constant(0x8000000000000000 u64)
	var7 = 0x7fffffffffffffffull;	// _7 = Constant(0x7fffffffffffffff u64)
	var8 = 0x7ff0000000000000ull;	// _8 = Constant(0x7ff0000000000000 u64)
	var9 = 0x8000000000000ull;	// _9 = Constant(0x8000000000000 u64)
	var10 = 0x7ff8000000000000ull;	// _10 = Constant(0x7ff8000000000000 u64)
	memcpy( &var11, &arg0, sizeof(double ));
	// ^ Call( _11 = "transmute"::<f64,u64,>( a0, ), bb1, bb4)
	memcpy( &var12, &arg1, sizeof(double ));
	// ^ Call( _12 = "transmute"::<f64,u64,>( a1, ), bb2, bb4)
	var106 = var11 >> var2;	// _106 = BinOp(_11 BIT_SHR _2)
	var107 = (uint64_t )var3;	// _107 = Cast(_3 as u64)
	var13 = var106 & var107;	// _13 = BinOp(_106 BIT_AND _107)
	var108 = var12 >> var2;	// _108 = BinOp(_12 BIT_SHR _2)
	var109 = (uint64_t )var3;	// _109 = Cast(_3 as u64)
	var14 = var108 & var109;	// _14 = BinOp(_108 BIT_AND _109)
	var110 = var11 ^ var12;	// _110 = BinOp(_11 BIT_XOR _12)
	var15 = var110 & var111;	// _15 = BinOp(_110 BIT_AND _111)
	var16 = var11 & var6;	// _16 = BinOp(_11 BIT_AND _6)
	var17 = var12 & var6;	// _17 = BinOp(_12 BIT_AND _6)
	var18 = 0;	// _18 = Constant(+0 i32)
	__builtin_sub_overflow(var13, var0, &var36);
	// ^ Call( _36 = "overflowing_sub"::<u64,>( _13, _0, ), bb3, bb4)
	var112 = var3 - 0x1;	// _112 = BinOp(_3 SUB 0x1 u32)
	var37 = (uint64_t )var112;	// _37 = Cast(_112 as u64)
	var35 = var36 >= var37;	// _35 = BinOp(_36 GE _37)
	if(var35) goto bb7; else goto bb5;
	// ^ If( _35 : 7, 5)
bb4: _Unwind_Resume(); // Diverge
bb5:
	__builtin_sub_overflow(var14, var0, &var38);
	// ^ Call( _38 = "overflowing_sub"::<u64,>( _14, _0, ), bb6, bb4)
	var113 = var3 - 0x1;	// _113 = BinOp(_3 SUB 0x1 u32)
	var39 = (uint64_t )var113;	// _39 = Cast(_113 as u64)
	var35 = var38 >= var39;	// _35 = BinOp(_38 GE _39)
	if(var35) goto bb7; else goto bb8;
	// ^ If( _35 : 7, 8)
bb7:
	var19 = var11 & var7;	// _19 = BinOp(_11 BIT_AND _7)
	var20 = var12 & var7;	// _20 = BinOp(_12 BIT_AND _7)
	var35 = var19 > var8;	// _35 = BinOp(_19 GT _8)
	if(var35) goto bb44; else goto bb45;
	// ^ If( _35 : 44, 45)
bb8:
	var42 = & var16;	// _42 = Borrow(Unique, _16)
	(*var42) = (*var42) | var5;	// _42* = BinOp(_42* BIT_OR _5)
	// ^ drop(_42)
	var43 = & var17;	// _43 = Borrow(Unique, _17)
	(*var43) = (*var43) | var5;	// _43* = BinOp(_43* BIT_OR _5)
	// ^ drop(_43)
	var114 = (int32_t )var13;	// _114 = Cast(_13 as i32)
	var115 = (int32_t )var14;	// _115 = Cast(_14 as i32)
	__builtin_sub_overflow(var114, var115, &var65);
	// ^ Call( _65 = "overflowing_sub"::<i32,>( _114, _115, ), bb9, bb4)
	__builtin_add_overflow(var65, var18, &var21);
	// ^ Call( _21 = "overflowing_add"::<i32,>( _65, _18, ), bb10, bb4)
	var116 = var17 >> 0x15;	// _116 = BinOp(_17 BIT_SHR 0x15 u32)
	var22 = (uint32_t )var116;	// _22 = Cast(_116 as u32)
	__builtin_sub_overflow(0x7504f333, var22, &var23);
	// ^ Call( _23 = "overflowing_sub"::<u32,>( 0x7504f333 u32, _22, ), bb11, bb4)
	var66 = (uint64_t )var23;	// _66 = Cast(_23 as u64)
	var67 = (uint64_t )var22;	// _67 = Cast(_22 as u64)
	__builtin_mul_overflow(var66, var67, &var45);
	// ^ Call( _45 = "overflowing_mul"::<u64,>( _66, _67, ), bb12, bb4)
	var44 = var45 >> 32;	// _44 = BinOp(_45 BIT_SHR +32 i32)
	var70 = (uint32_t )var44;	// _70 = Cast(_44 as u32)
	var69 = (int32_t )var70;	// _69 = Cast(_70 as i32)
	var68 = ZRICf15overflowing_neg0g( var69 );
	// ^ Call( _68 = <i32 /*- */>::overflowing_neg( _69, ), bb13, bb4)
	var24 = (uint32_t )var68._0;	// _24 = Cast(_68.0 as u32)
	var71 = (uint64_t )var23;	// _71 = Cast(_23 as u64)
	var72 = (uint64_t )var24;	// _72 = Cast(_24 as u64)
	__builtin_mul_overflow(var71, var72, &var47);
	// ^ Call( _47 = "overflowing_mul"::<u64,>( _71, _72, ), bb14, bb4)
	var46 = var47 >> 31;	// _46 = BinOp(_47 BIT_SHR +31 i32)
	var23 = (uint32_t )var46;	// _23 = Cast(_46 as u32)
	var73 = (uint64_t )var23;	// _73 = Cast(_23 as u64)
	var74 = (uint64_t )var22;	// _74 = Cast(_22 as u64)
	__builtin_mul_overflow(var73, var74, &var49);
	// ^ Call( _49 = "overflowing_mul"::<u64,>( _73, _74, ), bb15, bb4)
	var48 = var49 >> 32;	// _48 = BinOp(_49 BIT_SHR +32 i32)
	var77 = (uint32_t )var48;	// _77 = Cast(_48 as u32)
	var76 = (int32_t )var77;	// _76 = Cast(_77 as i32)
	var75 = ZRICf15overflowing_neg0g( var76 );
	// ^ Call( _75 = <i32 /*- */>::overflowing_neg( _76, ), bb16, bb4)
	var24 = (uint32_t )var75._0;	// _24 = Cast(_75.0 as u32)
	var78 = (uint64_t )var23;	// _78 = Cast(_23 as u64)
	var79 = (uint64_t )var24;	// _79 = Cast(_24 as u64)
	__builtin_mul_overflow(var78, var79, &var51);
	// ^ Call( _51 = "overflowing_mul"::<u64,>( _78, _79, ), bb17, bb4)
	var50 = var51 >> 31;	// _50 = BinOp(_51 BIT_SHR +31 i32)
	var23 = (uint32_t )var50;	// _23 = Cast(_50 as u32)
	var80 = (uint64_t )var23;	// _80 = Cast(_23 as u64)
	var81 = (uint64_t )var22;	// _81 = Cast(_22 as u64)
	__builtin_mul_overflow(var80, var81, &var53);
	// ^ Call( _53 = "overflowing_mul"::<u64,>( _80, _81, ), bb18, bb4)
	var52 = var53 >> 32;	// _52 = BinOp(_53 BIT_SHR +32 i32)
	var84 = (uint32_t )var52;	// _84 = Cast(_52 as u32)
	var83 = (int32_t )var84;	// _83 = Cast(_84 as i32)
	var82 = ZRICf15overflowing_neg0g( var83 );
	// ^ Call( _82 = <i32 /*- */>::overflowing_neg( _83, ), bb19, bb4)
	var24 = (uint32_t )var82._0;	// _24 = Cast(_82.0 as u32)
	var85 = (uint64_t )var23;	// _85 = Cast(_23 as u64)
	var86 = (uint64_t )var24;	// _86 = Cast(_24 as u64)
	__builtin_mul_overflow(var85, var86, &var55);
	// ^ Call( _55 = "overflowing_mul"::<u64,>( _85, _86, ), bb20, bb4)
	var54 = var55 >> 31;	// _54 = BinOp(_55 BIT_SHR +31 i32)
	var23 = (uint32_t )var54;	// _23 = Cast(_54 as u32)
	var87 = var23;	// _87 = Use(_23)
	__builtin_sub_overflow(var87, 0x1, &var23);
	// ^ Call( _23 = "overflowing_sub"::<u32,>( _87, 0x1 u32, ), bb21, bb4)
	var117 = var17 << 0xb;	// _117 = BinOp(_17 BIT_SHL 0xb u32)
	var25 = (uint32_t )var117;	// _25 = Cast(_117 as u32)
	var88 = (uint64_t )var23;	// _88 = Cast(_23 as u64)
	var89 = (uint64_t )var22;	// _89 = Cast(_22 as u64)
	__builtin_mul_overflow(var88, var89, &var92);
	// ^ Call( _92 = "overflowing_mul"::<u64,>( _88, _89, ), bb22, bb4)
	var90 = (uint64_t )var23;	// _90 = Cast(_23 as u64)
	var91 = (uint64_t )var25;	// _91 = Cast(_25 as u64)
	__builtin_mul_overflow(var90, var91, &var56);
	// ^ Call( _56 = "overflowing_mul"::<u64,>( _90, _91, ), bb23, bb4)
	var93 = var56 >> 32;	// _93 = BinOp(_56 BIT_SHR +32 i32)
	__builtin_add_overflow(var92, var93, &var96);
	// ^ Call( _96 = "overflowing_add"::<u64,>( _92, _93, ), bb24, bb4)
	var95 = (int64_t )var96;	// _95 = Cast(_96 as i64)
	var94 = ZRICh15overflowing_neg0g( var95 );
	// ^ Call( _94 = <i64 /*- */>::overflowing_neg( _95, ), bb25, bb4)
	var26 = (uint64_t )var94._0;	// _26 = Cast(_94.0 as u64)
	var57 = var26 >> 32;	// _57 = BinOp(_26 BIT_SHR +32 i32)
	var28 = (uint32_t )var57;	// _28 = Cast(_57 as u32)
	var29 = (uint32_t )var26;	// _29 = Cast(_26 as u32)
	var97 = (uint64_t )var23;	// _97 = Cast(_23 as u64)
	var98 = (uint64_t )var28;	// _98 = Cast(_28 as u64)
	__builtin_mul_overflow(var97, var98, &var101);
	// ^ Call( _101 = "overflowing_mul"::<u64,>( _97, _98, ), bb26, bb4)
	var99 = (uint64_t )var23;	// _99 = Cast(_23 as u64)
	var100 = (uint64_t )var29;	// _100 = Cast(_29 as u64)
	__builtin_mul_overflow(var99, var100, &var58);
	// ^ Call( _58 = "overflowing_mul"::<u64,>( _99, _100, ), bb27, bb4)
	var102 = var58 >> 32;	// _102 = BinOp(_58 BIT_SHR +32 i32)
	__builtin_add_overflow(var101, var102, &var27);
	// ^ Call( _27 = "overflowing_add"::<u64,>( _101, _102, ), bb28, bb4)
	var103 = var27;	// _103 = Use(_27)
	__builtin_sub_overflow(var103, 0x2ull, &var27);
	// ^ Call( _27 = "overflowing_sub"::<u64,>( _103, 0x2 u64, ), bb29, bb4)
	var122 = var16 << 0x2;	// _122 = BinOp(_16 BIT_SHL 0x2 u32)
	var120.lo = var122; var120.hi = var122 < 0 ? -1 : 0;	// _120 = Cast(_122 as u128)
	var121.lo = var27; var121.hi = var27 < 0 ? -1 : 0;	// _121 = Cast(_27 as u128)
	mul128_o(var120, var121, &var118);
	// ^ Call( _118 = "overflowing_mul"::<u128,>( _120, _121, ), bb30, bb4)
	var119 = shr128(var118, 0x40ull);	// _119 = BinOp(_118 BIT_SHR 0x40 u64)
	var138 = var119.lo;	// _138 = Cast(_119 as u64)
	var30 = var138;	// _30 = Use(_138)
	var59 = var5 << 0x1;	// _59 = BinOp(_5 BIT_SHL 0x1 u32)
	var35 = var138 < var59;	// _35 = BinOp(_138 LT _59)
	if(var35) goto bb31; else goto bb34;
	// ^ If( _35 : 31, 34)
bb31:
	var104 = var21;	// _104 = Use(_21)
	__builtin_sub_overflow(var104, 1, &var21);
	// ^ Call( _21 = "overflowing_sub"::<i32,>( _104, +1 i32, ), bb32, bb4)
	var123 = var2 + 0x1;	// _123 = BinOp(_2 ADD 0x1 u32)
	var124 = var16 << var123;	// _124 = BinOp(_16 BIT_SHL _123)
	__builtin_mul_overflow(var30, var17, &var125);
	// ^ Call( _125 = "overflowing_mul"::<u64,>( _30, _17, ), bb33, bb4)
	__builtin_sub_overflow(var124, var125, &var31);
	goto bb36;
	// ^ Call( _31 = "overflowing_sub"::<u64,>( _124, _125, ), bb36, bb4)
bb34:
	var60 = & var30;	// _60 = Borrow(Unique, _30)
	(*var60) = (*var60) >> 0x1;	// _60* = BinOp(_60* BIT_SHR 0x1 u32)
	// ^ drop(_60)
	var126 = var16 << var2;	// _126 = BinOp(_16 BIT_SHL _2)
	__builtin_mul_overflow(var30, var17, &var127);
	// ^ Call( _127 = "overflowing_mul"::<u64,>( _30, _17, ), bb35, bb4)
	__builtin_sub_overflow(var126, var127, &var31);
	// ^ Call( _31 = "overflowing_sub"::<u64,>( _126, _127, ), bb36, bb4)
bb36:
	var105 = (int32_t )var4;	// _105 = Cast(_4 as i32)
	__builtin_add_overflow(var21, var105, &var32);
	// ^ Call( _32 = "overflowing_add"::<i32,>( _21, _105, ), bb37, bb4)
	var61 = (int32_t )var3;	// _61 = Cast(_3 as i32)
	var35 = var32 >= var61;	// _35 = BinOp(_32 GE _61)
	if(var35) goto bb38; else goto bb39;
	// ^ If( _35 : 38, 39)
bb38:
	var128 = var8 | var15;	// _128 = BinOp(_8 BIT_OR _15)
	memcpy( &rv, &var128, sizeof(uint64_t ));
	goto bb43;
	// ^ Call( retval = "transmute"::<u64,f64,>( _128, ), bb43, bb4)
bb39:
	var35 = var32 < 1;	// _35 = BinOp(_32 LT +1 i32)
	if(var35) goto bb40; else goto bb41;
	// ^ If( _35 : 40, 41)
bb40:
	memcpy( &rv, &var15, sizeof(uint64_t ));
	goto bb43;
	// ^ Call( retval = "transmute"::<u64,f64,>( _15, ), bb43, bb4)
bb41:
	var62 = var31 << 0x1;	// _62 = BinOp(_31 BIT_SHL 0x1 u32)
	var63 = var62 > var17;	// _63 = BinOp(_62 GT _17)
	var33 = (uint32_t )var63;	// _33 = Cast(_63 as u32)
	var34 = var30 & var6;	// _34 = BinOp(_30 BIT_AND _6)
	var64 = & var34;	// _64 = Borrow(Unique, _34)
	var129 = (uint64_t )var32;	// _129 = Cast(_32 as u64)
	var130 = var129 << var2;	// _130 = BinOp(_129 BIT_SHL _2)
	(*var64) = (*var64) | var130;	// _64* = BinOp(_64* BIT_OR _130)
	// ^ drop(_64)
	var132 = (uint64_t )var33;	// _132 = Cast(_33 as u64)
	var131 = var34;	// _131 = Use(_34)
	__builtin_add_overflow(var131, var132, &var34);
	// ^ Call( _34 = "overflowing_add"::<u64,>( _131, _132, ), bb42, bb4)
	var133 = var34 | var15;	// _133 = BinOp(_34 BIT_OR _15)
	memcpy( &rv, &var133, sizeof(uint64_t ));
	// ^ Call( retval = "transmute"::<u64,f64,>( _133, ), bb43, bb4)
bb43:
	return rv;
	// ^ Return
bb44:
	var134 = var11 | var9;	// _134 = BinOp(_11 BIT_OR _9)
	memcpy( &rv, &var134, sizeof(uint64_t ));
	goto bb43;
	// ^ Call( retval = "transmute"::<u64,f64,>( _134, ), bb43, bb4)
bb45:
	var35 = var20 > var8;	// _35 = BinOp(_20 GT _8)
	if(var35) goto bb46; else goto bb47;
	// ^ If( _35 : 46, 47)
bb46:
	var135 = var12 | var9;	// _135 = BinOp(_12 BIT_OR _9)
	memcpy( &rv, &var135, sizeof(uint64_t ));
	goto bb43;
	// ^ Call( retval = "transmute"::<u64,f64,>( _135, ), bb43, bb4)
bb47:
	var35 = var19 == var8;	// _35 = BinOp(_19 EQ _8)
	if(var35) goto bb48; else goto bb49;
	// ^ If( _35 : 48, 49)
bb48:
	var35 = var20 == var8;	// _35 = BinOp(_20 EQ _8)
	if(var35) goto bb60; else goto bb61;
	// ^ If( _35 : 60, 61)
bb49:
	var35 = var20 == var8;	// _35 = BinOp(_20 EQ _8)
	if(var35) goto bb40; else goto bb50;
	// ^ If( _35 : 40, 50)
bb50:
	var35 = var19 == var1;	// _35 = BinOp(_19 EQ _1)
	if(var35) goto bb51; else goto bb52;
	// ^ If( _35 : 51, 52)
bb51:
	var35 = var20 == var1;	// _35 = BinOp(_20 EQ _1)
	if(var35) goto bb60; else goto bb40;
	// ^ If( _35 : 60, 40)
bb52:
	var35 = var20 == var1;	// _35 = BinOp(_20 EQ _1)
	if(var35) goto bb53; else goto bb54;
	// ^ If( _35 : 53, 54)
bb53:
	var136 = var8 | var15;	// _136 = BinOp(_8 BIT_OR _15)
	memcpy( &rv, &var136, sizeof(uint64_t ));
	goto bb43;
	// ^ Call( retval = "transmute"::<u64,f64,>( _136, ), bb43, bb4)
bb54:
	var35 = var19 < var5;	// _35 = BinOp(_19 LT _5)
	if(var35) goto bb55; else goto bb57;
	// ^ If( _35 : 55, 57)
bb55:
	var40 = ZRQCo2cR25compiler_builtins0_0_0_Hb5float5Float0g9normalize0g( var16 );
	// ^ Call( _40 = <f64 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::normalize( _16, ), bb56, bb4)
	var16 = var40._1;	// _16 = Use(_40.1)
	var18 = var18 + var40._0;	// _18 = BinOp(_18 ADD _40.0)
	// ^ Goto(57)
bb57:
	var35 = var20 < var5;	// _35 = BinOp(_20 LT _5)
	if(var35) goto bb58; else goto bb8;
	// ^ If( _35 : 58, 8)
bb58:
	var41 = ZRQCo2cR25compiler_builtins0_0_0_Hb5float5Float0g9normalize0g( var17 );
	// ^ Call( _41 = <f64 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::normalize( _17, ), bb59, bb4)
	var17 = var41._1;	// _17 = Use(_41.1)
	var18 = var18 - var41._0;	// _18 = BinOp(_18 SUB _41.0)
	goto bb8;
	// ^ Goto(8)
bb60:
	memcpy( &rv, &var10, sizeof(uint64_t ));
	goto bb43;
	// ^ Call( retval = "transmute"::<u64,f64,>( _10, ), bb43, bb4)
bb61:
	var137 = var19 | var15;	// _137 = BinOp(_19 BIT_OR _15)
	memcpy( &rv, &var137, sizeof(uint64_t ));
	goto bb43;
	// ^ Call( retval = "transmute"::<u64,f64,>( _137, ), bb43, bb4)
}
// ::"compiler_builtins-0_0_0_Hb"::float::extend::__extendsfdf2
double  ZRG3cR25compiler_builtins0_0_0_Hb5float6extend13__extendsfdf20g(
		float arg0 // f32
		) // -> f64

{
	double rv;
	rv = ZRG3cR25compiler_builtins0_0_0_Hb5float6extend_C2gCnCo( arg0 );
	// ^ Call( retval = ::"compiler_builtins-0_0_0_Hb"::float::extend::extend<f32,f64,>( a0, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::extend::extend<f32,f64,>
double  ZRG3cR25compiler_builtins0_0_0_Hb5float6extend_C2gCnCo(
		float arg0 // f32
		) // -> f64

{
	double rv;
	uint32_t var0;	// u32
	uint32_t var1;	// u32
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	uint32_t var4;	// u32
	uint32_t var5;	// u32
	uint32_t var6;	// u32
	uint32_t var7;	// u32
	uint32_t var8;	// u32
	uint32_t var9;	// u32
	uint64_t var10;	// u64
	uint32_t var11;	// u32
	uint32_t var12;	// u32
	uint32_t var13;	// u32
	uint64_t var14;	// u64
	uint32_t var15;	// u32
	RUST_BOOL var16;	// bool
	uint32_t var17;	// u32
	uint32_t var18;	// u32
	uint64_t *var19;	// &'#omitted mut u64
	uint64_t *var20;	// &'#omitted mut u64
	uint64_t *var21;	// &'#omitted mut u64
	uint64_t var22;	// u64
	uint32_t var23;	// u32
	uint32_t var24;	// u32
	uint32_t var25;	// u32
	uint32_t var26;	// u32
	uint32_t var27;	// u32
	uint32_t *var28;	// &'#omitted u32
	uint32_t var29;	// u32
	uint64_t var30;	// u64
	uint64_t var31;	// u64
	uint32_t var32;	// u32
	uint64_t var33;	// u64
	uint64_t var34;	// u64
	uint64_t var35;	// u64
	uint32_t var36;	// u32
	uint32_t var37;	// u32
	uint32_t var38;	// u32
	uint64_t var39;	// u64
	uint64_t var40;	// u64
	uint32_t var41;	// u32
	uint64_t var42;	// u64
	uint64_t var43;	// u64
	uint64_t var44;	// u64
	uint32_t var45;	// u32
	uint64_t var46;	// u64
	uint64_t var47;	// u64
	uint32_t var48;	// u32
	uint32_t var49;	// u32
	uint64_t var50;	// u64
	uint64_t var51;	// u64
	uint32_t var52;	// u32
	uint32_t var53;	// u32
	uint64_t var54;	// u64
	uint64_t var55;	// u64
	uint64_t var56;	// u64
	uint64_t var57;	// u64
	uint32_t var58;	// u32
	uint32_t var59;	// u32
	uint32_t var60;	// u32
	uint64_t var61;	// u64
	uint64_t var62;	// u64
	uint32_t var63;	// u32
	uint64_t var64;	// u64
	uint64_t var65;	// u64
	var0 = 0x0;	// _0 = Constant(0x0 u32)
	var1 = 0x20;	// _1 = Constant(0x20 u32)
	var2 = 0x800000;	// _2 = Constant(0x800000 u32)
	var3 = 0x7f800000;	// _3 = Constant(0x7f800000 u32)
	var4 = 0x80000000;	// _4 = Constant(0x80000000 u32)
	var27 = 0x7fffffff;	// _27 = Constant(0x7fffffff u32)
	var5 = 0x7fffff;	// _5 = Constant(0x7fffff u32)
	var6 = 0x7ffffe;	// _6 = Constant(0x7ffffe u32)
	var7 = 0x40;	// _7 = Constant(0x40 u32)
	var8 = 0x34;	// _8 = Constant(0x34 u32)
	var9 = 0x7ff;	// _9 = Constant(0x7ff u32)
	var10 = 0x10000000000000ull;	// _10 = Constant(0x10000000000000 u64)
	var11 = 0x1d;	// _11 = Constant(0x1d u32)
	var12 = 0x380;	// _12 = Constant(0x380 u32)
	memcpy( &var26, &arg0, sizeof(float ));
	// ^ Call( _26 = "transmute"::<f32,u32,>( a0, ), bb1, bb4)
	var13 = var26 & var27;	// _13 = BinOp(_26 BIT_AND _27)
	var14 = 0x0ull;	// _14 = Constant(0x0 u64)
	__builtin_sub_overflow(var13, var2, &var17);
	// ^ Call( _17 = "overflowing_sub"::<u32,>( _13, _2, ), bb2, bb4)
	var28 = & var17;	// _28 = Borrow(Shared, _17)
	__builtin_sub_overflow(var3, var2, &var18);
	// ^ Call( _18 = "overflowing_sub"::<u32,>( _3, _2, ), bb3, bb4)
	var16 = (*var28) < var18;	// _16 = BinOp(_28* LT _18)
	if(var16) goto bb5; else goto bb8;
	// ^ If( _16 : 5, 8)
bb4: _Unwind_Resume(); // Diverge
bb5:
	var31 = (uint64_t )var13;	// _31 = Cast(_13 as u64)
	var34 = (uint64_t )var12;	// _34 = Cast(_12 as u64)
	var29 = var11 & 0x3f;	// _29 = BinOp(_11 BIT_AND 0x3f u32)
	var30 = (uint64_t )var29;	// _30 = Cast(_29 as u64)
	var14 = var31 << var30;
	// ^ Call( _14 = "unchecked_shl"::<u64,>( _31, _30, ), bb6, bb4)
	var19 = & var14;	// _19 = Borrow(Unique, _14)
	var32 = var8 & 0x3f;	// _32 = BinOp(_8 BIT_AND 0x3f u32)
	var33 = (uint64_t )var32;	// _33 = Cast(_32 as u64)
	var35 = var34 << var33;
	// ^ Call( _35 = "unchecked_shl"::<u64,>( _34, _33, ), bb7, bb4)
	(*var19) = (*var19) + var35;	// _19* = BinOp(_19* ADD _35)
	// ^ drop(_19)
	goto bb19;
	// ^ Goto(19)
bb8:
	var16 = var13 >= var3;	// _16 = BinOp(_13 GE _3)
	if(var16) goto bb9; else goto bb13;
	// ^ If( _16 : 9, 13)
bb9:
	var36 = var13 & var5;	// _36 = BinOp(_13 BIT_AND _5)
	var43 = (uint64_t )var36;	// _43 = Cast(_36 as u64)
	var37 = var13 & var6;	// _37 = BinOp(_13 BIT_AND _6)
	var22 = (uint64_t )var37;	// _22 = Cast(_37 as u64)
	var40 = (uint64_t )var9;	// _40 = Cast(_9 as u64)
	var38 = var8 & 0x3f;	// _38 = BinOp(_8 BIT_AND 0x3f u32)
	var39 = (uint64_t )var38;	// _39 = Cast(_38 as u64)
	var14 = var40 << var39;
	// ^ Call( _14 = "unchecked_shl"::<u64,>( _40, _39, ), bb10, bb4)
	var20 = & var14;	// _20 = Borrow(Unique, _14)
	var41 = var11 & 0x3f;	// _41 = BinOp(_11 BIT_AND 0x3f u32)
	var42 = (uint64_t )var41;	// _42 = Cast(_41 as u64)
	var44 = var43 << var42;
	// ^ Call( _44 = "unchecked_shl"::<u64,>( _43, _42, ), bb11, bb4)
	(*var20) = (*var20) | var44;	// _20* = BinOp(_20* BIT_OR _44)
	// ^ drop(_20)
	var21 = & var14;	// _21 = Borrow(Unique, _14)
	var45 = var11 & 0x3f;	// _45 = BinOp(_11 BIT_AND 0x3f u32)
	var46 = (uint64_t )var45;	// _46 = Cast(_45 as u64)
	var47 = var22 << var46;
	// ^ Call( _47 = "unchecked_shl"::<u64,>( _22, _46, ), bb12, bb4)
	(*var21) = (*var21) | var47;	// _21* = BinOp(_21* BIT_OR _47)
	// ^ drop(_21)
	goto bb19;
	// ^ Goto(19)
bb13:
	var16 = var13 != var0;	// _16 = BinOp(_13 NE _0)
	if(var16) goto bb14; else goto bb19;
	// ^ If( _16 : 14, 19)
bb14:
	var23 = (var13 != 0 ? __builtin_clz(var13) : sizeof(uint32_t )*8);
	// ^ Call( _23 = "ctlz"::<u32,>( _13, ), bb15, bb4)
	var24 = (var2 != 0 ? __builtin_clz(var2) : sizeof(uint32_t )*8);
	// ^ Call( _24 = "ctlz"::<u32,>( _2, ), bb16, bb4)
	var15 = var23 - var24;	// _15 = BinOp(_23 SUB _24)
	var51 = (uint64_t )var13;	// _51 = Cast(_13 as u64)
	var25 = var12 - var15;	// _25 = BinOp(_12 SUB _15)
	var48 = var25 + 0x1;	// _48 = BinOp(_25 ADD 0x1 u32)
	var55 = (uint64_t )var48;	// _55 = Cast(_48 as u64)
	var52 = var11 + var15;	// _52 = BinOp(_11 ADD _15)
	var49 = var52 & 0x3f;	// _49 = BinOp(_52 BIT_AND 0x3f u32)
	var50 = (uint64_t )var49;	// _50 = Cast(_49 as u64)
	var14 = var51 << var50;
	// ^ Call( _14 = "unchecked_shl"::<u64,>( _51, _50, ), bb17, bb4)
	var56 = var14 ^ var10;	// _56 = BinOp(_14 BIT_XOR _10)
	var53 = var8 & 0x3f;	// _53 = BinOp(_8 BIT_AND 0x3f u32)
	var54 = (uint64_t )var53;	// _54 = Cast(_53 as u64)
	var57 = var55 << var54;
	// ^ Call( _57 = "unchecked_shl"::<u64,>( _55, _54, ), bb18, bb4)
	var14 = var56 | var57;	// _14 = BinOp(_56 BIT_OR _57)
	// ^ Goto(19)
bb19:
	memcpy( &var58, &arg0, sizeof(float ));
	// ^ Call( _58 = "transmute"::<f32,u32,>( a0, ), bb20, bb4)
	var59 = var58 & var4;	// _59 = BinOp(_58 BIT_AND _4)
	var62 = (uint64_t )var59;	// _62 = Cast(_59 as u64)
	var63 = var7 - var1;	// _63 = BinOp(_7 SUB _1)
	var60 = var63 & 0x3f;	// _60 = BinOp(_63 BIT_AND 0x3f u32)
	var61 = (uint64_t )var60;	// _61 = Cast(_60 as u64)
	var64 = var62 << var61;
	// ^ Call( _64 = "unchecked_shl"::<u64,>( _62, _61, ), bb21, bb4)
	var65 = var14 | var64;	// _65 = BinOp(_14 BIT_OR _64)
	memcpy( &rv, &var65, sizeof(uint64_t ));
	// ^ Call( retval = "transmute"::<u64,f64,>( _65, ), bb22, bb4)
	return rv;
	// ^ Return
}
// ::"compiler_builtins-0_0_0_Hb"::float::mul::__muldf3
double  ZRG3cR25compiler_builtins0_0_0_Hb5float3mul8__muldf30g(
		double arg0, // f64
		double arg1 // f64
		) // -> f64

{
	double rv;
	rv = ZRG3cR25compiler_builtins0_0_0_Hb5float3mul_C1gCo( arg0, arg1 );
	// ^ Call( retval = ::"compiler_builtins-0_0_0_Hb"::float::mul::mul<f64,>( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::mul::__mulsf3
float  ZRG3cR25compiler_builtins0_0_0_Hb5float3mul8__mulsf30g(
		float arg0, // f32
		float arg1 // f32
		) // -> f32

{
	float rv;
	rv = ZRG3cR25compiler_builtins0_0_0_Hb5float3mul_C1gCn( arg0, arg1 );
	// ^ Call( retval = ::"compiler_builtins-0_0_0_Hb"::float::mul::mul<f32,>( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::mul::mul<f32,>
float  ZRG3cR25compiler_builtins0_0_0_Hb5float3mul_C1gCn(
		float arg0, // f32
		float arg1 // f32
		) // -> f32

{
	float rv;
	uint32_t var0;	// u32
	uint32_t var1;	// u32
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	uint32_t var4;	// u32
	uint32_t var5;	// u32
	uint32_t var6;	// u32
	uint32_t var7;	// u32
	uint32_t var8;	// u32
	uint32_t var9;	// u32
	uint32_t var10;	// u32
	uint32_t var11;	// u32
	uint32_t var12;	// u32
	uint32_t var13;	// u32
	uint32_t var14;	// u32
	uint32_t var15;	// u32
	uint32_t var16;	// u32
	uint32_t var17;	// u32
	uint32_t var18;	// u32
	uint32_t var19;	// u32
	uint32_t var20;	// u32
	int32_t var21;	// i32
	uint32_t var22;	// u32
	uint32_t var23;	// u32
	uint32_t var24;	// u32
	uint32_t var25;	// u32
	int32_t var26;	// i32
	int32_t var27;	// i32
	RUST_BOOL var28;	// bool
	uint32_t var29;	// u32
	uint32_t var30;	// u32
	uint32_t var31;	// u32
	uint32_t var32;	// u32
	TUP_2_ZRTCf_ZRTCe var33;	// (i32, u32, )
	TUP_2_ZRTCf_ZRTCe var34;	// (i32, u32, )
	uint32_t *var35;	// &'#omitted mut u32
	uint32_t *var36;	// &'#omitted mut u32
	uint32_t var37;	// u32
	uint32_t *var38;	// &'#omitted mut u32
	uint32_t *var39;	// &'#omitted mut u32
	int32_t var40;	// i32
	tUNIT var41 = {0};	// ()
	int32_t var42;	// i32
	uint32_t *var43;	// &'#omitted mut u32
	uint32_t *var44;	// &'#omitted mut u32
	uint32_t *var45;	// &'#omitted mut u32
	uint32_t *var46;	// &'#omitted mut u32
	uint32_t *var47;	// &'#omitted mut u32
	uint32_t *var48;	// &'#omitted mut u32
	uint32_t *var49;	// &'#omitted mut u32
	int32_t var50;	// i32
	int32_t var51;	// i32
	int32_t var52;	// i32
	int32_t var53;	// i32
	uint32_t var54;	// u32
	uint32_t var55;	// u32
	uint32_t var56;	// u32
	uint64_t var57;	// u64
	uint64_t var58;	// u64
	uint64_t var59;	// u64
	uint64_t var60;	// u64
	uint32_t var61;	// u32
	int32_t var62;	// i32
	int32_t var63;	// i32
	uint32_t var64;	// u32
	uint32_t var65;	// u32
	uint32_t var66;	// u32
	uint32_t var67;	// u32
	uint32_t var68;	// u32
	uint32_t var69;	// u32
	uint32_t var70;	// u32
	uint32_t var71;	// u32
	uint32_t var72;	// u32
	uint32_t var73;	// u32
	uint32_t var74;	// u32
	uint32_t var75;	// u32
	var0 = 0x1;	// _0 = Constant(0x1 u32)
	var1 = 0x0;	// _1 = Constant(0x0 u32)
	var2 = 0x20;	// _2 = Constant(0x20 u32)
	var3 = 0x17;	// _3 = Constant(0x17 u32)
	var4 = 0xff;	// _4 = Constant(0xff u32)
	var5 = 0x7f;	// _5 = Constant(0x7f u32)
	var6 = 0x800000;	// _6 = Constant(0x800000 u32)
	var7 = 0x7fffff;	// _7 = Constant(0x7fffff u32)
	var8 = 0x80000000;	// _8 = Constant(0x80000000 u32)
	var9 = 0x7fffffff;	// _9 = Constant(0x7fffffff u32)
	var10 = 0x7f800000;	// _10 = Constant(0x7f800000 u32)
	var11 = 0x400000;	// _11 = Constant(0x400000 u32)
	var12 = 0x7fc00000;	// _12 = Constant(0x7fc00000 u32)
	var13 = 0x8;	// _13 = Constant(0x8 u32)
	memcpy( &var14, &arg0, sizeof(float ));
	// ^ Call( _14 = "transmute"::<f32,u32,>( a0, ), bb1, bb4)
	memcpy( &var15, &arg1, sizeof(float ));
	// ^ Call( _15 = "transmute"::<f32,u32,>( a1, ), bb2, bb4)
	var54 = var14 >> var3;	// _54 = BinOp(_14 BIT_SHR _3)
	var16 = var54 & var4;	// _16 = BinOp(_54 BIT_AND _4)
	var55 = var15 >> var3;	// _55 = BinOp(_15 BIT_SHR _3)
	var17 = var55 & var4;	// _17 = BinOp(_55 BIT_AND _4)
	var56 = var14 ^ var15;	// _56 = BinOp(_14 BIT_XOR _15)
	var18 = var56 & var8;	// _18 = BinOp(_56 BIT_AND _8)
	var19 = var14 & var7;	// _19 = BinOp(_14 BIT_AND _7)
	var20 = var15 & var7;	// _20 = BinOp(_15 BIT_AND _7)
	var21 = 0;	// _21 = Constant(+0 i32)
	__builtin_sub_overflow(var16, var0, &var29);
	// ^ Call( _29 = "overflowing_sub"::<u32,>( _16, _0, ), bb3, bb4)
	var30 = var4 - 0x1;	// _30 = BinOp(_4 SUB 0x1 u32)
	var28 = var29 >= var30;	// _28 = BinOp(_29 GE _30)
	if(var28) goto bb7; else goto bb5;
	// ^ If( _28 : 7, 5)
bb4: _Unwind_Resume(); // Diverge
bb5:
	__builtin_sub_overflow(var17, var0, &var31);
	// ^ Call( _31 = "overflowing_sub"::<u32,>( _17, _0, ), bb6, bb4)
	var32 = var4 - 0x1;	// _32 = BinOp(_4 SUB 0x1 u32)
	var28 = var31 >= var32;	// _28 = BinOp(_31 GE _32)
	if(var28) goto bb7; else goto bb8;
	// ^ If( _28 : 7, 8)
bb7:
	var22 = var14 & var9;	// _22 = BinOp(_14 BIT_AND _9)
	var23 = var15 & var9;	// _23 = BinOp(_15 BIT_AND _9)
	var28 = var22 > var10;	// _28 = BinOp(_22 GT _10)
	if(var28) goto bb29; else goto bb30;
	// ^ If( _28 : 29, 30)
bb8:
	var35 = & var19;	// _35 = Borrow(Unique, _19)
	(*var35) = (*var35) | var6;	// _35* = BinOp(_35* BIT_OR _6)
	// ^ drop(_35)
	var36 = & var20;	// _36 = Borrow(Unique, _20)
	(*var36) = (*var36) | var6;	// _36* = BinOp(_36* BIT_OR _6)
	// ^ drop(_36)
	var61 = var20 << var13;	// _61 = BinOp(_20 BIT_SHL _13)
	var59 = (uint64_t )var19;	// _59 = Cast(_19 as u64)
	var60 = (uint64_t )var61;	// _60 = Cast(_61 as u64)
	__builtin_mul_overflow(var59, var60, &var57);
	// ^ Call( _57 = "overflowing_mul"::<u64,>( _59, _60, ), bb9, bb4)
	var58 = var57 >> 0x20;	// _58 = BinOp(_57 BIT_SHR 0x20 u32)
	var24 = (uint32_t )var58;	// _24 = Cast(_58 as u32)
	var25 = (uint32_t )var57;	// _25 = Cast(_57 as u32)
	var62 = (int32_t )var16;	// _62 = Cast(_16 as i32)
	var63 = (int32_t )var17;	// _63 = Cast(_17 as i32)
	__builtin_add_overflow(var62, var63, &var50);
	// ^ Call( _50 = "overflowing_add"::<i32,>( _62, _63, ), bb10, bb4)
	__builtin_add_overflow(var50, var21, &var51);
	// ^ Call( _51 = "overflowing_add"::<i32,>( _50, _21, ), bb11, bb4)
	var52 = (int32_t )var5;	// _52 = Cast(_5 as i32)
	__builtin_sub_overflow(var51, var52, &var26);
	// ^ Call( _26 = "overflowing_sub"::<i32,>( _51, _52, ), bb12, bb4)
	var37 = var24 & var6;	// _37 = BinOp(_24 BIT_AND _6)
	var28 = var37 != var1;	// _28 = BinOp(_37 NE _1)
	if(var28) goto bb13; else goto bb14;
	// ^ If( _28 : 13, 14)
bb13:
	var53 = var26;	// _53 = Use(_26)
	__builtin_add_overflow(var53, 1, &var26);
	goto bb15;
	// ^ Call( _26 = "overflowing_add"::<i32,>( _53, +1 i32, ), bb15, bb4)
bb14:
	var38 = & var24;	// _38 = Borrow(Unique, _24)
	var39 = & var25;	// _39 = Borrow(Unique, _25)
	var64 = (*var38) << 1;	// _64 = BinOp(_38* BIT_SHL +1 i32)
	var65 = (*var39) >> 31;	// _65 = BinOp(_39* BIT_SHR +31 i32)
	(*var38) = var64 | var65;	// _38* = BinOp(_64 BIT_OR _65)
	(*var39) = (*var39) << 1;	// _39* = BinOp(_39* BIT_SHL +1 i32)
	// ^ drop(_38)
	// ^ drop(_39)
	// ^ Goto(15)
bb15:
	var40 = (int32_t )var4;	// _40 = Cast(_4 as i32)
	var28 = var26 >= var40;	// _28 = BinOp(_26 GE _40)
	if(var28) goto bb16; else goto bb17;
	// ^ If( _28 : 16, 17)
bb16:
	var66 = var10 | var18;	// _66 = BinOp(_10 BIT_OR _18)
	memcpy( &rv, &var66, sizeof(uint32_t ));
	goto bb26;
	// ^ Call( retval = "transmute"::<u32,f32,>( _66, ), bb26, bb4)
bb17:
	var28 = var26 <= 0;	// _28 = BinOp(_26 LE +0 i32)
	if(var28) goto bb18; else goto bb20;
	// ^ If( _28 : 18, 20)
bb18:
	var67 = (uint32_t )var26;	// _67 = Cast(_26 as u32)
	__builtin_sub_overflow(var0, var67, &var68);
	// ^ Call( _68 = "overflowing_sub"::<u32,>( _0, _67, ), bb19, bb4)
	var27 = (int32_t )var68;	// _27 = Cast(_68 as i32)
	var42 = (int32_t )var2;	// _42 = Cast(_2 as i32)
	var28 = var27 >= var42;	// _28 = BinOp(_27 GE _42)
	if(var28) goto bb27; else goto bb28;
	// ^ If( _28 : 27, 28)
bb20:
	var45 = & var24;	// _45 = Borrow(Unique, _24)
	(*var45) = (*var45) & var7;	// _45* = BinOp(_45* BIT_AND _7)
	// ^ drop(_45)
	var46 = & var24;	// _46 = Borrow(Unique, _24)
	var69 = (uint32_t )var26;	// _69 = Cast(_26 as u32)
	var70 = var69 << var3;	// _70 = BinOp(_69 BIT_SHL _3)
	(*var46) = (*var46) | var70;	// _46* = BinOp(_46* BIT_OR _70)
	// ^ drop(_46)
	/* ZST assign */
	// ^ Goto(21)
bb21:
	var47 = & var24;	// _47 = Borrow(Unique, _24)
	(*var47) = (*var47) | var18;	// _47* = BinOp(_47* BIT_OR _18)
	// ^ drop(_47)
	var28 = var25 > var8;	// _28 = BinOp(_25 GT _8)
	if(var28) goto bb22; else goto bb23;
	// ^ If( _28 : 22, 23)
bb22:
	var48 = & var24;	// _48 = Borrow(Unique, _24)
	(*var48) = (*var48) + var0;	// _48* = BinOp(_48* ADD _0)
	// ^ drop(_48)
	// ^ Goto(23)
bb23:
	var28 = var25 == var8;	// _28 = BinOp(_25 EQ _8)
	if(var28) goto bb24; else goto bb25;
	// ^ If( _28 : 24, 25)
bb24:
	var49 = & var24;	// _49 = Borrow(Unique, _24)
	var71 = var24 & var0;	// _71 = BinOp(_24 BIT_AND _0)
	(*var49) = (*var49) + var71;	// _49* = BinOp(_49* ADD _71)
	// ^ drop(_49)
	// ^ Goto(25)
bb25:
	memcpy( &rv, &var24, sizeof(uint32_t ));
	// ^ Call( retval = "transmute"::<u32,f32,>( _24, ), bb26, bb4)
bb26:
	return rv;
	// ^ Return
bb27:
	memcpy( &rv, &var18, sizeof(uint32_t ));
	goto bb26;
	// ^ Call( retval = "transmute"::<u32,f32,>( _18, ), bb26, bb4)
bb28:
	var43 = & var24;	// _43 = Borrow(Unique, _24)
	var44 = & var25;	// _44 = Borrow(Unique, _25)
	ZRQCe2cR25compiler_builtins0_0_0_Hb3int7WideInt0g28wide_shift_right_with_sticky0g( var43, var44, var27 );
	goto bb21;
	// ^ Call( _41 = <u32 as ::"compiler_builtins-0_0_0_Hb"::int::WideInt>::wide_shift_right_with_sticky<'#local2,'#local3,>( _43, _44, _27, ), bb21, bb4)
bb29:
	var72 = var14 | var11;	// _72 = BinOp(_14 BIT_OR _11)
	memcpy( &rv, &var72, sizeof(uint32_t ));
	goto bb26;
	// ^ Call( retval = "transmute"::<u32,f32,>( _72, ), bb26, bb4)
bb30:
	var28 = var23 > var10;	// _28 = BinOp(_23 GT _10)
	if(var28) goto bb31; else goto bb32;
	// ^ If( _28 : 31, 32)
bb31:
	var73 = var15 | var11;	// _73 = BinOp(_15 BIT_OR _11)
	memcpy( &rv, &var73, sizeof(uint32_t ));
	goto bb26;
	// ^ Call( retval = "transmute"::<u32,f32,>( _73, ), bb26, bb4)
bb32:
	var28 = var22 == var10;	// _28 = BinOp(_22 EQ _10)
	if(var28) goto bb33; else goto bb34;
	// ^ If( _28 : 33, 34)
bb33:
	var28 = var23 != var1;	// _28 = BinOp(_23 NE _1)
	if(var28) goto bb46; else goto bb45;
	// ^ If( _28 : 46, 45)
bb34:
	var28 = var23 == var10;	// _28 = BinOp(_23 EQ _10)
	if(var28) goto bb35; else goto bb36;
	// ^ If( _28 : 35, 36)
bb35:
	var28 = var22 != var1;	// _28 = BinOp(_22 NE _1)
	if(var28) goto bb44; else goto bb45;
	// ^ If( _28 : 44, 45)
bb36:
	var28 = var22 == var1;	// _28 = BinOp(_22 EQ _1)
	if(var28) goto bb27; else goto bb37;
	// ^ If( _28 : 27, 37)
bb37:
	var28 = var23 == var1;	// _28 = BinOp(_23 EQ _1)
	if(var28) goto bb27; else goto bb38;
	// ^ If( _28 : 27, 38)
bb38:
	var28 = var22 < var6;	// _28 = BinOp(_22 LT _6)
	if(var28) goto bb39; else goto bb41;
	// ^ If( _28 : 39, 41)
bb39:
	var33 = ZRQCn2cR25compiler_builtins0_0_0_Hb5float5Float0g9normalize0g( var19 );
	// ^ Call( _33 = <f32 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::normalize( _19, ), bb40, bb4)
	var19 = var33._1;	// _19 = Use(_33.1)
	var21 = var21 + var33._0;	// _21 = BinOp(_21 ADD _33.0)
	// ^ Goto(41)
bb41:
	var28 = var23 < var6;	// _28 = BinOp(_23 LT _6)
	if(var28) goto bb42; else goto bb8;
	// ^ If( _28 : 42, 8)
bb42:
	var34 = ZRQCn2cR25compiler_builtins0_0_0_Hb5float5Float0g9normalize0g( var20 );
	// ^ Call( _34 = <f32 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::normalize( _20, ), bb43, bb4)
	var20 = var34._1;	// _20 = Use(_34.1)
	var21 = var21 + var34._0;	// _21 = BinOp(_21 ADD _34.0)
	goto bb8;
	// ^ Goto(8)
bb44:
	var74 = var23 | var18;	// _74 = BinOp(_23 BIT_OR _18)
	memcpy( &rv, &var74, sizeof(uint32_t ));
	goto bb26;
	// ^ Call( retval = "transmute"::<u32,f32,>( _74, ), bb26, bb4)
bb45:
	memcpy( &rv, &var12, sizeof(uint32_t ));
	goto bb26;
	// ^ Call( retval = "transmute"::<u32,f32,>( _12, ), bb26, bb4)
bb46:
	var75 = var22 | var18;	// _75 = BinOp(_22 BIT_OR _18)
	memcpy( &rv, &var75, sizeof(uint32_t ));
	goto bb26;
	// ^ Call( retval = "transmute"::<u32,f32,>( _75, ), bb26, bb4)
}
// ::"compiler_builtins-0_0_0_Hb"::float::mul::mul<f64,>
double  ZRG3cR25compiler_builtins0_0_0_Hb5float3mul_C1gCo(
		double arg0, // f64
		double arg1 // f64
		) // -> f64

{
	double rv;
	uint64_t var0;	// u64
	uint64_t var1;	// u64
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	uint32_t var4;	// u32
	uint32_t var5;	// u32
	uint64_t var6;	// u64
	uint64_t var7;	// u64
	uint64_t var8;	// u64
	uint64_t var9;	// u64
	uint64_t var10;	// u64
	uint64_t var11;	// u64
	uint64_t var12;	// u64
	uint32_t var13;	// u32
	uint64_t var14;	// u64
	uint64_t var15;	// u64
	uint64_t var16;	// u64
	uint64_t var17;	// u64
	uint64_t var18;	// u64
	uint64_t var19;	// u64
	uint64_t var20;	// u64
	int32_t var21;	// i32
	uint64_t var22;	// u64
	uint64_t var23;	// u64
	uint64_t var24;	// u64
	uint64_t var25;	// u64
	int32_t var26;	// i32
	int32_t var27;	// i32
	RUST_BOOL var28;	// bool
	uint64_t var29;	// u64
	uint64_t var30;	// u64
	uint64_t var31;	// u64
	uint64_t var32;	// u64
	TUP_2_ZRTCf_ZRTCg var33;	// (i32, u64, )
	TUP_2_ZRTCf_ZRTCg var34;	// (i32, u64, )
	uint64_t *var35;	// &'#omitted mut u64
	uint64_t *var36;	// &'#omitted mut u64
	uint64_t var37;	// u64
	uint64_t *var38;	// &'#omitted mut u64
	uint64_t *var39;	// &'#omitted mut u64
	int32_t var40;	// i32
	tUNIT var41 = {0};	// ()
	int32_t var42;	// i32
	uint64_t *var43;	// &'#omitted mut u64
	uint64_t *var44;	// &'#omitted mut u64
	uint64_t *var45;	// &'#omitted mut u64
	uint64_t *var46;	// &'#omitted mut u64
	uint64_t *var47;	// &'#omitted mut u64
	uint64_t *var48;	// &'#omitted mut u64
	uint64_t *var49;	// &'#omitted mut u64
	int32_t var50;	// i32
	int32_t var51;	// i32
	int32_t var52;	// i32
	int32_t var53;	// i32
	uint64_t var54;	// u64
	uint64_t var55;	// u64
	uint64_t var56;	// u64
	uint64_t var57;	// u64
	uint64_t var58;	// u64
	uint32_t var59;	// u32
	uint32_t var60;	// u32
	uint128_t var61;	// u128
	uint128_t var62;	// u128
	uint128_t var63;	// u128
	uint128_t var64;	// u128
	uint64_t var65;	// u64
	int32_t var66;	// i32
	int32_t var67;	// i32
	uint64_t var68;	// u64
	uint64_t var69;	// u64
	uint64_t var70;	// u64
	uint64_t var71;	// u64
	uint64_t var72;	// u64
	uint64_t var73;	// u64
	uint64_t var74;	// u64
	uint64_t var75;	// u64
	uint64_t var76;	// u64
	uint64_t var77;	// u64
	uint64_t var78;	// u64
	uint64_t var79;	// u64
	var0 = 0x1ull;	// _0 = Constant(0x1 u64)
	var1 = 0x0ull;	// _1 = Constant(0x0 u64)
	var2 = 0x40;	// _2 = Constant(0x40 u32)
	var3 = 0x34;	// _3 = Constant(0x34 u32)
	var4 = 0x7ff;	// _4 = Constant(0x7ff u32)
	var5 = 0x3ff;	// _5 = Constant(0x3ff u32)
	var6 = 0x10000000000000ull;	// _6 = Constant(0x10000000000000 u64)
	var7 = 0xfffffffffffffull;	// _7 = Constant(0xfffffffffffff u64)
	var8 = 0x8000000000000000ull;	// _8 = Constant(0x8000000000000000 u64)
	var9 = 0x7fffffffffffffffull;	// _9 = Constant(0x7fffffffffffffff u64)
	var10 = 0x7ff0000000000000ull;	// _10 = Constant(0x7ff0000000000000 u64)
	var11 = 0x8000000000000ull;	// _11 = Constant(0x8000000000000 u64)
	var12 = 0x7ff8000000000000ull;	// _12 = Constant(0x7ff8000000000000 u64)
	var13 = 0xb;	// _13 = Constant(0xb u32)
	memcpy( &var14, &arg0, sizeof(double ));
	// ^ Call( _14 = "transmute"::<f64,u64,>( a0, ), bb1, bb4)
	memcpy( &var15, &arg1, sizeof(double ));
	// ^ Call( _15 = "transmute"::<f64,u64,>( a1, ), bb2, bb4)
	var54 = var14 >> var3;	// _54 = BinOp(_14 BIT_SHR _3)
	var55 = (uint64_t )var4;	// _55 = Cast(_4 as u64)
	var16 = var54 & var55;	// _16 = BinOp(_54 BIT_AND _55)
	var56 = var15 >> var3;	// _56 = BinOp(_15 BIT_SHR _3)
	var57 = (uint64_t )var4;	// _57 = Cast(_4 as u64)
	var17 = var56 & var57;	// _17 = BinOp(_56 BIT_AND _57)
	var58 = var14 ^ var15;	// _58 = BinOp(_14 BIT_XOR _15)
	var18 = var58 & var8;	// _18 = BinOp(_58 BIT_AND _8)
	var19 = var14 & var7;	// _19 = BinOp(_14 BIT_AND _7)
	var20 = var15 & var7;	// _20 = BinOp(_15 BIT_AND _7)
	var21 = 0;	// _21 = Constant(+0 i32)
	__builtin_sub_overflow(var16, var0, &var29);
	// ^ Call( _29 = "overflowing_sub"::<u64,>( _16, _0, ), bb3, bb4)
	var59 = var4 - 0x1;	// _59 = BinOp(_4 SUB 0x1 u32)
	var30 = (uint64_t )var59;	// _30 = Cast(_59 as u64)
	var28 = var29 >= var30;	// _28 = BinOp(_29 GE _30)
	if(var28) goto bb7; else goto bb5;
	// ^ If( _28 : 7, 5)
bb4: _Unwind_Resume(); // Diverge
bb5:
	__builtin_sub_overflow(var17, var0, &var31);
	// ^ Call( _31 = "overflowing_sub"::<u64,>( _17, _0, ), bb6, bb4)
	var60 = var4 - 0x1;	// _60 = BinOp(_4 SUB 0x1 u32)
	var32 = (uint64_t )var60;	// _32 = Cast(_60 as u64)
	var28 = var31 >= var32;	// _28 = BinOp(_31 GE _32)
	if(var28) goto bb7; else goto bb8;
	// ^ If( _28 : 7, 8)
bb7:
	var22 = var14 & var9;	// _22 = BinOp(_14 BIT_AND _9)
	var23 = var15 & var9;	// _23 = BinOp(_15 BIT_AND _9)
	var28 = var22 > var10;	// _28 = BinOp(_22 GT _10)
	if(var28) goto bb29; else goto bb30;
	// ^ If( _28 : 29, 30)
bb8:
	var35 = & var19;	// _35 = Borrow(Unique, _19)
	(*var35) = (*var35) | var6;	// _35* = BinOp(_35* BIT_OR _6)
	// ^ drop(_35)
	var36 = & var20;	// _36 = Borrow(Unique, _20)
	(*var36) = (*var36) | var6;	// _36* = BinOp(_36* BIT_OR _6)
	// ^ drop(_36)
	var65 = var20 << var13;	// _65 = BinOp(_20 BIT_SHL _13)
	var63.lo = var19; var63.hi = var19 < 0 ? -1 : 0;	// _63 = Cast(_19 as u128)
	var64.lo = var65; var64.hi = var65 < 0 ? -1 : 0;	// _64 = Cast(_65 as u128)
	mul128_o(var63, var64, &var61);
	// ^ Call( _61 = "overflowing_mul"::<u128,>( _63, _64, ), bb9, bb4)
	var62 = shr128(var61, 0x40ull);	// _62 = BinOp(_61 BIT_SHR 0x40 u64)
	var24 = var62.lo;	// _24 = Cast(_62 as u64)
	var25 = var61.lo;	// _25 = Cast(_61 as u64)
	var66 = (int32_t )var16;	// _66 = Cast(_16 as i32)
	var67 = (int32_t )var17;	// _67 = Cast(_17 as i32)
	__builtin_add_overflow(var66, var67, &var50);
	// ^ Call( _50 = "overflowing_add"::<i32,>( _66, _67, ), bb10, bb4)
	__builtin_add_overflow(var50, var21, &var51);
	// ^ Call( _51 = "overflowing_add"::<i32,>( _50, _21, ), bb11, bb4)
	var52 = (int32_t )var5;	// _52 = Cast(_5 as i32)
	__builtin_sub_overflow(var51, var52, &var26);
	// ^ Call( _26 = "overflowing_sub"::<i32,>( _51, _52, ), bb12, bb4)
	var37 = var24 & var6;	// _37 = BinOp(_24 BIT_AND _6)
	var28 = var37 != var1;	// _28 = BinOp(_37 NE _1)
	if(var28) goto bb13; else goto bb14;
	// ^ If( _28 : 13, 14)
bb13:
	var53 = var26;	// _53 = Use(_26)
	__builtin_add_overflow(var53, 1, &var26);
	goto bb15;
	// ^ Call( _26 = "overflowing_add"::<i32,>( _53, +1 i32, ), bb15, bb4)
bb14:
	var38 = & var24;	// _38 = Borrow(Unique, _24)
	var39 = & var25;	// _39 = Borrow(Unique, _25)
	var68 = (*var38) << 1;	// _68 = BinOp(_38* BIT_SHL +1 i32)
	var69 = (*var39) >> 63;	// _69 = BinOp(_39* BIT_SHR +63 i32)
	(*var38) = var68 | var69;	// _38* = BinOp(_68 BIT_OR _69)
	(*var39) = (*var39) << 1;	// _39* = BinOp(_39* BIT_SHL +1 i32)
	// ^ drop(_38)
	// ^ drop(_39)
	// ^ Goto(15)
bb15:
	var40 = (int32_t )var4;	// _40 = Cast(_4 as i32)
	var28 = var26 >= var40;	// _28 = BinOp(_26 GE _40)
	if(var28) goto bb16; else goto bb17;
	// ^ If( _28 : 16, 17)
bb16:
	var70 = var10 | var18;	// _70 = BinOp(_10 BIT_OR _18)
	memcpy( &rv, &var70, sizeof(uint64_t ));
	goto bb26;
	// ^ Call( retval = "transmute"::<u64,f64,>( _70, ), bb26, bb4)
bb17:
	var28 = var26 <= 0;	// _28 = BinOp(_26 LE +0 i32)
	if(var28) goto bb18; else goto bb20;
	// ^ If( _28 : 18, 20)
bb18:
	var71 = (uint64_t )var26;	// _71 = Cast(_26 as u64)
	__builtin_sub_overflow(var0, var71, &var72);
	// ^ Call( _72 = "overflowing_sub"::<u64,>( _0, _71, ), bb19, bb4)
	var27 = (int32_t )var72;	// _27 = Cast(_72 as i32)
	var42 = (int32_t )var2;	// _42 = Cast(_2 as i32)
	var28 = var27 >= var42;	// _28 = BinOp(_27 GE _42)
	if(var28) goto bb27; else goto bb28;
	// ^ If( _28 : 27, 28)
bb20:
	var45 = & var24;	// _45 = Borrow(Unique, _24)
	(*var45) = (*var45) & var7;	// _45* = BinOp(_45* BIT_AND _7)
	// ^ drop(_45)
	var46 = & var24;	// _46 = Borrow(Unique, _24)
	var73 = (uint64_t )var26;	// _73 = Cast(_26 as u64)
	var74 = var73 << var3;	// _74 = BinOp(_73 BIT_SHL _3)
	(*var46) = (*var46) | var74;	// _46* = BinOp(_46* BIT_OR _74)
	// ^ drop(_46)
	/* ZST assign */
	// ^ Goto(21)
bb21:
	var47 = & var24;	// _47 = Borrow(Unique, _24)
	(*var47) = (*var47) | var18;	// _47* = BinOp(_47* BIT_OR _18)
	// ^ drop(_47)
	var28 = var25 > var8;	// _28 = BinOp(_25 GT _8)
	if(var28) goto bb22; else goto bb23;
	// ^ If( _28 : 22, 23)
bb22:
	var48 = & var24;	// _48 = Borrow(Unique, _24)
	(*var48) = (*var48) + var0;	// _48* = BinOp(_48* ADD _0)
	// ^ drop(_48)
	// ^ Goto(23)
bb23:
	var28 = var25 == var8;	// _28 = BinOp(_25 EQ _8)
	if(var28) goto bb24; else goto bb25;
	// ^ If( _28 : 24, 25)
bb24:
	var49 = & var24;	// _49 = Borrow(Unique, _24)
	var75 = var24 & var0;	// _75 = BinOp(_24 BIT_AND _0)
	(*var49) = (*var49) + var75;	// _49* = BinOp(_49* ADD _75)
	// ^ drop(_49)
	// ^ Goto(25)
bb25:
	memcpy( &rv, &var24, sizeof(uint64_t ));
	// ^ Call( retval = "transmute"::<u64,f64,>( _24, ), bb26, bb4)
bb26:
	return rv;
	// ^ Return
bb27:
	memcpy( &rv, &var18, sizeof(uint64_t ));
	goto bb26;
	// ^ Call( retval = "transmute"::<u64,f64,>( _18, ), bb26, bb4)
bb28:
	var43 = & var24;	// _43 = Borrow(Unique, _24)
	var44 = & var25;	// _44 = Borrow(Unique, _25)
	ZRQCg2cR25compiler_builtins0_0_0_Hb3int7WideInt0g28wide_shift_right_with_sticky0g( var43, var44, var27 );
	goto bb21;
	// ^ Call( _41 = <u64 as ::"compiler_builtins-0_0_0_Hb"::int::WideInt>::wide_shift_right_with_sticky<'#local2,'#local3,>( _43, _44, _27, ), bb21, bb4)
bb29:
	var76 = var14 | var11;	// _76 = BinOp(_14 BIT_OR _11)
	memcpy( &rv, &var76, sizeof(uint64_t ));
	goto bb26;
	// ^ Call( retval = "transmute"::<u64,f64,>( _76, ), bb26, bb4)
bb30:
	var28 = var23 > var10;	// _28 = BinOp(_23 GT _10)
	if(var28) goto bb31; else goto bb32;
	// ^ If( _28 : 31, 32)
bb31:
	var77 = var15 | var11;	// _77 = BinOp(_15 BIT_OR _11)
	memcpy( &rv, &var77, sizeof(uint64_t ));
	goto bb26;
	// ^ Call( retval = "transmute"::<u64,f64,>( _77, ), bb26, bb4)
bb32:
	var28 = var22 == var10;	// _28 = BinOp(_22 EQ _10)
	if(var28) goto bb33; else goto bb34;
	// ^ If( _28 : 33, 34)
bb33:
	var28 = var23 != var1;	// _28 = BinOp(_23 NE _1)
	if(var28) goto bb46; else goto bb45;
	// ^ If( _28 : 46, 45)
bb34:
	var28 = var23 == var10;	// _28 = BinOp(_23 EQ _10)
	if(var28) goto bb35; else goto bb36;
	// ^ If( _28 : 35, 36)
bb35:
	var28 = var22 != var1;	// _28 = BinOp(_22 NE _1)
	if(var28) goto bb44; else goto bb45;
	// ^ If( _28 : 44, 45)
bb36:
	var28 = var22 == var1;	// _28 = BinOp(_22 EQ _1)
	if(var28) goto bb27; else goto bb37;
	// ^ If( _28 : 27, 37)
bb37:
	var28 = var23 == var1;	// _28 = BinOp(_23 EQ _1)
	if(var28) goto bb27; else goto bb38;
	// ^ If( _28 : 27, 38)
bb38:
	var28 = var22 < var6;	// _28 = BinOp(_22 LT _6)
	if(var28) goto bb39; else goto bb41;
	// ^ If( _28 : 39, 41)
bb39:
	var33 = ZRQCo2cR25compiler_builtins0_0_0_Hb5float5Float0g9normalize0g( var19 );
	// ^ Call( _33 = <f64 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::normalize( _19, ), bb40, bb4)
	var19 = var33._1;	// _19 = Use(_33.1)
	var21 = var21 + var33._0;	// _21 = BinOp(_21 ADD _33.0)
	// ^ Goto(41)
bb41:
	var28 = var23 < var6;	// _28 = BinOp(_23 LT _6)
	if(var28) goto bb42; else goto bb8;
	// ^ If( _28 : 42, 8)
bb42:
	var34 = ZRQCo2cR25compiler_builtins0_0_0_Hb5float5Float0g9normalize0g( var20 );
	// ^ Call( _34 = <f64 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::normalize( _20, ), bb43, bb4)
	var20 = var34._1;	// _20 = Use(_34.1)
	var21 = var21 + var34._0;	// _21 = BinOp(_21 ADD _34.0)
	goto bb8;
	// ^ Goto(8)
bb44:
	var78 = var23 | var18;	// _78 = BinOp(_23 BIT_OR _18)
	memcpy( &rv, &var78, sizeof(uint64_t ));
	goto bb26;
	// ^ Call( retval = "transmute"::<u64,f64,>( _78, ), bb26, bb4)
bb45:
	memcpy( &rv, &var12, sizeof(uint64_t ));
	goto bb26;
	// ^ Call( retval = "transmute"::<u64,f64,>( _12, ), bb26, bb4)
bb46:
	var79 = var22 | var18;	// _79 = BinOp(_22 BIT_OR _18)
	memcpy( &rv, &var79, sizeof(uint64_t ));
	goto bb26;
	// ^ Call( retval = "transmute"::<u64,f64,>( _79, ), bb26, bb4)
}
// ::"compiler_builtins-0_0_0_Hb"::float::pow::__powidf2
double  ZRG3cR25compiler_builtins0_0_0_Hb5float3pow9__powidf20g(
		double arg0, // f64
		int32_t arg1 // i32
		) // -> f64

{
	double rv;
	rv = ZRQCo3cR25compiler_builtins0_0_0_Hb5float3pow3Pow0g_C0g( arg0, arg1 );
	// ^ Call( retval = <f64 as ::"compiler_builtins-0_0_0_Hb"::float::pow::Pow>::pow( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::pow::__powisf2
float  ZRG3cR25compiler_builtins0_0_0_Hb5float3pow9__powisf20g(
		float arg0, // f32
		int32_t arg1 // i32
		) // -> f32

{
	float rv;
	rv = ZRQCn3cR25compiler_builtins0_0_0_Hb5float3pow3Pow0g_C0g( arg0, arg1 );
	// ^ Call( retval = <f32 as ::"compiler_builtins-0_0_0_Hb"::float::pow::Pow>::pow( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::sub::__subdf3
double  ZRG3cR25compiler_builtins0_0_0_Hb5float3sub8__subdf30g(
		double arg0, // f64
		double arg1 // f64
		) // -> f64

{
	double rv;
	uint64_t var0;	// u64
	uint64_t var1;	// u64
	double var2;	// f64
	memcpy( &var0, &arg1, sizeof(double ));
	// ^ Call( _0 = "transmute"::<f64,u64,>( a1, ), bb1, bb4)
	var1 = var0 ^ 0x8000000000000000ull;	// _1 = BinOp(_0 BIT_XOR 0x8000000000000000 u64)
	memcpy( &var2, &var1, sizeof(uint64_t ));
	// ^ Call( _2 = "transmute"::<u64,f64,>( _1, ), bb2, bb4)
	rv = ZRG3cR25compiler_builtins0_0_0_Hb5float3add_C1gCo( arg0, var2 );
	// ^ Call( retval = ::"compiler_builtins-0_0_0_Hb"::float::add::add<f64,>( a0, _2, ), bb3, bb4)
	return rv;
	// ^ Return
bb4: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::float::sub::__subsf3
float  ZRG3cR25compiler_builtins0_0_0_Hb5float3sub8__subsf30g(
		float arg0, // f32
		float arg1 // f32
		) // -> f32

{
	float rv;
	uint32_t var0;	// u32
	uint32_t var1;	// u32
	float var2;	// f32
	memcpy( &var0, &arg1, sizeof(float ));
	// ^ Call( _0 = "transmute"::<f32,u32,>( a1, ), bb1, bb4)
	var1 = var0 ^ 0x80000000;	// _1 = BinOp(_0 BIT_XOR 0x80000000 u32)
	memcpy( &var2, &var1, sizeof(uint32_t ));
	// ^ Call( _2 = "transmute"::<u32,f32,>( _1, ), bb2, bb4)
	rv = ZRG3cR25compiler_builtins0_0_0_Hb5float3add_C1gCn( arg0, var2 );
	// ^ Call( retval = ::"compiler_builtins-0_0_0_Hb"::float::add::add<f32,>( a0, _2, ), bb3, bb4)
	return rv;
	// ^ Return
bb4: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::addsub::rust_i128_add
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int6addsub13rust_i128_add0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128

{
	int128_t rv;
	uint128_t var0;	// u128
	uint128_t var1;	// u128
	uint128_t var2;	// u128
	var1.lo = arg0.lo; var1.hi = arg0.hi;	// _1 = Cast(a0 as u128)
	var2.lo = arg1.lo; var2.hi = arg1.hi;	// _2 = Cast(a1 as u128)
	var0 = ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub7UAddSub0g4uadd0g( var1, var2 );
	// ^ Call( _0 = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::UAddSub>::uadd( _1, _2, ), bb1, bb2)
	rv.lo = var0.lo; rv.hi = var0.hi;	// retval = Cast(_0 as i128)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::addsub::rust_i128_addo
TUP_2_ZRTCj_ZRTCw  ZRG3cR25compiler_builtins0_0_0_Hb3int6addsub14rust_i128_addo0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> (i128, bool, )

{
	TUP_2_ZRTCj_ZRTCw rv;
	int32_t var0;	// i32
	int32_t *var1;	// &'#local0 mut i32
	int128_t var2;	// i128
	RUST_BOOL var3;	// bool
	var0 = 0;	// _0 = Constant(+0 i32)
	var1 = & var0;	// _1 = Borrow(Unique, _0)
	var2 = ZRQCj3cR25compiler_builtins0_0_0_Hb3int6addsub4Addo0g4addo0g( arg0, arg1, var1 );
	// ^ Call( _2 = <i128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::Addo>::addo<'#local0,>( a0, a1, _1, ), bb1, bb2)
	var3 = var0 != 0;	// _3 = BinOp(_0 NE +0 i32)
	;
	rv._0 = var2;
	rv._1 = var3;	// retval = Tuple(_2, _3)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::addsub::rust_i128_sub
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int6addsub13rust_i128_sub0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128

{
	int128_t rv;
	uint128_t var0;	// u128
	uint128_t var1;	// u128
	uint128_t var2;	// u128
	var1.lo = arg0.lo; var1.hi = arg0.hi;	// _1 = Cast(a0 as u128)
	var2.lo = arg1.lo; var2.hi = arg1.hi;	// _2 = Cast(a1 as u128)
	var0 = ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub7UAddSub0g4usub0g( var1, var2 );
	// ^ Call( _0 = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::UAddSub>::usub( _1, _2, ), bb1, bb2)
	rv.lo = var0.lo; rv.hi = var0.hi;	// retval = Cast(_0 as i128)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::addsub::rust_i128_subo
TUP_2_ZRTCj_ZRTCw  ZRG3cR25compiler_builtins0_0_0_Hb3int6addsub14rust_i128_subo0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> (i128, bool, )

{
	TUP_2_ZRTCj_ZRTCw rv;
	int32_t var0;	// i32
	int32_t *var1;	// &'#local0 mut i32
	int128_t var2;	// i128
	RUST_BOOL var3;	// bool
	var0 = 0;	// _0 = Constant(+0 i32)
	var1 = & var0;	// _1 = Borrow(Unique, _0)
	var2 = ZRQCj3cR25compiler_builtins0_0_0_Hb3int6addsub4Subo0g4subo0g( arg0, arg1, var1 );
	// ^ Call( _2 = <i128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::Subo>::subo<'#local0,>( a0, a1, _1, ), bb1, bb2)
	var3 = var0 != 0;	// _3 = BinOp(_0 NE +0 i32)
	;
	rv._0 = var2;
	rv._1 = var3;	// retval = Tuple(_2, _3)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::addsub::rust_u128_add
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int6addsub13rust_u128_add0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128

{
	uint128_t rv;
	rv = ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub7UAddSub0g4uadd0g( arg0, arg1 );
	// ^ Call( retval = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::UAddSub>::uadd( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::addsub::rust_u128_addo
TUP_2_ZRTCi_ZRTCw  ZRG3cR25compiler_builtins0_0_0_Hb3int6addsub14rust_u128_addo0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> (u128, bool, )

{
	TUP_2_ZRTCi_ZRTCw rv;
	int32_t var0;	// i32
	int32_t *var1;	// &'#local0 mut i32
	uint128_t var2;	// u128
	RUST_BOOL var3;	// bool
	var0 = 0;	// _0 = Constant(+0 i32)
	var1 = & var0;	// _1 = Borrow(Unique, _0)
	var2 = ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub4Addo0g4addo0g( arg0, arg1, var1 );
	// ^ Call( _2 = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::Addo>::addo<'#local0,>( a0, a1, _1, ), bb1, bb2)
	var3 = var0 != 0;	// _3 = BinOp(_0 NE +0 i32)
	;
	rv._0 = var2;
	rv._1 = var3;	// retval = Tuple(_2, _3)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::addsub::rust_u128_sub
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int6addsub13rust_u128_sub0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128

{
	uint128_t rv;
	rv = ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub7UAddSub0g4usub0g( arg0, arg1 );
	// ^ Call( retval = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::UAddSub>::usub( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::addsub::rust_u128_subo
TUP_2_ZRTCi_ZRTCw  ZRG3cR25compiler_builtins0_0_0_Hb3int6addsub14rust_u128_subo0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> (u128, bool, )

{
	TUP_2_ZRTCi_ZRTCw rv;
	int32_t var0;	// i32
	int32_t *var1;	// &'#local0 mut i32
	uint128_t var2;	// u128
	RUST_BOOL var3;	// bool
	var0 = 0;	// _0 = Constant(+0 i32)
	var1 = & var0;	// _1 = Borrow(Unique, _0)
	var2 = ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub4Subo0g4subo0g( arg0, arg1, var1 );
	// ^ Call( _2 = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::Subo>::subo<'#local0,>( a0, a1, _1, ), bb1, bb2)
	var3 = var0 != 0;	// _3 = BinOp(_0 NE +0 i32)
	;
	rv._0 = var2;
	rv._1 = var3;	// retval = Tuple(_2, _3)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::mul::__muldi3
uint64_t  ZRG3cR25compiler_builtins0_0_0_Hb3int3mul8__muldi30g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64

{
	uint64_t rv;
	rv = ZRQCg3cR25compiler_builtins0_0_0_Hb3int3mul3Mul0g_C0g( arg0, arg1 );
	// ^ Call( retval = <u64 as ::"compiler_builtins-0_0_0_Hb"::int::mul::Mul>::mul( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::mul::__mulodi4
int64_t  ZRG3cR25compiler_builtins0_0_0_Hb3int3mul9__mulodi40g(
		int64_t arg0, // i64
		int64_t arg1, // i64
		int32_t *arg2 // &'#omitted mut i32
		) // -> i64

{
	int64_t rv;
	rv = ZRQCh3cR25compiler_builtins0_0_0_Hb3int3mul4Mulo0g4mulo0g( arg0, arg1, arg2 );
	// ^ Call( retval = <i64 as ::"compiler_builtins-0_0_0_Hb"::int::mul::Mulo>::mulo<'M0,>( a0, a1, a2, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::mul::__mulosi4
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb3int3mul9__mulosi40g(
		int32_t arg0, // i32
		int32_t arg1, // i32
		int32_t *arg2 // &'#omitted mut i32
		) // -> i32

{
	int32_t rv;
	rv = ZRQCf3cR25compiler_builtins0_0_0_Hb3int3mul4Mulo0g4mulo0g( arg0, arg1, arg2 );
	// ^ Call( retval = <i32 as ::"compiler_builtins-0_0_0_Hb"::int::mul::Mulo>::mulo<'M0,>( a0, a1, a2, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::mul::__muloti4
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int3mul9__muloti40g(
		int128_t arg0, // i128
		int128_t arg1, // i128
		int32_t *arg2 // &'#omitted mut i32
		) // -> i128

{
	int128_t rv;
	rv = ZRQCj3cR25compiler_builtins0_0_0_Hb3int3mul4Mulo0g4mulo0g( arg0, arg1, arg2 );
	// ^ Call( retval = <i128 as ::"compiler_builtins-0_0_0_Hb"::int::mul::Mulo>::mulo<'M0,>( a0, a1, a2, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::mul::__multi3
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int3mul8__multi30g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128

{
	int128_t rv;
	rv = ZRQCj3cR25compiler_builtins0_0_0_Hb3int3mul3Mul0g_C0g( arg0, arg1 );
	// ^ Call( retval = <i128 as ::"compiler_builtins-0_0_0_Hb"::int::mul::Mul>::mul( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::mul::rust_i128_mul
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int3mul13rust_i128_mul0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128

{
	int128_t rv;
	rv = ZRQCj3cR25compiler_builtins0_0_0_Hb3int3mul3Mul0g_C0g( arg0, arg1 );
	// ^ Call( retval = <i128 as ::"compiler_builtins-0_0_0_Hb"::int::mul::Mul>::mul( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::mul::rust_i128_mulo
TUP_2_ZRTCj_ZRTCw  ZRG3cR25compiler_builtins0_0_0_Hb3int3mul14rust_i128_mulo0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> (i128, bool, )

{
	TUP_2_ZRTCj_ZRTCw rv;
	int32_t var0;	// i32
	RUST_BOOL var1;	// bool
	int128_t var2;	// i128
	int32_t *var3;	// &'#local0 mut i32
	var0 = 0;	// _0 = Constant(+0 i32)
	var3 = & var0;	// _3 = Borrow(Unique, _0)
	var2 = ZRQCj3cR25compiler_builtins0_0_0_Hb3int3mul4Mulo0g4mulo0g( arg0, arg1, var3 );
	// ^ Call( _2 = <i128 as ::"compiler_builtins-0_0_0_Hb"::int::mul::Mulo>::mulo<'#local0,>( a0, a1, _3, ), bb1, bb2)
	var1 = var0 != 0;	// _1 = BinOp(_0 NE +0 i32)
	;
	rv._0 = var2;
	rv._1 = var1;	// retval = Tuple(_2, _1)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::mul::rust_u128_mul
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int3mul13rust_u128_mul0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128

{
	uint128_t rv;
	int128_t var0;	// i128
	int128_t var1;	// i128
	int128_t var2;	// i128
	var1.lo = arg0.lo; var1.hi = arg0.hi;	// _1 = Cast(a0 as i128)
	var2.lo = arg1.lo; var2.hi = arg1.hi;	// _2 = Cast(a1 as i128)
	var0 = ZRQCj3cR25compiler_builtins0_0_0_Hb3int3mul3Mul0g_C0g( var1, var2 );
	// ^ Call( _0 = <i128 as ::"compiler_builtins-0_0_0_Hb"::int::mul::Mul>::mul( _1, _2, ), bb1, bb2)
	rv.lo = var0.lo; rv.hi = var0.hi;	// retval = Cast(_0 as u128)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::mul::rust_u128_mulo
TUP_2_ZRTCi_ZRTCw  ZRG3cR25compiler_builtins0_0_0_Hb3int3mul14rust_u128_mulo0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> (u128, bool, )

{
	TUP_2_ZRTCi_ZRTCw rv;
	int32_t var0;	// i32
	int32_t *var1;	// &'#local0 mut i32
	uint128_t var2;	// u128
	RUST_BOOL var3;	// bool
	var0 = 0;	// _0 = Constant(+0 i32)
	var1 = & var0;	// _1 = Borrow(Unique, _0)
	var2 = ZRQCi3cR25compiler_builtins0_0_0_Hb3int3mul5UMulo0g4mulo0g( arg0, arg1, var1 );
	// ^ Call( _2 = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::mul::UMulo>::mulo<'#local0,>( a0, a1, _1, ), bb1, bb2)
	var3 = var0 != 0;	// _3 = BinOp(_0 NE +0 i32)
	;
	rv._0 = var2;
	rv._1 = var3;	// retval = Tuple(_2, _3)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::sdiv::__divdi3
int64_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv8__divdi30g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64

{
	int64_t rv;
	rv = ZRQCh3cR25compiler_builtins0_0_0_Hb3int4sdiv3Div0g3div0g( arg0, arg1 );
	// ^ Call( retval = <i64 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Div>::div( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::sdiv::__divmoddi4
int64_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv11__divmoddi40g(
		int64_t arg0, // i64
		int64_t arg1, // i64
		int64_t *arg2 // &'#omitted mut i64
		) // -> i64

{
	int64_t rv;
	struct s_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmoddi4_10g var0 = {0};	// ::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmoddi4_1/*S*/
	/* ZST assign */
	{
		struct s_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmoddi4_10g zarg3 = {0};
		rv = ZRQCh3cR25compiler_builtins0_0_0_Hb3int4sdiv6Divmod0g6divmod1gG3c_A_B_CH20closure__divmoddi4_10g( arg0, arg1, arg2, zarg3 );
	}
	// ^ Call( retval = <i64 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Divmod>::divmod<'M0,::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmoddi4_1/*S*/,>( a0, a1, a2, _0, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::sdiv::__divmodsi4
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv11__divmodsi40g(
		int32_t arg0, // i32
		int32_t arg1, // i32
		int32_t *arg2 // &'#omitted mut i32
		) // -> i32

{
	int32_t rv;
	struct s_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmodsi4_00g var0 = {0};	// ::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmodsi4_0/*S*/
	/* ZST assign */
	{
		struct s_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmodsi4_00g zarg3 = {0};
		rv = ZRQCf3cR25compiler_builtins0_0_0_Hb3int4sdiv6Divmod0g6divmod1gG3c_A_B_CH20closure__divmodsi4_00g( arg0, arg1, arg2, zarg3 );
	}
	// ^ Call( retval = <i32 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Divmod>::divmod<'M0,::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmodsi4_0/*S*/,>( a0, a1, a2, _0, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::sdiv::__divsi3
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv8__divsi30g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32

{
	int32_t rv;
	rv = ZRQCf3cR25compiler_builtins0_0_0_Hb3int4sdiv3Div0g3div0g( arg0, arg1 );
	// ^ Call( retval = <i32 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Div>::div( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::sdiv::__divti3
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv8__divti30g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128

{
	int128_t rv;
	rv = ZRQCj3cR25compiler_builtins0_0_0_Hb3int4sdiv3Div0g3div0g( arg0, arg1 );
	// ^ Call( retval = <i128 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Div>::div( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::sdiv::__moddi3
int64_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv8__moddi30g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64

{
	int64_t rv;
	rv = ZRQCh3cR25compiler_builtins0_0_0_Hb3int4sdiv3Mod0g4mod_0g( arg0, arg1 );
	// ^ Call( retval = <i64 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Mod>::mod_( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::sdiv::__modsi3
int32_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv8__modsi30g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32

{
	int32_t rv;
	rv = ZRQCf3cR25compiler_builtins0_0_0_Hb3int4sdiv3Mod0g4mod_0g( arg0, arg1 );
	// ^ Call( retval = <i32 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Mod>::mod_( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::sdiv::__modti3
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv8__modti30g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128

{
	int128_t rv;
	rv = ZRQCj3cR25compiler_builtins0_0_0_Hb3int4sdiv3Mod0g4mod_0g( arg0, arg1 );
	// ^ Call( retval = <i128 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Mod>::mod_( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::sdiv::rust_i128_div
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv13rust_i128_div0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128

{
	int128_t rv;
	rv = ZRQCj3cR25compiler_builtins0_0_0_Hb3int4sdiv3Div0g3div0g( arg0, arg1 );
	// ^ Call( retval = <i128 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Div>::div( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::sdiv::rust_i128_rem
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4sdiv13rust_i128_rem0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128

{
	int128_t rv;
	rv = ZRQCj3cR25compiler_builtins0_0_0_Hb3int4sdiv3Mod0g4mod_0g( arg0, arg1 );
	// ^ Call( retval = <i128 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Mod>::mod_( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::shift::__ashldi3
uint64_t  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift9__ashldi30g(
		uint64_t arg0, // u64
		uint32_t arg1 // u32
		) // -> u64

{
	uint64_t rv;
	rv = ZRQCg3cR25compiler_builtins0_0_0_Hb3int5shift4Ashl0g4ashl0g( arg0, arg1 );
	// ^ Call( retval = <u64 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Ashl>::ashl( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::shift::__ashlti3
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift9__ashlti30g(
		uint128_t arg0, // u128
		uint32_t arg1 // u32
		) // -> u128

{
	uint128_t rv;
	rv = ZRQCi3cR25compiler_builtins0_0_0_Hb3int5shift4Ashl0g4ashl0g( arg0, arg1 );
	// ^ Call( retval = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Ashl>::ashl( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::shift::__ashrdi3
int64_t  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift9__ashrdi30g(
		int64_t arg0, // i64
		uint32_t arg1 // u32
		) // -> i64

{
	int64_t rv;
	rv = ZRQCh3cR25compiler_builtins0_0_0_Hb3int5shift4Ashr0g4ashr0g( arg0, arg1 );
	// ^ Call( retval = <i64 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Ashr>::ashr( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::shift::__ashrti3
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift9__ashrti30g(
		int128_t arg0, // i128
		uint32_t arg1 // u32
		) // -> i128

{
	int128_t rv;
	rv = ZRQCj3cR25compiler_builtins0_0_0_Hb3int5shift4Ashr0g4ashr0g( arg0, arg1 );
	// ^ Call( retval = <i128 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Ashr>::ashr( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::shift::__lshrdi3
uint64_t  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift9__lshrdi30g(
		uint64_t arg0, // u64
		uint32_t arg1 // u32
		) // -> u64

{
	uint64_t rv;
	rv = ZRQCg3cR25compiler_builtins0_0_0_Hb3int5shift4Lshr0g4lshr0g( arg0, arg1 );
	// ^ Call( retval = <u64 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Lshr>::lshr( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::shift::__lshrti3
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift9__lshrti30g(
		uint128_t arg0, // u128
		uint32_t arg1 // u32
		) // -> u128

{
	uint128_t rv;
	rv = ZRQCi3cR25compiler_builtins0_0_0_Hb3int5shift4Lshr0g4lshr0g( arg0, arg1 );
	// ^ Call( retval = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Lshr>::lshr( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::shift::rust_i128_shl
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift13rust_i128_shl0g(
		int128_t arg0, // i128
		uint32_t arg1 // u32
		) // -> i128

{
	int128_t rv;
	uint128_t var0;	// u128
	uint128_t var1;	// u128
	var1.lo = arg0.lo; var1.hi = arg0.hi;	// _1 = Cast(a0 as u128)
	var0 = ZRQCi3cR25compiler_builtins0_0_0_Hb3int5shift4Ashl0g4ashl0g( var1, arg1 );
	// ^ Call( _0 = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Ashl>::ashl( _1, a1, ), bb1, bb2)
	rv.lo = var0.lo; rv.hi = var0.hi;	// retval = Cast(_0 as i128)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::shift::rust_i128_shlo
TUP_2_ZRTCj_ZRTCw  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift14rust_i128_shlo0g(
		int128_t arg0, // i128
		uint128_t arg1 // u128
		) // -> (i128, bool, )

{
	TUP_2_ZRTCj_ZRTCw rv;
	RUST_BOOL var0;	// bool
	int128_t var1;	// i128
	uint128_t var2;	// u128
	uint128_t var3;	// u128
	uint32_t var4;	// u32
	var4 = arg1.lo;	// _4 = Cast(a1 as u32)
	var3.lo = arg0.lo; var3.hi = arg0.hi;	// _3 = Cast(a0 as u128)
	var2 = ZRQCi3cR25compiler_builtins0_0_0_Hb3int5shift4Ashl0g4ashl0g( var3, var4 );
	// ^ Call( _2 = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Ashl>::ashl( _3, _4, ), bb1, bb2)
	var1.lo = var2.lo; var1.hi = var2.hi;	// _1 = Cast(_2 as i128)
	var0 = 0 >= cmp128(make128_raw(0ull, 128ull), arg1);	// _0 = BinOp(a1 GE 0x80 u128)
	;
	rv._0 = var1;
	rv._1 = var0;	// retval = Tuple(_1, _0)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::shift::rust_i128_shr
int128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift13rust_i128_shr0g(
		int128_t arg0, // i128
		uint32_t arg1 // u32
		) // -> i128

{
	int128_t rv;
	rv = ZRQCj3cR25compiler_builtins0_0_0_Hb3int5shift4Ashr0g4ashr0g( arg0, arg1 );
	// ^ Call( retval = <i128 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Ashr>::ashr( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::shift::rust_i128_shro
TUP_2_ZRTCj_ZRTCw  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift14rust_i128_shro0g(
		int128_t arg0, // i128
		uint128_t arg1 // u128
		) // -> (i128, bool, )

{
	TUP_2_ZRTCj_ZRTCw rv;
	RUST_BOOL var0;	// bool
	int128_t var1;	// i128
	uint32_t var2;	// u32
	var2 = arg1.lo;	// _2 = Cast(a1 as u32)
	var1 = ZRQCj3cR25compiler_builtins0_0_0_Hb3int5shift4Ashr0g4ashr0g( arg0, var2 );
	// ^ Call( _1 = <i128 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Ashr>::ashr( a0, _2, ), bb1, bb2)
	var0 = 0 >= cmp128(make128_raw(0ull, 128ull), arg1);	// _0 = BinOp(a1 GE 0x80 u128)
	;
	rv._0 = var1;
	rv._1 = var0;	// retval = Tuple(_1, _0)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::shift::rust_u128_shl
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift13rust_u128_shl0g(
		uint128_t arg0, // u128
		uint32_t arg1 // u32
		) // -> u128

{
	uint128_t rv;
	rv = ZRQCi3cR25compiler_builtins0_0_0_Hb3int5shift4Ashl0g4ashl0g( arg0, arg1 );
	// ^ Call( retval = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Ashl>::ashl( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::shift::rust_u128_shlo
TUP_2_ZRTCi_ZRTCw  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift14rust_u128_shlo0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> (u128, bool, )

{
	TUP_2_ZRTCi_ZRTCw rv;
	RUST_BOOL var0;	// bool
	uint128_t var1;	// u128
	uint32_t var2;	// u32
	var2 = arg1.lo;	// _2 = Cast(a1 as u32)
	var1 = ZRQCi3cR25compiler_builtins0_0_0_Hb3int5shift4Ashl0g4ashl0g( arg0, var2 );
	// ^ Call( _1 = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Ashl>::ashl( a0, _2, ), bb1, bb2)
	var0 = 0 >= cmp128(make128_raw(0ull, 128ull), arg1);	// _0 = BinOp(a1 GE 0x80 u128)
	;
	rv._0 = var1;
	rv._1 = var0;	// retval = Tuple(_1, _0)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::shift::rust_u128_shr
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift13rust_u128_shr0g(
		uint128_t arg0, // u128
		uint32_t arg1 // u32
		) // -> u128

{
	uint128_t rv;
	rv = ZRQCi3cR25compiler_builtins0_0_0_Hb3int5shift4Lshr0g4lshr0g( arg0, arg1 );
	// ^ Call( retval = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Lshr>::lshr( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::shift::rust_u128_shro
TUP_2_ZRTCi_ZRTCw  ZRG3cR25compiler_builtins0_0_0_Hb3int5shift14rust_u128_shro0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> (u128, bool, )

{
	TUP_2_ZRTCi_ZRTCw rv;
	RUST_BOOL var0;	// bool
	uint128_t var1;	// u128
	uint32_t var2;	// u32
	var2 = arg1.lo;	// _2 = Cast(a1 as u32)
	var1 = ZRQCi3cR25compiler_builtins0_0_0_Hb3int5shift4Lshr0g4lshr0g( arg0, var2 );
	// ^ Call( _1 = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Lshr>::lshr( a0, _2, ), bb1, bb2)
	var0 = 0 >= cmp128(make128_raw(0ull, 128ull), arg1);	// _0 = BinOp(a1 GE 0x80 u128)
	;
	rv._0 = var1;
	rv._1 = var0;	// retval = Tuple(_1, _0)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::udiv::__udivdi3
uint64_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv9__udivdi30g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64

{
	uint64_t rv;
	struct e_ZRG2cE9core0_0_06option6Option1gBuCg var0;	// ::"core-0_0_0"::option::Option<&'static mut u64,>/*E*/
	memset(&var0, 0, sizeof(struct e_ZRG2cE9core0_0_06option6Option1gBuCg ));	// _0 = Variant(::"core-0_0_0"::option::Option<&'static mut u64,> #0, {})
	rv = ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv12__udivmoddi40g( arg0, arg1, var0 );
	// ^ Call( retval = ::"compiler_builtins-0_0_0_Hb"::int::udiv::__udivmoddi4<'static,>( a0, a1, _0, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::udiv::__udivmoddi4
uint64_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv12__udivmoddi40g(
		uint64_t arg0, // u64
		uint64_t arg1, // u64
		struct e_ZRG2cE9core0_0_06option6Option1gBuCg arg2 // ::"core-0_0_0"::option::Option<&'#omitted mut u64,>/*E*/
		) // -> u64

{
	uint64_t rv;
	uint64_t var0;	// u64
	uint64_t var1;	// u64
	struct e_ZRG2cE9core0_0_06option6Option1gBuCg var2;	// ::"core-0_0_0"::option::Option<&'M0 mut u64,>/*E*/
	uint64_t *var3;	// &'static mut u64
	uint64_t *var4;	// &'static mut u64
	uint32_t var5;	// u32
	uint64_t var6;	// u64
	uint64_t var7;	// u64
	uint64_t *var8;	// &'static mut u64
	uint64_t *var9;	// &'static mut u64
	uint64_t *var10;	// &'static mut u64
	uint64_t *var11;	// &'static mut u64
	uint32_t var12;	// u32
	uint64_t *var13;	// &'static mut u64
	uint32_t var14;	// u32
	uint32_t var15;	// u32
	int64_t var16;	// i64
	uint64_t *var17;	// &'static mut u64
	RUST_BOOL var18;	// bool
	uint32_t var19;	// u32
	uint32_t var20;	// u32
	uint32_t var21;	// u32
	uint32_t var22;	// u32
	uint32_t var23;	// u32
	uint32_t var24;	// u32
	uint32_t var25;	// u32
	uint32_t var26;	// u32
	uint32_t var27;	// u32
	uint32_t var28;	// u32
	uint32_t var29;	// u32
	uint32_t var30;	// u32
	uint32_t var31;	// u32
	uint32_t var32;	// u32
	uint32_t var33;	// u32
	uint32_t var34;	// u32
	uint32_t var35;	// u32
	uint32_t var36;	// u32
	uint32_t var37;	// u32
	uint32_t var38;	// u32
	uint32_t var39;	// u32
	uint32_t var40;	// u32
	uint64_t var41;	// u64
	uint64_t var42;	// u64
	uint64_t var43;	// u64
	uint64_t var44;	// u64
	uint64_t var45;	// u64
	int64_t var46;	// i64
	int64_t var47;	// i64
	uint64_t var48;	// u64
	uint64_t var49;	// u64
	uint64_t var50;	// u64
	uint64_t var51;	// u64
	uint64_t var52;	// u64
	uint64_t var53;	// u64
	uint32_t var54;	// u32
	uint32_t var55;	// u32
	uint32_t var56;	// u32
	uint32_t var57;	// u32
	uint32_t var58;	// u32
	uint32_t var59;	// u32
	uint64_t var60;	// u64
	uint64_t var61;	// u64
	uint32_t var62;	// u32
	uint64_t var63;	// u64
	uint32_t var64;	// u32
	uint64_t var65;	// u64
	uint32_t var66;	// u32
	uint64_t var67;	// u64
	uint32_t var68;	// u32
	uint64_t var69;	// u64
	uint64_t var70;	// u64
	uint64_t var71;	// u64
	uint32_t var72;	// u32
	uint32_t var73;	// u32
	uint64_t var74;	// u64
	uint32_t var75;	// u32
	uint64_t var76;	// u64
	uint64_t var77;	// u64
	uint64_t var78;	// u64
	uint64_t var79;	// u64
	uint64_t var80;	// u64
	uint64_t var81;	// u64
	uint64_t var82;	// u64
	uint32_t var83;	// u32
	uint32_t var84;	// u32
	uint64_t var85;	// u64
	uint32_t var86;	// u32
	uint32_t var87;	// u32
	uint32_t var88;	// u32
	uint64_t var89;	// u64
	uint32_t var90;	// u32
	uint32_t var91;	// u32
	uint32_t var92;	// u32
	uint32_t var93;	// u32
	uint64_t var94;	// u64
	uint32_t var95;	// u32
	uint32_t var96;	// u32
	uint32_t var97;	// u32
	uint64_t var98;	// u64
	uint32_t var99;	// u32
	uint32_t var100;	// u32
	uint64_t var101;	// u64
	uint32_t var102;	// u32
	uint32_t var103;	// u32
	uint32_t var104;	// u32
	uint64_t var105;	// u64
	tBANG var106 = {0};	// !
	var1 = arg1;	// _1 = Use(a1)
	var2 = arg2;	// _2 = Use(a2)
	var0 = arg0;	// _0 = Use(a0)
	var52 = arg0 >> 32;	// _52 = BinOp(a0 BIT_SHR +32 i32)
	var19 = (uint32_t )var52;	// _19 = Cast(_52 as u32)
	var18 = var19 == 0x0;	// _18 = BinOp(_19 EQ 0x0 u32)
	if(var18) goto bb1; else goto bb2;
	// ^ If( _18 : 1, 2)
bb1:
	var53 = var1 >> 32;	// _53 = BinOp(_1 BIT_SHR +32 i32)
	var20 = (uint32_t )var53;	// _20 = Cast(_53 as u32)
	var18 = var20 == 0x0;	// _18 = BinOp(_20 EQ 0x0 u32)
	if(var18) goto bb53; else goto bb54;
	// ^ If( _18 : 53, 54)
bb2:
	var21 = (uint32_t )var1;	// _21 = Cast(_1 as u32)
	var18 = var21 == 0x0;	// _18 = BinOp(_21 EQ 0x0 u32)
	if(var18) goto bb3; else goto bb4;
	// ^ If( _18 : 3, 4)
bb3:
	var60 = var1 >> 32;	// _60 = BinOp(_1 BIT_SHR +32 i32)
	var22 = (uint32_t )var60;	// _22 = Cast(_60 as u32)
	var18 = var22 == 0x0;	// _18 = BinOp(_22 EQ 0x0 u32)
	if(var18) goto bb33; else goto bb34;
	// ^ If( _18 : 33, 34)
bb4:
	var61 = var1 >> 32;	// _61 = BinOp(_1 BIT_SHR +32 i32)
	var30 = (uint32_t )var61;	// _30 = Cast(_61 as u32)
	var18 = var30 == 0x0;	// _18 = BinOp(_30 EQ 0x0 u32)
	if(var18) goto bb5; else goto bb7;
	// ^ If( _18 : 5, 7)
bb5:
	var93 = (uint32_t )var1;	// _93 = Cast(_1 as u32)
	var18 = ZRICe15is_power_of_two0g( var93 );
	// ^ Call( _18 = <u32 /*- */>::is_power_of_two( _93, ), bb6, bb11)
	if(var18) goto bb24; else goto bb25;
	// ^ If( _18 : 24, 25)
bb7:
	var94 = var1 >> 32;	// _94 = BinOp(_1 BIT_SHR +32 i32)
	var100 = (uint32_t )var94;	// _100 = Cast(_94 as u32)
	var103 = (var100 != 0 ? __builtin_clz(var100) : sizeof(uint32_t )*8);
	// ^ Call( _103 = "ctlz"::<u32,>( _100, ), bb8, bb11)
	var101 = var0 >> 32;	// _101 = BinOp(_0 BIT_SHR +32 i32)
	var102 = (uint32_t )var101;	// _102 = Cast(_101 as u32)
	var104 = (var102 != 0 ? __builtin_clz(var102) : sizeof(uint32_t )*8);
	// ^ Call( _104 = "ctlz"::<u32,>( _102, ), bb9, bb11)
	__builtin_sub_overflow(var103, var104, &var5);
	// ^ Call( _5 = "overflowing_sub"::<u32,>( _103, _104, ), bb10, bb11)
	var18 = var5 > 0x1f;	// _18 = BinOp(_5 GT 0x1f u32)
	if(var18) goto bb12; else goto bb13;
	// ^ If( _18 : 12, 13)
bb11: _Unwind_Resume(); // Diverge
bb12:
	if( var2.DATA.var_1._0 != 0 )
		goto bb22;
	else
		goto bb23;
	// ^ Switch( _2 : 0 => bb23, 1 => bb22, )
bb13:
	var5 = var5 + 0x1;	// _5 = BinOp(_5 ADD 0x1 u32)
	var40 = 0x40 - var5;	// _40 = BinOp(0x40 u32 SUB _5)
	var6 = var0 << var40;	// _6 = BinOp(_0 BIT_SHL _40)
	var7 = var0 >> var5;	// _7 = BinOp(_0 BIT_SHR _5)
	// ^ Goto(14)
bb14:
	var14 = 0x0;	// _14 = Constant(0x0 u32)
	var15 = 0x0;	// _15 = Constant(0x0 u32)
	// ^ Goto(15)
bb15:
	var18 = var15 < var5;	// _18 = BinOp(_15 LT _5)
	if(var18) goto bb16; else goto bb19;
	// ^ If( _18 : 16, 19)
bb16:
	var15 = var15 + 0x1;	// _15 = BinOp(_15 ADD 0x1 u32)
	var41 = var7 << 1;	// _41 = BinOp(_7 BIT_SHL +1 i32)
	var42 = var6 >> 0x3f;	// _42 = BinOp(_6 BIT_SHR 0x3f u32)
	var7 = var41 | var42;	// _7 = BinOp(_41 BIT_OR _42)
	var43 = var6 << 1;	// _43 = BinOp(_6 BIT_SHL +1 i32)
	var44 = (uint64_t )var14;	// _44 = Cast(_14 as u64)
	var6 = var43 | var44;	// _6 = BinOp(_43 BIT_OR _44)
	__builtin_sub_overflow(var1, var7, &var105);
	// ^ Call( _105 = "overflowing_sub"::<u64,>( _1, _7, ), bb17, bb11)
	__builtin_sub_overflow(var105, 0x1ull, &var45);
	// ^ Call( _45 = "overflowing_sub"::<u64,>( _105, 0x1 u64, ), bb18, bb11)
	var46 = (int64_t )var45;	// _46 = Cast(_45 as i64)
	var16 = var46 >> 0x3f;	// _16 = BinOp(_46 BIT_SHR 0x3f u32)
	var47 = var16 & 1ll;	// _47 = BinOp(_16 BIT_AND +1 i64)
	var14 = (uint32_t )var47;	// _14 = Cast(_47 as u32)
	var49 = (uint64_t )var16;	// _49 = Cast(_16 as u64)
	var48 = var1 & var49;	// _48 = BinOp(_1 BIT_AND _49)
	var7 = var7 - var48;	// _7 = BinOp(_7 SUB _48)
	goto bb15;
	// ^ Goto(15)
bb19:
	if( var2.DATA.var_1._0 != 0 )
		goto bb20;
	else
		goto bb21;
	// ^ Switch( _2 : 0 => bb21, 1 => bb20, )
bb20:
	var17 = var2.DATA.var_1._0;	// _17 = Use(_2#1.0)
	(*var17) = var7;	// _17* = Use(_7)
	// ^ drop(_17)
	// ^ Goto(21)
bb21:
	var50 = var6 << 1;	// _50 = BinOp(_6 BIT_SHL +1 i32)
	var51 = (uint64_t )var14;	// _51 = Cast(_14 as u64)
	rv = var50 | var51;	// retval = BinOp(_50 BIT_OR _51)
	return rv;
	// ^ Return
bb22:
	var13 = var2.DATA.var_1._0;	// _13 = Use(_2#1.0)
	(*var13) = var0;	// _13* = Use(_0)
	// ^ drop(_13)
	// ^ Goto(23)
bb23:
	rv = 0x0ull;	// retval = Constant(0x0 u64)
	return rv;
	// ^ Return
bb24:
	if( var2.DATA.var_1._0 != 0 )
		goto bb28;
	else
		goto bb29;
	// ^ Switch( _2 : 0 => bb29, 1 => bb28, )
bb25:
	var36 = 0x21;	// _36 = Constant(0x21 u32)
	var97 = (uint32_t )var1;	// _97 = Cast(_1 as u32)
	var37 = (var97 != 0 ? __builtin_clz(var97) : sizeof(uint32_t )*8);
	// ^ Call( _37 = "ctlz"::<u32,>( _97, ), bb26, bb11)
	var35 = var36 + var37;	// _35 = BinOp(_36 ADD _37)
	var98 = var0 >> 32;	// _98 = BinOp(_0 BIT_SHR +32 i32)
	var99 = (uint32_t )var98;	// _99 = Cast(_98 as u32)
	var38 = (var99 != 0 ? __builtin_clz(var99) : sizeof(uint32_t )*8);
	// ^ Call( _38 = "ctlz"::<u32,>( _99, ), bb27, bb11)
	var5 = var35 - var38;	// _5 = BinOp(_35 SUB _38)
	var39 = 0x40 - var5;	// _39 = BinOp(0x40 u32 SUB _5)
	var6 = var0 << var39;	// _6 = BinOp(_0 BIT_SHL _39)
	var7 = var0 >> var5;	// _7 = BinOp(_0 BIT_SHR _5)
	goto bb14;
	// ^ Goto(14)
bb28:
	var11 = var2.DATA.var_1._0;	// _11 = Use(_2#1.0)
	var31 = (uint32_t )var0;	// _31 = Cast(_0 as u32)
	var33 = (uint32_t )var1;	// _33 = Cast(_1 as u32)
	var32 = var33 - 0x1;	// _32 = BinOp(_33 SUB 0x1 u32)
	var95 = var31 & var32;	// _95 = BinOp(_31 BIT_AND _32)
	(*var11) = (uint64_t )var95;	// _11* = Cast(_95 as u64)
	// ^ drop(_11)
	// ^ Goto(29)
bb29:
	var34 = (uint32_t )var1;	// _34 = Cast(_1 as u32)
	var18 = var34 == 0x1;	// _18 = BinOp(_34 EQ 0x1 u32)
	if(var18) goto bb30; else goto bb31;
	// ^ If( _18 : 30, 31)
bb30:
	rv = var0;	// retval = Use(_0)
	return rv;
	// ^ Return
bb31:
	var96 = (uint32_t )var1;	// _96 = Cast(_1 as u32)
	var12 = (var96 != 0 ? __builtin_ctz(var96) : sizeof(uint32_t )*8);
	// ^ Call( _12 = "cttz"::<u32,>( _96, ), bb32, bb11)
	rv = var0 >> var12;	// retval = BinOp(_0 BIT_SHR _12)
	return rv;
	// ^ Return
bb33:
	abort();
	goto bb11;
	// ^ Call( _106 = "abort"::( ), bb11, bb11)
bb34:
	var23 = (uint32_t )var0;	// _23 = Cast(_0 as u32)
	var18 = var23 == 0x0;	// _18 = BinOp(_23 EQ 0x0 u32)
	if(var18) goto bb35; else goto bb36;
	// ^ If( _18 : 35, 36)
bb35:
	if( var2.DATA.var_1._0 != 0 )
		goto bb49;
	else
		goto bb51;
	// ^ Switch( _2 : 0 => bb51, 1 => bb49, )
bb36:
	var63 = var1 >> 32;	// _63 = BinOp(_1 BIT_SHR +32 i32)
	var62 = (uint32_t )var63;	// _62 = Cast(_63 as u32)
	var18 = ZRICe15is_power_of_two0g( var62 );
	// ^ Call( _18 = <u32 /*- */>::is_power_of_two( _62, ), bb37, bb11)
	if(var18) goto bb38; else goto bb39;
	// ^ If( _18 : 38, 39)
bb38:
	if( var2.DATA.var_1._0 != 0 )
		goto bb46;
	else
		goto bb47;
	// ^ Switch( _2 : 0 => bb47, 1 => bb46, )
bb39:
	var76 = var1 >> 32;	// _76 = BinOp(_1 BIT_SHR +32 i32)
	var88 = (uint32_t )var76;	// _88 = Cast(_76 as u32)
	var91 = (var88 != 0 ? __builtin_clz(var88) : sizeof(uint32_t )*8);
	// ^ Call( _91 = "ctlz"::<u32,>( _88, ), bb40, bb11)
	var89 = var0 >> 32;	// _89 = BinOp(_0 BIT_SHR +32 i32)
	var90 = (uint32_t )var89;	// _90 = Cast(_89 as u32)
	var92 = (var90 != 0 ? __builtin_clz(var90) : sizeof(uint32_t )*8);
	// ^ Call( _92 = "ctlz"::<u32,>( _90, ), bb41, bb11)
	__builtin_sub_overflow(var91, var92, &var5);
	// ^ Call( _5 = "overflowing_sub"::<u32,>( _91, _92, ), bb42, bb11)
	var18 = var5 > 0x1e;	// _18 = BinOp(_5 GT 0x1e u32)
	if(var18) goto bb43; else goto bb44;
	// ^ If( _18 : 43, 44)
bb43:
	if( var2.DATA.var_1._0 != 0 )
		goto bb45;
	else
		goto bb23;
	// ^ Switch( _2 : 0 => bb23, 1 => bb45, )
bb44:
	var5 = var5 + 0x1;	// _5 = BinOp(_5 ADD 0x1 u32)
	var29 = 0x40 - var5;	// _29 = BinOp(0x40 u32 SUB _5)
	var6 = var0 << var29;	// _6 = BinOp(_0 BIT_SHL _29)
	var7 = var0 >> var5;	// _7 = BinOp(_0 BIT_SHR _5)
	goto bb14;
	// ^ Goto(14)
bb45:
	var10 = var2.DATA.var_1._0;	// _10 = Use(_2#1.0)
	(*var10) = var0;	// _10* = Use(_0)
	// ^ drop(_10)
	goto bb23;
	// ^ Goto(23)
bb46:
	var9 = var2.DATA.var_1._0;	// _9 = Use(_2#1.0)
	var83 = (uint32_t )var0;	// _83 = Cast(_0 as u32)
	var78 = var0 >> 32;	// _78 = BinOp(_0 BIT_SHR +32 i32)
	var24 = (uint32_t )var78;	// _24 = Cast(_78 as u32)
	var79 = var1 >> 32;	// _79 = BinOp(_1 BIT_SHR +32 i32)
	var26 = (uint32_t )var79;	// _26 = Cast(_79 as u32)
	var25 = var26 - 0x1;	// _25 = BinOp(_26 SUB 0x1 u32)
	var84 = var24 & var25;	// _84 = BinOp(_24 BIT_AND _25)
	var80 = (uint64_t )var83;	// _80 = Cast(_83 as u64)
	var82 = (uint64_t )var84;	// _82 = Cast(_84 as u64)
	var81 = var82 << 32;	// _81 = BinOp(_82 BIT_SHL +32 i32)
	(*var9) = var80 | var81;	// _9* = BinOp(_80 BIT_OR _81)
	// ^ drop(_9)
	// ^ Goto(47)
bb47:
	var77 = var0 >> 32;	// _77 = BinOp(_0 BIT_SHR +32 i32)
	var27 = (uint32_t )var77;	// _27 = Cast(_77 as u32)
	var85 = var1 >> 32;	// _85 = BinOp(_1 BIT_SHR +32 i32)
	var86 = (uint32_t )var85;	// _86 = Cast(_85 as u32)
	var28 = (var86 != 0 ? __builtin_ctz(var86) : sizeof(uint32_t )*8);
	// ^ Call( _28 = "cttz"::<u32,>( _86, ), bb48, bb11)
	var87 = var27 >> var28;	// _87 = BinOp(_27 BIT_SHR _28)
	rv = (uint64_t )var87;	// retval = Cast(_87 as u64)
	return rv;
	// ^ Return
bb49:
	var8 = var2.DATA.var_1._0;	// _8 = Use(_2#1.0)
	var67 = var0 >> 32;	// _67 = BinOp(_0 BIT_SHR +32 i32)
	var66 = (uint32_t )var67;	// _66 = Cast(_67 as u32)
	var69 = var1 >> 32;	// _69 = BinOp(_1 BIT_SHR +32 i32)
	var68 = (uint32_t )var69;	// _68 = Cast(_69 as u32)
	var72 = ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_rem0g( var66, var68 );
	// ^ Call( _72 = <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_rem( _66, _68, ), bb50, bb11)
	var71 = (uint64_t )var72;	// _71 = Cast(_72 as u64)
	var70 = var71 << 32;	// _70 = BinOp(_71 BIT_SHL +32 i32)
	(*var8) = 0x0ull | var70;	// _8* = BinOp(0x0 u64 BIT_OR _70)
	// ^ drop(_8)
	// ^ Goto(51)
bb51:
	var65 = var0 >> 32;	// _65 = BinOp(_0 BIT_SHR +32 i32)
	var64 = (uint32_t )var65;	// _64 = Cast(_65 as u32)
	var74 = var1 >> 32;	// _74 = BinOp(_1 BIT_SHR +32 i32)
	var73 = (uint32_t )var74;	// _73 = Cast(_74 as u32)
	var75 = ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g( var64, var73 );
	// ^ Call( _75 = <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div( _64, _73, ), bb52, bb11)
	rv = (uint64_t )var75;	// retval = Cast(_75 as u64)
	return rv;
	// ^ Return
bb53:
	if( var2.DATA.var_1._0 != 0 )
		goto bb56;
	else
		goto bb58;
	// ^ Switch( _2 : 0 => bb58, 1 => bb56, )
bb54:
	if( var2.DATA.var_1._0 != 0 )
		goto bb55;
	else
		goto bb23;
	// ^ Switch( _2 : 0 => bb23, 1 => bb55, )
bb55:
	var4 = var2.DATA.var_1._0;	// _4 = Use(_2#1.0)
	(*var4) = var0;	// _4* = Use(_0)
	// ^ drop(_4)
	goto bb23;
	// ^ Goto(23)
bb56:
	var3 = var2.DATA.var_1._0;	// _3 = Use(_2#1.0)
	var55 = (uint32_t )var0;	// _55 = Cast(_0 as u32)
	var56 = (uint32_t )var1;	// _56 = Cast(_1 as u32)
	var57 = ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_rem0g( var55, var56 );
	// ^ Call( _57 = <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_rem( _55, _56, ), bb57, bb11)
	(*var3) = (uint64_t )var57;	// _3* = Cast(_57 as u64)
	// ^ drop(_3)
	// ^ Goto(58)
bb58:
	var54 = (uint32_t )var0;	// _54 = Cast(_0 as u32)
	var58 = (uint32_t )var1;	// _58 = Cast(_1 as u32)
	var59 = ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g( var54, var58 );
	// ^ Call( _59 = <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div( _54, _58, ), bb59, bb11)
	rv = (uint64_t )var59;	// retval = Cast(_59 as u64)
	return rv;
	// ^ Return
}
// ::"compiler_builtins-0_0_0_Hb"::int::udiv::__udivmodsi4
uint32_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv12__udivmodsi40g(
		uint32_t arg0, // u32
		uint32_t arg1, // u32
		struct e_ZRG2cE9core0_0_06option6Option1gBuCe arg2 // ::"core-0_0_0"::option::Option<&'#omitted mut u32,>/*E*/
		) // -> u32

{
	uint32_t rv;
	uint32_t var0;	// u32
	uint32_t *var1;	// &'static mut u32
	uint32_t var2;	// u32
	var0 = ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv9__udivsi30g( arg0, arg1 );
	// ^ Call( _0 = ::"compiler_builtins-0_0_0_Hb"::int::udiv::__udivsi3( a0, a1, ), bb1, bb2)
	if( arg2.DATA.var_1._0 != 0 )
		goto bb3;
	else
		goto bb4;
	// ^ Switch( a2 : 0 => bb4, 1 => bb3, )
bb2: _Unwind_Resume(); // Diverge
bb3:
	var1 = arg2.DATA.var_1._0;	// _1 = Use(a2#1.0)
	var2 = var0 * arg1;	// _2 = BinOp(_0 MUL a1)
	(*var1) = arg0 - var2;	// _1* = BinOp(a0 SUB _2)
	// ^ drop(_1)
	// ^ Goto(4)
bb4:
	rv = var0;	// retval = Use(_0)
	return rv;
	// ^ Return
}
// ::"compiler_builtins-0_0_0_Hb"::int::udiv::__udivmodti4
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv12__udivmodti40g(
		uint128_t arg0, // u128
		uint128_t arg1, // u128
		struct e_ZRG2cE9core0_0_06option6Option1gBuCi arg2 // ::"core-0_0_0"::option::Option<&'#omitted mut u128,>/*E*/
		) // -> u128

{
	uint128_t rv;
	uint128_t var0;	// u128
	uint128_t var1;	// u128
	struct e_ZRG2cE9core0_0_06option6Option1gBuCi var2;	// ::"core-0_0_0"::option::Option<&'M0 mut u128,>/*E*/
	uint128_t *var3;	// &'static mut u128
	uint128_t *var4;	// &'static mut u128
	uint32_t var5;	// u32
	uint128_t var6;	// u128
	uint128_t var7;	// u128
	uint128_t *var8;	// &'static mut u128
	uint128_t *var9;	// &'static mut u128
	uint128_t *var10;	// &'static mut u128
	uint128_t *var11;	// &'static mut u128
	uint32_t var12;	// u32
	uint128_t *var13;	// &'static mut u128
	uint64_t var14;	// u64
	uint32_t var15;	// u32
	int128_t var16;	// i128
	uint128_t *var17;	// &'static mut u128
	RUST_BOOL var18;	// bool
	uint64_t var19;	// u64
	uint64_t var20;	// u64
	uint64_t var21;	// u64
	uint64_t var22;	// u64
	uint64_t var23;	// u64
	uint64_t var24;	// u64
	uint64_t var25;	// u64
	uint64_t var26;	// u64
	uint64_t var27;	// u64
	uint32_t var28;	// u32
	uint32_t var29;	// u32
	uint64_t var30;	// u64
	uint64_t var31;	// u64
	uint64_t var32;	// u64
	uint64_t var33;	// u64
	uint64_t var34;	// u64
	uint32_t var35;	// u32
	uint32_t var36;	// u32
	uint32_t var37;	// u32
	uint32_t var38;	// u32
	uint32_t var39;	// u32
	uint32_t var40;	// u32
	uint128_t var41;	// u128
	uint128_t var42;	// u128
	uint128_t var43;	// u128
	uint128_t var44;	// u128
	uint128_t var45;	// u128
	int128_t var46;	// i128
	int128_t var47;	// i128
	uint128_t var48;	// u128
	uint128_t var49;	// u128
	uint128_t var50;	// u128
	uint128_t var51;	// u128
	uint128_t var52;	// u128
	uint128_t var53;	// u128
	uint64_t var54;	// u64
	uint64_t var55;	// u64
	uint64_t var56;	// u64
	uint64_t var57;	// u64
	uint64_t var58;	// u64
	uint64_t var59;	// u64
	uint128_t var60;	// u128
	uint128_t var61;	// u128
	uint64_t var62;	// u64
	uint128_t var63;	// u128
	uint64_t var64;	// u64
	uint128_t var65;	// u128
	uint64_t var66;	// u64
	uint128_t var67;	// u128
	uint64_t var68;	// u64
	uint128_t var69;	// u128
	uint128_t var70;	// u128
	uint128_t var71;	// u128
	uint64_t var72;	// u64
	uint64_t var73;	// u64
	uint128_t var74;	// u128
	uint64_t var75;	// u64
	uint128_t var76;	// u128
	uint128_t var77;	// u128
	uint128_t var78;	// u128
	uint128_t var79;	// u128
	uint128_t var80;	// u128
	uint128_t var81;	// u128
	uint128_t var82;	// u128
	uint64_t var83;	// u64
	uint64_t var84;	// u64
	uint128_t var85;	// u128
	uint64_t var86;	// u64
	uint64_t var87;	// u64
	uint64_t var88;	// u64
	uint64_t var89;	// u64
	uint64_t var90;	// u64
	uint128_t var91;	// u128
	uint64_t var92;	// u64
	uint64_t var93;	// u64
	uint32_t var94;	// u32
	uint32_t var95;	// u32
	uint64_t var96;	// u64
	uint128_t var97;	// u128
	uint64_t var98;	// u64
	uint64_t var99;	// u64
	uint64_t var100;	// u64
	uint64_t var101;	// u64
	uint64_t var102;	// u64
	uint128_t var103;	// u128
	uint64_t var104;	// u64
	uint64_t var105;	// u64
	uint64_t var106;	// u64
	uint64_t var107;	// u64
	uint128_t var108;	// u128
	uint64_t var109;	// u64
	uint64_t var110;	// u64
	uint32_t var111;	// u32
	uint32_t var112;	// u32
	uint128_t var113;	// u128
	tBANG var114 = {0};	// !
	var1 = arg1;	// _1 = Use(a1)
	var2 = arg2;	// _2 = Use(a2)
	var0 = arg0;	// _0 = Use(a0)
	var52 = shr128(arg0, 64);	// _52 = BinOp(a0 BIT_SHR +64 i32)
	var19 = var52.lo;	// _19 = Cast(_52 as u64)
	var18 = var19 == 0x0ull;	// _18 = BinOp(_19 EQ 0x0 u64)
	if(var18) goto bb1; else goto bb2;
	// ^ If( _18 : 1, 2)
bb1:
	var53 = shr128(var1, 64);	// _53 = BinOp(_1 BIT_SHR +64 i32)
	var20 = var53.lo;	// _20 = Cast(_53 as u64)
	var18 = var20 == 0x0ull;	// _18 = BinOp(_20 EQ 0x0 u64)
	if(var18) goto bb53; else goto bb54;
	// ^ If( _18 : 53, 54)
bb2:
	var21 = var1.lo;	// _21 = Cast(_1 as u64)
	var18 = var21 == 0x0ull;	// _18 = BinOp(_21 EQ 0x0 u64)
	if(var18) goto bb3; else goto bb4;
	// ^ If( _18 : 3, 4)
bb3:
	var60 = shr128(var1, 64);	// _60 = BinOp(_1 BIT_SHR +64 i32)
	var22 = var60.lo;	// _22 = Cast(_60 as u64)
	var18 = var22 == 0x0ull;	// _18 = BinOp(_22 EQ 0x0 u64)
	if(var18) goto bb33; else goto bb34;
	// ^ If( _18 : 33, 34)
bb4:
	var61 = shr128(var1, 64);	// _61 = BinOp(_1 BIT_SHR +64 i32)
	var30 = var61.lo;	// _30 = Cast(_61 as u64)
	var18 = var30 == 0x0ull;	// _18 = BinOp(_30 EQ 0x0 u64)
	if(var18) goto bb5; else goto bb7;
	// ^ If( _18 : 5, 7)
bb5:
	var96 = var1.lo;	// _96 = Cast(_1 as u64)
	var18 = ZRICg15is_power_of_two0g( var96 );
	// ^ Call( _18 = <u64 /*- */>::is_power_of_two( _96, ), bb6, bb11)
	if(var18) goto bb24; else goto bb25;
	// ^ If( _18 : 24, 25)
bb7:
	var97 = shr128(var1, 64);	// _97 = BinOp(_1 BIT_SHR +64 i32)
	var107 = var97.lo;	// _107 = Cast(_97 as u64)
	var106 = (var107 != 0 ? __builtin_clz64(var107) : sizeof(uint64_t )*8);
	// ^ Call( _106 = "ctlz"::<u64,>( _107, ), bb8, bb11)
	var111 = (uint32_t )var106;	// _111 = Cast(_106 as u32)
	var108 = shr128(var0, 64);	// _108 = BinOp(_0 BIT_SHR +64 i32)
	var110 = var108.lo;	// _110 = Cast(_108 as u64)
	var109 = (var110 != 0 ? __builtin_clz64(var110) : sizeof(uint64_t )*8);
	// ^ Call( _109 = "ctlz"::<u64,>( _110, ), bb9, bb11)
	var112 = (uint32_t )var109;	// _112 = Cast(_109 as u32)
	__builtin_sub_overflow(var111, var112, &var5);
	// ^ Call( _5 = "overflowing_sub"::<u32,>( _111, _112, ), bb10, bb11)
	var18 = var5 > 0x3f;	// _18 = BinOp(_5 GT 0x3f u32)
	if(var18) goto bb12; else goto bb13;
	// ^ If( _18 : 12, 13)
bb11: _Unwind_Resume(); // Diverge
bb12:
	if( var2.DATA.var_1._0 != 0 )
		goto bb22;
	else
		goto bb23;
	// ^ Switch( _2 : 0 => bb23, 1 => bb22, )
bb13:
	var5 = var5 + 0x1;	// _5 = BinOp(_5 ADD 0x1 u32)
	var40 = 0x80 - var5;	// _40 = BinOp(0x80 u32 SUB _5)
	var6 = shl128(var0, var40);	// _6 = BinOp(_0 BIT_SHL _40)
	var7 = shr128(var0, var5);	// _7 = BinOp(_0 BIT_SHR _5)
	// ^ Goto(14)
bb14:
	var14 = 0x0ull;	// _14 = Constant(0x0 u64)
	var15 = 0x0;	// _15 = Constant(0x0 u32)
	// ^ Goto(15)
bb15:
	var18 = var15 < var5;	// _18 = BinOp(_15 LT _5)
	if(var18) goto bb16; else goto bb19;
	// ^ If( _18 : 16, 19)
bb16:
	var15 = var15 + 0x1;	// _15 = BinOp(_15 ADD 0x1 u32)
	var41 = shl128(var7, 1);	// _41 = BinOp(_7 BIT_SHL +1 i32)
	var42 = shr128(var6, 0x7f);	// _42 = BinOp(_6 BIT_SHR 0x7f u32)
	var7 = or128(var41, var42);	// _7 = BinOp(_41 BIT_OR _42)
	var43 = shl128(var6, 1);	// _43 = BinOp(_6 BIT_SHL +1 i32)
	var44.lo = var14; var44.hi = var14 < 0 ? -1 : 0;	// _44 = Cast(_14 as u128)
	var6 = or128(var43, var44);	// _6 = BinOp(_43 BIT_OR _44)
	sub128_o(var1, var7, &var113);
	// ^ Call( _113 = "overflowing_sub"::<u128,>( _1, _7, ), bb17, bb11)
	sub128_o(var113, make128_raw(0ull, 1ull), &var45);
	// ^ Call( _45 = "overflowing_sub"::<u128,>( _113, 0x1 u128, ), bb18, bb11)
	var46.lo = var45.lo; var46.hi = var45.hi;	// _46 = Cast(_45 as i128)
	var16 = shr128s(var46, 0x7f);	// _16 = BinOp(_46 BIT_SHR 0x7f u32)
	var47 = and128s(var16, make128s_raw(0ull, 1ull));	// _47 = BinOp(_16 BIT_AND +1 i128)
	var14 = var47.lo;	// _14 = Cast(_47 as u64)
	var49.lo = var16.lo; var49.hi = var16.hi;	// _49 = Cast(_16 as u128)
	var48 = and128(var1, var49);	// _48 = BinOp(_1 BIT_AND _49)
	var7 = sub128(var7, var48);	// _7 = BinOp(_7 SUB _48)
	goto bb15;
	// ^ Goto(15)
bb19:
	if( var2.DATA.var_1._0 != 0 )
		goto bb20;
	else
		goto bb21;
	// ^ Switch( _2 : 0 => bb21, 1 => bb20, )
bb20:
	var17 = var2.DATA.var_1._0;	// _17 = Use(_2#1.0)
	(*var17) = var7;	// _17* = Use(_7)
	// ^ drop(_17)
	// ^ Goto(21)
bb21:
	var50 = shl128(var6, 1);	// _50 = BinOp(_6 BIT_SHL +1 i32)
	var51.lo = var14; var51.hi = var14 < 0 ? -1 : 0;	// _51 = Cast(_14 as u128)
	rv = or128(var50, var51);	// retval = BinOp(_50 BIT_OR _51)
	return rv;
	// ^ Return
bb22:
	var13 = var2.DATA.var_1._0;	// _13 = Use(_2#1.0)
	(*var13) = var0;	// _13* = Use(_0)
	// ^ drop(_13)
	// ^ Goto(23)
bb23:
	rv = make128_raw(0ull, 0ull);	// retval = Constant(0x0 u128)
	return rv;
	// ^ Return
bb24:
	if( var2.DATA.var_1._0 != 0 )
		goto bb28;
	else
		goto bb29;
	// ^ Switch( _2 : 0 => bb29, 1 => bb28, )
bb25:
	var36 = 0x41;	// _36 = Constant(0x41 u32)
	var102 = var1.lo;	// _102 = Cast(_1 as u64)
	var101 = (var102 != 0 ? __builtin_clz64(var102) : sizeof(uint64_t )*8);
	// ^ Call( _101 = "ctlz"::<u64,>( _102, ), bb26, bb11)
	var37 = (uint32_t )var101;	// _37 = Cast(_101 as u32)
	var35 = var36 + var37;	// _35 = BinOp(_36 ADD _37)
	var103 = shr128(var0, 64);	// _103 = BinOp(_0 BIT_SHR +64 i32)
	var105 = var103.lo;	// _105 = Cast(_103 as u64)
	var104 = (var105 != 0 ? __builtin_clz64(var105) : sizeof(uint64_t )*8);
	// ^ Call( _104 = "ctlz"::<u64,>( _105, ), bb27, bb11)
	var38 = (uint32_t )var104;	// _38 = Cast(_104 as u32)
	var5 = var35 - var38;	// _5 = BinOp(_35 SUB _38)
	var39 = 0x80 - var5;	// _39 = BinOp(0x80 u32 SUB _5)
	var6 = shl128(var0, var39);	// _6 = BinOp(_0 BIT_SHL _39)
	var7 = shr128(var0, var5);	// _7 = BinOp(_0 BIT_SHR _5)
	goto bb14;
	// ^ Goto(14)
bb28:
	var11 = var2.DATA.var_1._0;	// _11 = Use(_2#1.0)
	var31 = var0.lo;	// _31 = Cast(_0 as u64)
	var33 = var1.lo;	// _33 = Cast(_1 as u64)
	var32 = var33 - 0x1ull;	// _32 = BinOp(_33 SUB 0x1 u64)
	var98 = var31 & var32;	// _98 = BinOp(_31 BIT_AND _32)
	(*var11).lo = var98; (*var11).hi = var98 < 0 ? -1 : 0;	// _11* = Cast(_98 as u128)
	// ^ drop(_11)
	// ^ Goto(29)
bb29:
	var34 = var1.lo;	// _34 = Cast(_1 as u64)
	var18 = var34 == 0x1ull;	// _18 = BinOp(_34 EQ 0x1 u64)
	if(var18) goto bb30; else goto bb31;
	// ^ If( _18 : 30, 31)
bb30:
	rv = var0;	// retval = Use(_0)
	return rv;
	// ^ Return
bb31:
	var100 = var1.lo;	// _100 = Cast(_1 as u64)
	var99 = (var100 != 0 ? __builtin_ctz64(var100) : sizeof(uint64_t )*8);
	// ^ Call( _99 = "cttz"::<u64,>( _100, ), bb32, bb11)
	var12 = (uint32_t )var99;	// _12 = Cast(_99 as u32)
	rv = shr128(var0, var12);	// retval = BinOp(_0 BIT_SHR _12)
	return rv;
	// ^ Return
bb33:
	abort();
	goto bb11;
	// ^ Call( _114 = "abort"::( ), bb11, bb11)
bb34:
	var23 = var0.lo;	// _23 = Cast(_0 as u64)
	var18 = var23 == 0x0ull;	// _18 = BinOp(_23 EQ 0x0 u64)
	if(var18) goto bb35; else goto bb36;
	// ^ If( _18 : 35, 36)
bb35:
	if( var2.DATA.var_1._0 != 0 )
		goto bb49;
	else
		goto bb51;
	// ^ Switch( _2 : 0 => bb51, 1 => bb49, )
bb36:
	var63 = shr128(var1, 64);	// _63 = BinOp(_1 BIT_SHR +64 i32)
	var62 = var63.lo;	// _62 = Cast(_63 as u64)
	var18 = ZRICg15is_power_of_two0g( var62 );
	// ^ Call( _18 = <u64 /*- */>::is_power_of_two( _62, ), bb37, bb11)
	if(var18) goto bb38; else goto bb39;
	// ^ If( _18 : 38, 39)
bb38:
	if( var2.DATA.var_1._0 != 0 )
		goto bb46;
	else
		goto bb47;
	// ^ Switch( _2 : 0 => bb47, 1 => bb46, )
bb39:
	var76 = shr128(var1, 64);	// _76 = BinOp(_1 BIT_SHR +64 i32)
	var90 = var76.lo;	// _90 = Cast(_76 as u64)
	var89 = (var90 != 0 ? __builtin_clz64(var90) : sizeof(uint64_t )*8);
	// ^ Call( _89 = "ctlz"::<u64,>( _90, ), bb40, bb11)
	var94 = (uint32_t )var89;	// _94 = Cast(_89 as u32)
	var91 = shr128(var0, 64);	// _91 = BinOp(_0 BIT_SHR +64 i32)
	var93 = var91.lo;	// _93 = Cast(_91 as u64)
	var92 = (var93 != 0 ? __builtin_clz64(var93) : sizeof(uint64_t )*8);
	// ^ Call( _92 = "ctlz"::<u64,>( _93, ), bb41, bb11)
	var95 = (uint32_t )var92;	// _95 = Cast(_92 as u32)
	__builtin_sub_overflow(var94, var95, &var5);
	// ^ Call( _5 = "overflowing_sub"::<u32,>( _94, _95, ), bb42, bb11)
	var18 = var5 > 0x3e;	// _18 = BinOp(_5 GT 0x3e u32)
	if(var18) goto bb43; else goto bb44;
	// ^ If( _18 : 43, 44)
bb43:
	if( var2.DATA.var_1._0 != 0 )
		goto bb45;
	else
		goto bb23;
	// ^ Switch( _2 : 0 => bb23, 1 => bb45, )
bb44:
	var5 = var5 + 0x1;	// _5 = BinOp(_5 ADD 0x1 u32)
	var29 = 0x80 - var5;	// _29 = BinOp(0x80 u32 SUB _5)
	var6 = shl128(var0, var29);	// _6 = BinOp(_0 BIT_SHL _29)
	var7 = shr128(var0, var5);	// _7 = BinOp(_0 BIT_SHR _5)
	goto bb14;
	// ^ Goto(14)
bb45:
	var10 = var2.DATA.var_1._0;	// _10 = Use(_2#1.0)
	(*var10) = var0;	// _10* = Use(_0)
	// ^ drop(_10)
	goto bb23;
	// ^ Goto(23)
bb46:
	var9 = var2.DATA.var_1._0;	// _9 = Use(_2#1.0)
	var83 = var0.lo;	// _83 = Cast(_0 as u64)
	var78 = shr128(var0, 64);	// _78 = BinOp(_0 BIT_SHR +64 i32)
	var24 = var78.lo;	// _24 = Cast(_78 as u64)
	var79 = shr128(var1, 64);	// _79 = BinOp(_1 BIT_SHR +64 i32)
	var26 = var79.lo;	// _26 = Cast(_79 as u64)
	var25 = var26 - 0x1ull;	// _25 = BinOp(_26 SUB 0x1 u64)
	var84 = var24 & var25;	// _84 = BinOp(_24 BIT_AND _25)
	var80.lo = var83; var80.hi = var83 < 0 ? -1 : 0;	// _80 = Cast(_83 as u128)
	var82.lo = var84; var82.hi = var84 < 0 ? -1 : 0;	// _82 = Cast(_84 as u128)
	var81 = shl128(var82, 64);	// _81 = BinOp(_82 BIT_SHL +64 i32)
	(*var9) = or128(var80, var81);	// _9* = BinOp(_80 BIT_OR _81)
	// ^ drop(_9)
	// ^ Goto(47)
bb47:
	var77 = shr128(var0, 64);	// _77 = BinOp(_0 BIT_SHR +64 i32)
	var27 = var77.lo;	// _27 = Cast(_77 as u64)
	var85 = shr128(var1, 64);	// _85 = BinOp(_1 BIT_SHR +64 i32)
	var87 = var85.lo;	// _87 = Cast(_85 as u64)
	var86 = (var87 != 0 ? __builtin_ctz64(var87) : sizeof(uint64_t )*8);
	// ^ Call( _86 = "cttz"::<u64,>( _87, ), bb48, bb11)
	var28 = (uint32_t )var86;	// _28 = Cast(_86 as u32)
	var88 = var27 >> var28;	// _88 = BinOp(_27 BIT_SHR _28)
	rv.lo = var88; rv.hi = var88 < 0 ? -1 : 0;	// retval = Cast(_88 as u128)
	return rv;
	// ^ Return
bb49:
	var8 = var2.DATA.var_1._0;	// _8 = Use(_2#1.0)
	var67 = shr128(var0, 64);	// _67 = BinOp(_0 BIT_SHR +64 i32)
	var66 = var67.lo;	// _66 = Cast(_67 as u64)
	var69 = shr128(var1, 64);	// _69 = BinOp(_1 BIT_SHR +64 i32)
	var68 = var69.lo;	// _68 = Cast(_69 as u64)
	var72 = ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_rem0g( var66, var68 );
	// ^ Call( _72 = <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_rem( _66, _68, ), bb50, bb11)
	var71.lo = var72; var71.hi = var72 < 0 ? -1 : 0;	// _71 = Cast(_72 as u128)
	var70 = shl128(var71, 64);	// _70 = BinOp(_71 BIT_SHL +64 i32)
	(*var8) = or128(make128_raw(0ull, 0ull), var70);	// _8* = BinOp(0x0 u128 BIT_OR _70)
	// ^ drop(_8)
	// ^ Goto(51)
bb51:
	var65 = shr128(var0, 64);	// _65 = BinOp(_0 BIT_SHR +64 i32)
	var64 = var65.lo;	// _64 = Cast(_65 as u64)
	var74 = shr128(var1, 64);	// _74 = BinOp(_1 BIT_SHR +64 i32)
	var73 = var74.lo;	// _73 = Cast(_74 as u64)
	var75 = ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g( var64, var73 );
	// ^ Call( _75 = <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div( _64, _73, ), bb52, bb11)
	rv.lo = var75; rv.hi = var75 < 0 ? -1 : 0;	// retval = Cast(_75 as u128)
	return rv;
	// ^ Return
bb53:
	if( var2.DATA.var_1._0 != 0 )
		goto bb56;
	else
		goto bb58;
	// ^ Switch( _2 : 0 => bb58, 1 => bb56, )
bb54:
	if( var2.DATA.var_1._0 != 0 )
		goto bb55;
	else
		goto bb23;
	// ^ Switch( _2 : 0 => bb23, 1 => bb55, )
bb55:
	var4 = var2.DATA.var_1._0;	// _4 = Use(_2#1.0)
	(*var4) = var0;	// _4* = Use(_0)
	// ^ drop(_4)
	goto bb23;
	// ^ Goto(23)
bb56:
	var3 = var2.DATA.var_1._0;	// _3 = Use(_2#1.0)
	var55 = var0.lo;	// _55 = Cast(_0 as u64)
	var56 = var1.lo;	// _56 = Cast(_1 as u64)
	var57 = ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_rem0g( var55, var56 );
	// ^ Call( _57 = <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_rem( _55, _56, ), bb57, bb11)
	(*var3).lo = var57; (*var3).hi = var57 < 0 ? -1 : 0;	// _3* = Cast(_57 as u128)
	// ^ drop(_3)
	// ^ Goto(58)
bb58:
	var54 = var0.lo;	// _54 = Cast(_0 as u64)
	var58 = var1.lo;	// _58 = Cast(_1 as u64)
	var59 = ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g( var54, var58 );
	// ^ Call( _59 = <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div( _54, _58, ), bb59, bb11)
	rv.lo = var59; rv.hi = var59 < 0 ? -1 : 0;	// retval = Cast(_59 as u128)
	return rv;
	// ^ Return
}
// ::"compiler_builtins-0_0_0_Hb"::int::udiv::__udivsi3
uint32_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv9__udivsi30g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32

{
	uint32_t rv;
	uint32_t var0;	// u32
	uint32_t var1;	// u32
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	uint32_t var4;	// u32
	int32_t var5;	// i32
	RUST_BOOL var6;	// bool
	uint32_t var7;	// u32
	uint32_t var8;	// u32
	uint32_t var9;	// u32
	uint32_t var10;	// u32
	uint32_t var11;	// u32
	int32_t var12;	// i32
	int32_t var13;	// i32
	uint32_t var14;	// u32
	uint32_t var15;	// u32
	uint32_t var16;	// u32
	uint32_t var17;	// u32
	uint32_t var18;	// u32
	uint32_t var19;	// u32
	tBANG var20 = {0};	// !
	var6 = arg1 == 0x0;	// _6 = BinOp(a1 EQ 0x0 u32)
	if(var6) goto bb1; else goto bb2;
	// ^ If( _6 : 1, 2)
bb1:
	abort();
	goto bb7;
	// ^ Call( _20 = "abort"::( ), bb7, bb7)
bb2:
	var6 = arg0 == 0x0;	// _6 = BinOp(a0 EQ 0x0 u32)
	if(var6) goto bb8; else goto bb3;
	// ^ If( _6 : 8, 3)
bb3:
	var17 = (arg1 != 0 ? __builtin_clz(arg1) : sizeof(uint32_t )*8);
	// ^ Call( _17 = "ctlz"::<u32,>( a1, ), bb4, bb7)
	var18 = (arg0 != 0 ? __builtin_clz(arg0) : sizeof(uint32_t )*8);
	// ^ Call( _18 = "ctlz"::<u32,>( a0, ), bb5, bb7)
	__builtin_sub_overflow(var17, var18, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u32,>( _17, _18, ), bb6, bb7)
	var6 = var0 > 0x1f;	// _6 = BinOp(_0 GT 0x1f u32)
	if(var6) goto bb8; else goto bb9;
	// ^ If( _6 : 8, 9)
bb7: _Unwind_Resume(); // Diverge
bb8:
	rv = 0x0;	// retval = Constant(0x0 u32)
	return rv;
	// ^ Return
bb9:
	var6 = var0 == 0x1f;	// _6 = BinOp(_0 EQ 0x1f u32)
	if(var6) goto bb10; else goto bb11;
	// ^ If( _6 : 10, 11)
bb10:
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
bb11:
	var0 = var0 + 0x1;	// _0 = BinOp(_0 ADD 0x1 u32)
	var7 = 0x20 - var0;	// _7 = BinOp(0x20 u32 SUB _0)
	var1 = arg0 << var7;	// _1 = BinOp(a0 BIT_SHL _7)
	var2 = arg0 >> var0;	// _2 = BinOp(a0 BIT_SHR _0)
	var3 = 0x0;	// _3 = Constant(0x0 u32)
	var4 = 0x0;	// _4 = Constant(0x0 u32)
	// ^ Goto(12)
bb12:
	var6 = var4 < var0;	// _6 = BinOp(_4 LT _0)
	if(var6) goto bb13; else goto bb16;
	// ^ If( _6 : 13, 16)
bb13:
	var4 = var4 + 0x1;	// _4 = BinOp(_4 ADD 0x1 u32)
	var8 = var2 << 1;	// _8 = BinOp(_2 BIT_SHL +1 i32)
	var9 = var1 >> 0x1f;	// _9 = BinOp(_1 BIT_SHR 0x1f u32)
	var2 = var8 | var9;	// _2 = BinOp(_8 BIT_OR _9)
	var10 = var1 << 1;	// _10 = BinOp(_1 BIT_SHL +1 i32)
	var1 = var10 | var3;	// _1 = BinOp(_10 BIT_OR _3)
	__builtin_sub_overflow(arg1, var2, &var19);
	// ^ Call( _19 = "overflowing_sub"::<u32,>( a1, _2, ), bb14, bb7)
	__builtin_sub_overflow(var19, 0x1, &var11);
	// ^ Call( _11 = "overflowing_sub"::<u32,>( _19, 0x1 u32, ), bb15, bb7)
	var12 = (int32_t )var11;	// _12 = Cast(_11 as i32)
	var5 = var12 >> 0x1f;	// _5 = BinOp(_12 BIT_SHR 0x1f u32)
	var13 = var5 & 1;	// _13 = BinOp(_5 BIT_AND +1 i32)
	var3 = (uint32_t )var13;	// _3 = Cast(_13 as u32)
	var15 = (uint32_t )var5;	// _15 = Cast(_5 as u32)
	var14 = arg1 & var15;	// _14 = BinOp(a1 BIT_AND _15)
	var2 = var2 - var14;	// _2 = BinOp(_2 SUB _14)
	goto bb12;
	// ^ Goto(12)
bb16:
	var16 = var1 << 1;	// _16 = BinOp(_1 BIT_SHL +1 i32)
	rv = var16 | var3;	// retval = BinOp(_16 BIT_OR _3)
	return rv;
	// ^ Return
}
// ::"compiler_builtins-0_0_0_Hb"::int::udiv::__udivti3
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv9__udivti30g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128

{
	uint128_t rv;
	struct e_ZRG2cE9core0_0_06option6Option1gBuCi var0;	// ::"core-0_0_0"::option::Option<&'static mut u128,>/*E*/
	memset(&var0, 0, sizeof(struct e_ZRG2cE9core0_0_06option6Option1gBuCi ));	// _0 = Variant(::"core-0_0_0"::option::Option<&'static mut u128,> #0, {})
	rv = ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv12__udivmodti40g( arg0, arg1, var0 );
	// ^ Call( retval = ::"compiler_builtins-0_0_0_Hb"::int::udiv::__udivmodti4<'static,>( a0, a1, _0, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::udiv::__umoddi3
uint64_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv9__umoddi30g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64

{
	uint64_t rv;
	uint64_t var0;	// u64
	uint64_t *var1;	// &'#local0 mut u64
	struct e_ZRG2cE9core0_0_06option6Option1gBuCg var2;	// ::"core-0_0_0"::option::Option<&'#local0 mut u64,>/*E*/
	uint64_t var3;	// u64
	var0 = 0x0ull;	// _0 = Constant(0x0 u64)
	var1 = & var0;	// _1 = Borrow(Unique, _0)
	var2.DATA.var_1._0 = var1;	// _2 = Variant(::"core-0_0_0"::option::Option<&'#local0 mut u64,> #1, {_1})
	var3 = ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv12__udivmoddi40g( arg0, arg1, var2 );
	// ^ Call( _3 = ::"compiler_builtins-0_0_0_Hb"::int::udiv::__udivmoddi4<'#local0,>( a0, a1, _2, ), bb1, bb2)
	rv = var0;	// retval = Use(_0)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::udiv::__umodsi3
uint32_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv9__umodsi30g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32

{
	uint32_t rv;
	uint32_t var0;	// u32
	uint32_t var1;	// u32
	var0 = ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv9__udivsi30g( arg0, arg1 );
	// ^ Call( _0 = ::"compiler_builtins-0_0_0_Hb"::int::udiv::__udivsi3( a0, a1, ), bb1, bb2)
	var1 = var0 * arg1;	// _1 = BinOp(_0 MUL a1)
	rv = arg0 - var1;	// retval = BinOp(a0 SUB _1)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::udiv::__umodti3
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv9__umodti30g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128

{
	uint128_t rv;
	uint128_t var0;	// u128
	uint128_t *var1;	// &'#local0 mut u128
	struct e_ZRG2cE9core0_0_06option6Option1gBuCi var2;	// ::"core-0_0_0"::option::Option<&'#local0 mut u128,>/*E*/
	uint128_t var3;	// u128
	var0 = make128_raw(0ull, 0ull);	// _0 = Constant(0x0 u128)
	var1 = & var0;	// _1 = Borrow(Unique, _0)
	var2.DATA.var_1._0 = var1;	// _2 = Variant(::"core-0_0_0"::option::Option<&'#local0 mut u128,> #1, {_1})
	var3 = ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv12__udivmodti40g( arg0, arg1, var2 );
	// ^ Call( _3 = ::"compiler_builtins-0_0_0_Hb"::int::udiv::__udivmodti4<'#local0,>( a0, a1, _2, ), bb1, bb2)
	rv = var0;	// retval = Use(_0)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::udiv::rust_u128_div
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv13rust_u128_div0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128

{
	uint128_t rv;
	struct e_ZRG2cE9core0_0_06option6Option1gBuCi var0;	// ::"core-0_0_0"::option::Option<&'static mut u128,>/*E*/
	memset(&var0, 0, sizeof(struct e_ZRG2cE9core0_0_06option6Option1gBuCi ));	// _0 = Variant(::"core-0_0_0"::option::Option<&'static mut u128,> #0, {})
	rv = ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv12__udivmodti40g( arg0, arg1, var0 );
	// ^ Call( retval = ::"compiler_builtins-0_0_0_Hb"::int::udiv::__udivmodti4<'static,>( a0, a1, _0, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::udiv::rust_u128_rem
uint128_t  ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv13rust_u128_rem0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128

{
	uint128_t rv;
	uint128_t var0;	// u128
	uint128_t *var1;	// &'#local0 mut u128
	struct e_ZRG2cE9core0_0_06option6Option1gBuCi var2;	// ::"core-0_0_0"::option::Option<&'#local0 mut u128,>/*E*/
	uint128_t var3;	// u128
	var0 = make128_raw(0ull, 0ull);	// _0 = Constant(0x0 u128)
	var1 = & var0;	// _1 = Borrow(Unique, _0)
	var2.DATA.var_1._0 = var1;	// _2 = Variant(::"core-0_0_0"::option::Option<&'#local0 mut u128,> #1, {_1})
	var3 = ZRG3cR25compiler_builtins0_0_0_Hb3int4udiv12__udivmodti40g( arg0, arg1, var2 );
	// ^ Call( _3 = ::"compiler_builtins-0_0_0_Hb"::int::udiv::__udivmodti4<'#local0,>( a0, a1, _2, ), bb1, bb2)
	rv = var0;	// retval = Use(_0)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::unwrap<u32,>
uint32_t  ZRG2cR25compiler_builtins0_0_0_Hb3int6unwrap1gCe(
		struct e_ZRG2cE9core0_0_06option6Option1gCe arg0 // ::"core-0_0_0"::option::Option<u32,>/*E*/
		) // -> u32

{
	uint32_t rv;
	tBANG var0 = {0};	// !
	if( arg0.DATA.TAG == 0) {goto bb1;} else {goto bb2;}
	// ^ Switch( a0 : 0 => bb1, 1 => bb2, )
bb1:
	abort();
	goto bb3;
	// ^ Call( _0 = "abort"::( ), bb3, bb3)
bb2:
	rv = arg0.DATA.var_1._0;	// retval = Use(a0#1.0)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::unwrap<i32,>
int32_t  ZRG2cR25compiler_builtins0_0_0_Hb3int6unwrap1gCf(
		struct e_ZRG2cE9core0_0_06option6Option1gCf arg0 // ::"core-0_0_0"::option::Option<i32,>/*E*/
		) // -> i32

{
	int32_t rv;
	tBANG var0 = {0};	// !
	if( arg0.DATA.TAG == 0) {goto bb1;} else {goto bb2;}
	// ^ Switch( a0 : 0 => bb1, 1 => bb2, )
bb1:
	abort();
	goto bb3;
	// ^ Call( _0 = "abort"::( ), bb3, bb3)
bb2:
	rv = arg0.DATA.var_1._0;	// retval = Use(a0#1.0)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::unwrap<u64,>
uint64_t  ZRG2cR25compiler_builtins0_0_0_Hb3int6unwrap1gCg(
		struct e_ZRG2cE9core0_0_06option6Option1gCg arg0 // ::"core-0_0_0"::option::Option<u64,>/*E*/
		) // -> u64

{
	uint64_t rv;
	tBANG var0 = {0};	// !
	if( arg0.DATA.TAG == 0) {goto bb1;} else {goto bb2;}
	// ^ Switch( a0 : 0 => bb1, 1 => bb2, )
bb1:
	abort();
	goto bb3;
	// ^ Call( _0 = "abort"::( ), bb3, bb3)
bb2:
	rv = arg0.DATA.var_1._0;	// retval = Use(a0#1.0)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::unwrap<i64,>
int64_t  ZRG2cR25compiler_builtins0_0_0_Hb3int6unwrap1gCh(
		struct e_ZRG2cE9core0_0_06option6Option1gCh arg0 // ::"core-0_0_0"::option::Option<i64,>/*E*/
		) // -> i64

{
	int64_t rv;
	tBANG var0 = {0};	// !
	if( arg0.DATA.TAG == 0) {goto bb1;} else {goto bb2;}
	// ^ Switch( a0 : 0 => bb1, 1 => bb2, )
bb1:
	abort();
	goto bb3;
	// ^ Call( _0 = "abort"::( ), bb3, bb3)
bb2:
	rv = arg0.DATA.var_1._0;	// retval = Use(a0#1.0)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::unwrap<u128,>
uint128_t  ZRG2cR25compiler_builtins0_0_0_Hb3int6unwrap1gCi(
		struct e_ZRG2cE9core0_0_06option6Option1gCi arg0 // ::"core-0_0_0"::option::Option<u128,>/*E*/
		) // -> u128

{
	uint128_t rv;
	tBANG var0 = {0};	// !
	if( arg0.DATA.TAG == 0) {goto bb1;} else {goto bb2;}
	// ^ Switch( a0 : 0 => bb1, 1 => bb2, )
bb1:
	abort();
	goto bb3;
	// ^ Call( _0 = "abort"::( ), bb3, bb3)
bb2:
	rv = arg0.DATA.var_1._0;	// retval = Use(a0#1.0)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::int::unwrap<i128,>
int128_t  ZRG2cR25compiler_builtins0_0_0_Hb3int6unwrap1gCj(
		struct e_ZRG2cE9core0_0_06option6Option1gCj arg0 // ::"core-0_0_0"::option::Option<i128,>/*E*/
		) // -> i128

{
	int128_t rv;
	tBANG var0 = {0};	// !
	if( arg0.DATA.TAG == 0) {goto bb1;} else {goto bb2;}
	// ^ Switch( a0 : 0 => bb1, 1 => bb2, )
bb1:
	abort();
	goto bb3;
	// ^ Call( _0 = "abort"::( ), bb3, bb3)
bb2:
	rv = arg0.DATA.var_1._0;	// retval = Use(a0#1.0)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::mem::memcmp
int32_t  ZRG2cR25compiler_builtins0_0_0_Hb3mem6memcmp0g(
		uint8_t *arg0, // *const u8
		uint8_t *arg1, // *const u8
		uintptr_t arg2 // usize
		) // -> i32

{
	int32_t rv;
	uintptr_t var0;	// usize
	uint8_t var1;	// u8
	uint8_t var2;	// u8
	RUST_BOOL var3;	// bool
	uint8_t *var4;	// *const u8
	uint8_t *var5;	// *const u8
	int32_t var6;	// i32
	int32_t var7;	// i32
	intptr_t var8;	// isize
	intptr_t var9;	// isize
	var0 = 0x0ull;	// _0 = Constant(0x0 usize)
	// ^ Goto(1)
bb1:
	var3 = var0 < arg2;	// _3 = BinOp(_0 LT a2)
	if(var3) goto bb2; else goto bb5;
	// ^ If( _3 : 2, 5)
bb2:
	var8 = (intptr_t )var0;	// _8 = Cast(_0 as isize)
	var4 = arg0 + var8;
	// ^ Call( _4 = "offset"::<u8,>( a0, _8, ), bb3, bb6)
	var1 = (*var4);	// _1 = Use(_4*)
	var9 = (intptr_t )var0;	// _9 = Cast(_0 as isize)
	var5 = arg1 + var9;
	// ^ Call( _5 = "offset"::<u8,>( a1, _9, ), bb4, bb6)
	var2 = (*var5);	// _2 = Use(_5*)
	var3 = var1 != var2;	// _3 = BinOp(_1 NE _2)
	if(var3) goto bb7; else goto bb8;
	// ^ If( _3 : 7, 8)
bb5:
	rv = 0;	// retval = Constant(+0 i32)
	return rv;
	// ^ Return
bb6: _Unwind_Resume(); // Diverge
bb7:
	var6 = (int32_t )var1;	// _6 = Cast(_1 as i32)
	var7 = (int32_t )var2;	// _7 = Cast(_2 as i32)
	rv = var6 - var7;	// retval = BinOp(_6 SUB _7)
	return rv;
	// ^ Return
bb8:
	var0 = var0 + 0x1ull;	// _0 = BinOp(_0 ADD 0x1 usize)
	goto bb1;
	// ^ Goto(1)
}
// ::"compiler_builtins-0_0_0_Hb"::mem::memcpy
uint8_t * ZRG2cR25compiler_builtins0_0_0_Hb3mem6memcpy0g(
		uint8_t *arg0, // *mut u8
		uint8_t *arg1, // *const u8
		uintptr_t arg2 // usize
		) // -> *mut u8

{
	uint8_t *rv;
	uintptr_t var0;	// usize
	RUST_BOOL var1;	// bool
	uint8_t *var2;	// *const u8
	uint8_t *var3;	// *mut u8
	intptr_t var4;	// isize
	uint8_t *var5;	// *const u8
	uint8_t *var6;	// *const u8
	intptr_t var7;	// isize
	var0 = 0x0ull;	// _0 = Constant(0x0 usize)
	// ^ Goto(1)
bb1:
	var1 = var0 < arg2;	// _1 = BinOp(_0 LT a2)
	if(var1) goto bb2; else goto bb5;
	// ^ If( _1 : 2, 5)
bb2:
	var4 = (intptr_t )var0;	// _4 = Cast(_0 as isize)
	var2 = arg1 + var4;
	// ^ Call( _2 = "offset"::<u8,>( a1, _4, ), bb3, bb6)
	var7 = (intptr_t )var0;	// _7 = Cast(_0 as isize)
	var5 = (uint8_t *)arg0;	// _5 = Cast(a0 as *const u8)
	var6 = var5 + var7;
	// ^ Call( _6 = "offset"::<u8,>( _5, _7, ), bb4, bb6)
	var3 = (uint8_t *)var6;	// _3 = Cast(_6 as *mut u8)
	(*var3) = (*var2);	// _3* = Use(_2*)
	var0 = var0 + 0x1ull;	// _0 = BinOp(_0 ADD 0x1 usize)
	goto bb1;
	// ^ Goto(1)
bb5:
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
bb6: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::mem::memmove
uint8_t * ZRG2cR25compiler_builtins0_0_0_Hb3mem7memmove0g(
		uint8_t *arg0, // *mut u8
		uint8_t *arg1, // *const u8
		uintptr_t arg2 // usize
		) // -> *mut u8

{
	uint8_t *rv;
	uintptr_t var0;	// usize
	uintptr_t var1;	// usize
	RUST_BOOL var2;	// bool
	uint8_t *var3;	// *const u8
	uint8_t *var4;	// *const u8
	uint8_t *var5;	// *mut u8
	uint8_t *var6;	// *const u8
	uint8_t *var7;	// *mut u8
	intptr_t var8;	// isize
	uint8_t *var9;	// *const u8
	uint8_t *var10;	// *const u8
	intptr_t var11;	// isize
	intptr_t var12;	// isize
	uint8_t *var13;	// *const u8
	uint8_t *var14;	// *const u8
	intptr_t var15;	// isize
	var3 = (uint8_t *)arg0;	// _3 = Cast(a0 as *const u8)
	var2 = arg1 < var3;	// _2 = BinOp(a1 LT _3)
	if(var2) goto bb1; else goto bb3;
	// ^ If( _2 : 1, 3)
bb1:
	var0 = arg2;	// _0 = Use(a2)
	// ^ Goto(2)
bb2:
	var2 = var0 != 0x0ull;	// _2 = BinOp(_0 NE 0x0 usize)
	if(var2) goto bb10; else goto bb8;
	// ^ If( _2 : 10, 8)
bb3:
	var1 = 0x0ull;	// _1 = Constant(0x0 usize)
	// ^ Goto(4)
bb4:
	var2 = var1 < arg2;	// _2 = BinOp(_1 LT a2)
	if(var2) goto bb5; else goto bb8;
	// ^ If( _2 : 5, 8)
bb5:
	var12 = (intptr_t )var1;	// _12 = Cast(_1 as isize)
	var6 = arg1 + var12;
	// ^ Call( _6 = "offset"::<u8,>( a1, _12, ), bb6, bb9)
	var15 = (intptr_t )var1;	// _15 = Cast(_1 as isize)
	var13 = (uint8_t *)arg0;	// _13 = Cast(a0 as *const u8)
	var14 = var13 + var15;
	// ^ Call( _14 = "offset"::<u8,>( _13, _15, ), bb7, bb9)
	var7 = (uint8_t *)var14;	// _7 = Cast(_14 as *mut u8)
	(*var7) = (*var6);	// _7* = Use(_6*)
	var1 = var1 + 0x1ull;	// _1 = BinOp(_1 ADD 0x1 usize)
	goto bb4;
	// ^ Goto(4)
bb8:
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
bb9: _Unwind_Resume(); // Diverge
bb10:
	var0 = var0 - 0x1ull;	// _0 = BinOp(_0 SUB 0x1 usize)
	var8 = (intptr_t )var0;	// _8 = Cast(_0 as isize)
	var4 = arg1 + var8;
	// ^ Call( _4 = "offset"::<u8,>( a1, _8, ), bb11, bb9)
	var11 = (intptr_t )var0;	// _11 = Cast(_0 as isize)
	var9 = (uint8_t *)arg0;	// _9 = Cast(a0 as *const u8)
	var10 = var9 + var11;
	// ^ Call( _10 = "offset"::<u8,>( _9, _11, ), bb12, bb9)
	var5 = (uint8_t *)var10;	// _5 = Cast(_10 as *mut u8)
	(*var5) = (*var4);	// _5* = Use(_4*)
	goto bb2;
	// ^ Goto(2)
}
// ::"compiler_builtins-0_0_0_Hb"::mem::memset
uint8_t * ZRG2cR25compiler_builtins0_0_0_Hb3mem6memset0g(
		uint8_t *arg0, // *mut u8
		int32_t arg1, // i32
		uintptr_t arg2 // usize
		) // -> *mut u8

{
	uint8_t *rv;
	uintptr_t var0;	// usize
	RUST_BOOL var1;	// bool
	uint8_t var2;	// u8
	uint8_t *var3;	// *mut u8
	uint8_t *var4;	// *const u8
	uint8_t *var5;	// *const u8
	intptr_t var6;	// isize
	var0 = 0x0ull;	// _0 = Constant(0x0 usize)
	// ^ Goto(1)
bb1:
	var1 = var0 < arg2;	// _1 = BinOp(_0 LT a2)
	if(var1) goto bb2; else goto bb4;
	// ^ If( _1 : 2, 4)
bb2:
	var2 = (uint8_t )arg1;	// _2 = Cast(a1 as u8)
	var6 = (intptr_t )var0;	// _6 = Cast(_0 as isize)
	var4 = (uint8_t *)arg0;	// _4 = Cast(a0 as *const u8)
	var5 = var4 + var6;
	// ^ Call( _5 = "offset"::<u8,>( _4, _6, ), bb3, bb5)
	var3 = (uint8_t *)var5;	// _3 = Cast(_5 as *mut u8)
	(*var3) = var2;	// _3* = Use(_2)
	var0 = var0 + 0x1ull;	// _0 = BinOp(_0 ADD 0x1 usize)
	goto bb1;
	// ^ Goto(1)
bb4:
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
bb5: _Unwind_Resume(); // Diverge
}
// ::"compiler_builtins-0_0_0_Hb"::probestack::__rust_probestack
void  ZRG2cR25compiler_builtins0_0_0_Hb10probestack17__rust_probestack0g(void) // -> ()

{
	tUNIT rv;
	tBANG var0 = {0};	// !
	__asm__ __volatile__(";\n        mov    %%rax,%%r11        ": : : "memory");
	// ^ () = llvm_asm!("\n        mov    %rax,%r11        // duplicate %rax as we're clobbering %r11\n\n        // Main loop, taken in one page increments. We're decrementing rsp by\n        // a page each time until there's less than a page remaining. We're\n        // guaranteed that this function isn't called unless there's more than a\n        // page needed.\n        //\n        // Note that we're also testing against `8(%rsp)` to account for the 8\n        // bytes pushed on the stack orginally with our return address. Using\n        // `8(%rsp)` simulates us testing the stack pointer in the caller's\n        // context.\n\n        // It's usually called when %rax >= 0x1000, but that's not always true.\n        // Dynamic stack allocation, which is needed to implement unsized\n        // rvalues, triggers stackprobe even if %rax < 0x1000.\n        // Thus we have to check %r11 first to avoid segfault.\n        cmp    $$0x1000,%r11\n        jna    3f\n    2:\n        sub    $$0x1000,%rsp\n        test   %rsp,8(%rsp)\n        sub    $$0x1000,%r11\n        cmp    $$0x1000,%r11\n        ja     2b\n\n    3:\n        // Finish up the last remaining stack space requested, getting the last\n        // bits out of r11\n        sub    %r11,%rsp\n        test   %rsp,8(%rsp)\n\n        // Restore the stack pointer to what it previously was when entering\n        // this function. The caller will readjust the stack pointer after we\n        // return.\n        add    %rax,%rsp\n\n        ret\n    ", input=( ), clobbers=[memory], flags=[volatile])
	__builtin_unreachable();
	// ^ Call( _0 = "unreachable"::( ), bb1, bb1)
bb1: _Unwind_Resume(); // Diverge
}
// <u32 /*- */>::checked_div
static struct e_ZRG2cE9core0_0_06option6Option1gCe  ZRICe11checked_div0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> ::"core-0_0_0"::option::Option<u32,>/*E*/

{
	struct e_ZRG2cE9core0_0_06option6Option1gCe rv;
	RUST_BOOL var0;	// bool
	uint32_t var1;	// u32
	var0 = arg1 == 0x0;	// _0 = BinOp(a1 EQ 0x0 u32)
	if(var0) goto bb1; else goto bb2;
	// ^ If( _0 : 1, 2)
bb1:
	rv.DATA.TAG = 0;	// retval = Variant(::"core-0_0_0"::option::Option<u32,> #0, {})
	return rv;
	// ^ Return
bb2:
	var1 = arg0 / arg1;
	// ^ Call( _1 = "unchecked_div"::<u32,>( a0, a1, ), bb3, bb4)
	rv.DATA.TAG = 1;
	rv.DATA.var_1._0 = var1;	// retval = Variant(::"core-0_0_0"::option::Option<u32,> #1, {_1})
	return rv;
	// ^ Return
bb4: _Unwind_Resume(); // Diverge
}
// <u32 /*- */>::checked_rem
static struct e_ZRG2cE9core0_0_06option6Option1gCe  ZRICe11checked_rem0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> ::"core-0_0_0"::option::Option<u32,>/*E*/

{
	struct e_ZRG2cE9core0_0_06option6Option1gCe rv;
	RUST_BOOL var0;	// bool
	uint32_t var1;	// u32
	var0 = arg1 == 0x0;	// _0 = BinOp(a1 EQ 0x0 u32)
	if(var0) goto bb1; else goto bb2;
	// ^ If( _0 : 1, 2)
bb1:
	rv.DATA.TAG = 0;	// retval = Variant(::"core-0_0_0"::option::Option<u32,> #0, {})
	return rv;
	// ^ Return
bb2:
	var1 = arg0 % arg1;
	// ^ Call( _1 = "unchecked_rem"::<u32,>( a0, a1, ), bb3, bb4)
	rv.DATA.TAG = 1;
	rv.DATA.var_1._0 = var1;	// retval = Variant(::"core-0_0_0"::option::Option<u32,> #1, {_1})
	return rv;
	// ^ Return
bb4: _Unwind_Resume(); // Diverge
}
// <u32 /*- */>::is_power_of_two
static RUST_BOOL  ZRICe15is_power_of_two0g(
		uint32_t arg0 // u32
		) // -> bool

{
	RUST_BOOL rv;
	RUST_BOOL var0;	// bool
	uint32_t var1;	// u32
	uint32_t var2;	// u32
	RUST_BOOL var3;	// bool
	__builtin_sub_overflow(arg0, 0x1, &var2);
	// ^ Call( _2 = "overflowing_sub"::<u32,>( a0, 0x1 u32, ), bb1, bb2)
	var1 = var2 & arg0;	// _1 = BinOp(_2 BIT_AND a0)
	var0 = var1 == 0x0;	// _0 = BinOp(_1 EQ 0x0 u32)
	if(var0) goto bb3; else goto bb4;
	// ^ If( _0 : 3, 4)
bb2: _Unwind_Resume(); // Diverge
bb3:
	var3 = arg0 == 0x0;	// _3 = BinOp(a0 EQ 0x0 u32)
	rv = !var3;	// retval = UniOp(_3 INV)
	return rv;
	// ^ Return
bb4:
	rv = false;	// retval = Constant(false)
	return rv;
	// ^ Return
}
// <i32 /*- */>::checked_div
static struct e_ZRG2cE9core0_0_06option6Option1gCf  ZRICf11checked_div0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> ::"core-0_0_0"::option::Option<i32,>/*E*/

{
	struct e_ZRG2cE9core0_0_06option6Option1gCf rv;
	RUST_BOOL var0;	// bool
	int32_t var1;	// i32
	var0 = arg1 == 0;	// _0 = BinOp(a1 EQ +0 i32)
	if(var0) goto bb6; else goto bb1;
	// ^ If( _0 : 6, 1)
bb1:
	var0 = arg0 == -2147483648;	// _0 = BinOp(a0 EQ -2147483648 i32)
	if(var0) goto bb2; else goto bb3;
	// ^ If( _0 : 2, 3)
bb2:
	var0 = arg1 == -1;	// _0 = BinOp(a1 EQ -1 i32)
	if(var0) goto bb6; else goto bb3;
	// ^ If( _0 : 6, 3)
bb3:
	var1 = arg0 / arg1;
	// ^ Call( _1 = "unchecked_div"::<i32,>( a0, a1, ), bb4, bb5)
	rv.DATA.TAG = 1;
	rv.DATA.var_1._0 = var1;	// retval = Variant(::"core-0_0_0"::option::Option<i32,> #1, {_1})
	return rv;
	// ^ Return
bb5: _Unwind_Resume(); // Diverge
bb6:
	rv.DATA.TAG = 0;	// retval = Variant(::"core-0_0_0"::option::Option<i32,> #0, {})
	return rv;
	// ^ Return
}
// <i32 /*- */>::checked_rem
static struct e_ZRG2cE9core0_0_06option6Option1gCf  ZRICf11checked_rem0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> ::"core-0_0_0"::option::Option<i32,>/*E*/

{
	struct e_ZRG2cE9core0_0_06option6Option1gCf rv;
	RUST_BOOL var0;	// bool
	int32_t var1;	// i32
	var0 = arg1 == 0;	// _0 = BinOp(a1 EQ +0 i32)
	if(var0) goto bb6; else goto bb1;
	// ^ If( _0 : 6, 1)
bb1:
	var0 = arg0 == -2147483648;	// _0 = BinOp(a0 EQ -2147483648 i32)
	if(var0) goto bb2; else goto bb3;
	// ^ If( _0 : 2, 3)
bb2:
	var0 = arg1 == -1;	// _0 = BinOp(a1 EQ -1 i32)
	if(var0) goto bb6; else goto bb3;
	// ^ If( _0 : 6, 3)
bb3:
	var1 = arg0 % arg1;
	// ^ Call( _1 = "unchecked_rem"::<i32,>( a0, a1, ), bb4, bb5)
	rv.DATA.TAG = 1;
	rv.DATA.var_1._0 = var1;	// retval = Variant(::"core-0_0_0"::option::Option<i32,> #1, {_1})
	return rv;
	// ^ Return
bb5: _Unwind_Resume(); // Diverge
bb6:
	rv.DATA.TAG = 0;	// retval = Variant(::"core-0_0_0"::option::Option<i32,> #0, {})
	return rv;
	// ^ Return
}
// <i32 /*- */>::overflowing_neg
static TUP_2_ZRTCf_ZRTCw  ZRICf15overflowing_neg0g(
		int32_t arg0 // i32
		) // -> (i32, bool, )

{
	TUP_2_ZRTCf_ZRTCw rv;
	RUST_BOOL var0;	// bool
	int32_t var1;	// i32
	var0 = arg0 == -2147483648;	// _0 = BinOp(a0 EQ -2147483648 i32)
	if(var0) goto bb1; else goto bb2;
	// ^ If( _0 : 1, 2)
bb1:
	;
	rv._0 = -2147483648;
	rv._1 = true;	// retval = Tuple(-2147483648 i32, true)
	return rv;
	// ^ Return
bb2:
	var1 = -arg0;	// _1 = UniOp(a0 NEG)
	;
	rv._0 = var1;
	rv._1 = false;	// retval = Tuple(_1, false)
	return rv;
	// ^ Return
}
// <u64 /*- */>::checked_div
static struct e_ZRG2cE9core0_0_06option6Option1gCg  ZRICg11checked_div0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> ::"core-0_0_0"::option::Option<u64,>/*E*/

{
	struct e_ZRG2cE9core0_0_06option6Option1gCg rv;
	RUST_BOOL var0;	// bool
	uint64_t var1;	// u64
	var0 = arg1 == 0x0ull;	// _0 = BinOp(a1 EQ 0x0 u64)
	if(var0) goto bb1; else goto bb2;
	// ^ If( _0 : 1, 2)
bb1:
	rv.DATA.TAG = 0;	// retval = Variant(::"core-0_0_0"::option::Option<u64,> #0, {})
	return rv;
	// ^ Return
bb2:
	var1 = arg0 / arg1;
	// ^ Call( _1 = "unchecked_div"::<u64,>( a0, a1, ), bb3, bb4)
	rv.DATA.TAG = 1;
	rv.DATA.var_1._0 = var1;	// retval = Variant(::"core-0_0_0"::option::Option<u64,> #1, {_1})
	return rv;
	// ^ Return
bb4: _Unwind_Resume(); // Diverge
}
// <u64 /*- */>::checked_rem
static struct e_ZRG2cE9core0_0_06option6Option1gCg  ZRICg11checked_rem0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> ::"core-0_0_0"::option::Option<u64,>/*E*/

{
	struct e_ZRG2cE9core0_0_06option6Option1gCg rv;
	RUST_BOOL var0;	// bool
	uint64_t var1;	// u64
	var0 = arg1 == 0x0ull;	// _0 = BinOp(a1 EQ 0x0 u64)
	if(var0) goto bb1; else goto bb2;
	// ^ If( _0 : 1, 2)
bb1:
	rv.DATA.TAG = 0;	// retval = Variant(::"core-0_0_0"::option::Option<u64,> #0, {})
	return rv;
	// ^ Return
bb2:
	var1 = arg0 % arg1;
	// ^ Call( _1 = "unchecked_rem"::<u64,>( a0, a1, ), bb3, bb4)
	rv.DATA.TAG = 1;
	rv.DATA.var_1._0 = var1;	// retval = Variant(::"core-0_0_0"::option::Option<u64,> #1, {_1})
	return rv;
	// ^ Return
bb4: _Unwind_Resume(); // Diverge
}
// <u64 /*- */>::is_power_of_two
static RUST_BOOL  ZRICg15is_power_of_two0g(
		uint64_t arg0 // u64
		) // -> bool

{
	RUST_BOOL rv;
	RUST_BOOL var0;	// bool
	uint64_t var1;	// u64
	uint64_t var2;	// u64
	RUST_BOOL var3;	// bool
	__builtin_sub_overflow(arg0, 0x1ull, &var2);
	// ^ Call( _2 = "overflowing_sub"::<u64,>( a0, 0x1 u64, ), bb1, bb2)
	var1 = var2 & arg0;	// _1 = BinOp(_2 BIT_AND a0)
	var0 = var1 == 0x0ull;	// _0 = BinOp(_1 EQ 0x0 u64)
	if(var0) goto bb3; else goto bb4;
	// ^ If( _0 : 3, 4)
bb2: _Unwind_Resume(); // Diverge
bb3:
	var3 = arg0 == 0x0ull;	// _3 = BinOp(a0 EQ 0x0 u64)
	rv = !var3;	// retval = UniOp(_3 INV)
	return rv;
	// ^ Return
bb4:
	rv = false;	// retval = Constant(false)
	return rv;
	// ^ Return
}
// <i64 /*- */>::checked_div
static struct e_ZRG2cE9core0_0_06option6Option1gCh  ZRICh11checked_div0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> ::"core-0_0_0"::option::Option<i64,>/*E*/

{
	struct e_ZRG2cE9core0_0_06option6Option1gCh rv;
	RUST_BOOL var0;	// bool
	int64_t var1;	// i64
	var0 = arg1 == 0ll;	// _0 = BinOp(a1 EQ +0 i64)
	if(var0) goto bb6; else goto bb1;
	// ^ If( _0 : 6, 1)
bb1:
	var0 = arg0 == INT64_MIN;	// _0 = BinOp(a0 EQ -9223372036854775808 i64)
	if(var0) goto bb2; else goto bb3;
	// ^ If( _0 : 2, 3)
bb2:
	var0 = arg1 == -1ll;	// _0 = BinOp(a1 EQ -1 i64)
	if(var0) goto bb6; else goto bb3;
	// ^ If( _0 : 6, 3)
bb3:
	var1 = arg0 / arg1;
	// ^ Call( _1 = "unchecked_div"::<i64,>( a0, a1, ), bb4, bb5)
	rv.DATA.TAG = 1;
	rv.DATA.var_1._0 = var1;	// retval = Variant(::"core-0_0_0"::option::Option<i64,> #1, {_1})
	return rv;
	// ^ Return
bb5: _Unwind_Resume(); // Diverge
bb6:
	rv.DATA.TAG = 0;	// retval = Variant(::"core-0_0_0"::option::Option<i64,> #0, {})
	return rv;
	// ^ Return
}
// <i64 /*- */>::checked_rem
static struct e_ZRG2cE9core0_0_06option6Option1gCh  ZRICh11checked_rem0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> ::"core-0_0_0"::option::Option<i64,>/*E*/

{
	struct e_ZRG2cE9core0_0_06option6Option1gCh rv;
	RUST_BOOL var0;	// bool
	int64_t var1;	// i64
	var0 = arg1 == 0ll;	// _0 = BinOp(a1 EQ +0 i64)
	if(var0) goto bb6; else goto bb1;
	// ^ If( _0 : 6, 1)
bb1:
	var0 = arg0 == INT64_MIN;	// _0 = BinOp(a0 EQ -9223372036854775808 i64)
	if(var0) goto bb2; else goto bb3;
	// ^ If( _0 : 2, 3)
bb2:
	var0 = arg1 == -1ll;	// _0 = BinOp(a1 EQ -1 i64)
	if(var0) goto bb6; else goto bb3;
	// ^ If( _0 : 6, 3)
bb3:
	var1 = arg0 % arg1;
	// ^ Call( _1 = "unchecked_rem"::<i64,>( a0, a1, ), bb4, bb5)
	rv.DATA.TAG = 1;
	rv.DATA.var_1._0 = var1;	// retval = Variant(::"core-0_0_0"::option::Option<i64,> #1, {_1})
	return rv;
	// ^ Return
bb5: _Unwind_Resume(); // Diverge
bb6:
	rv.DATA.TAG = 0;	// retval = Variant(::"core-0_0_0"::option::Option<i64,> #0, {})
	return rv;
	// ^ Return
}
// <i64 /*- */>::overflowing_neg
static TUP_2_ZRTCh_ZRTCw  ZRICh15overflowing_neg0g(
		int64_t arg0 // i64
		) // -> (i64, bool, )

{
	TUP_2_ZRTCh_ZRTCw rv;
	RUST_BOOL var0;	// bool
	int64_t var1;	// i64
	var0 = arg0 == INT64_MIN;	// _0 = BinOp(a0 EQ -9223372036854775808 i64)
	if(var0) goto bb1; else goto bb2;
	// ^ If( _0 : 1, 2)
bb1:
	;
	rv._0 = INT64_MIN;
	rv._1 = true;	// retval = Tuple(-9223372036854775808 i64, true)
	return rv;
	// ^ Return
bb2:
	var1 = -arg0;	// _1 = UniOp(a0 NEG)
	;
	rv._0 = var1;
	rv._1 = false;	// retval = Tuple(_1, false)
	return rv;
	// ^ Return
}
// <u128 /*- */>::checked_div
static struct e_ZRG2cE9core0_0_06option6Option1gCi  ZRICi11checked_div0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> ::"core-0_0_0"::option::Option<u128,>/*E*/

{
	struct e_ZRG2cE9core0_0_06option6Option1gCi rv;
	RUST_BOOL var0;	// bool
	uint128_t var1;	// u128
	var0 = 0 == cmp128(make128_raw(0ull, 0ull), arg1);	// _0 = BinOp(a1 EQ 0x0 u128)
	if(var0) goto bb1; else goto bb2;
	// ^ If( _0 : 1, 2)
bb1:
	rv.DATA.TAG = 0;	// retval = Variant(::"core-0_0_0"::option::Option<u128,> #0, {})
	return rv;
	// ^ Return
bb2:
	var1 = div128(arg0, arg1);
	// ^ Call( _1 = "unchecked_div"::<u128,>( a0, a1, ), bb3, bb4)
	rv.DATA.TAG = 1;
	rv.DATA.var_1._0 = var1;	// retval = Variant(::"core-0_0_0"::option::Option<u128,> #1, {_1})
	return rv;
	// ^ Return
bb4: _Unwind_Resume(); // Diverge
}
// <u128 /*- */>::checked_rem
static struct e_ZRG2cE9core0_0_06option6Option1gCi  ZRICi11checked_rem0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> ::"core-0_0_0"::option::Option<u128,>/*E*/

{
	struct e_ZRG2cE9core0_0_06option6Option1gCi rv;
	RUST_BOOL var0;	// bool
	uint128_t var1;	// u128
	var0 = 0 == cmp128(make128_raw(0ull, 0ull), arg1);	// _0 = BinOp(a1 EQ 0x0 u128)
	if(var0) goto bb1; else goto bb2;
	// ^ If( _0 : 1, 2)
bb1:
	rv.DATA.TAG = 0;	// retval = Variant(::"core-0_0_0"::option::Option<u128,> #0, {})
	return rv;
	// ^ Return
bb2:
	var1 = mod128(arg0, arg1);
	// ^ Call( _1 = "unchecked_rem"::<u128,>( a0, a1, ), bb3, bb4)
	rv.DATA.TAG = 1;
	rv.DATA.var_1._0 = var1;	// retval = Variant(::"core-0_0_0"::option::Option<u128,> #1, {_1})
	return rv;
	// ^ Return
bb4: _Unwind_Resume(); // Diverge
}
// <i128 /*- */>::checked_div
static struct e_ZRG2cE9core0_0_06option6Option1gCj  ZRICj11checked_div0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> ::"core-0_0_0"::option::Option<i128,>/*E*/

{
	struct e_ZRG2cE9core0_0_06option6Option1gCj rv;
	RUST_BOOL var0;	// bool
	int128_t var1;	// i128
	var0 = 0 == cmp128s(make128s_raw(0ull, 0ull), arg1);	// _0 = BinOp(a1 EQ +0 i128)
	if(var0) goto bb6; else goto bb1;
	// ^ If( _0 : 6, 1)
bb1:
	var0 = 0 == cmp128s(make128s_raw(9223372036854775808ull, 0ull), arg0);	// _0 = BinOp(a0 EQ --170141183460469231731687303715884105728 i128)
	if(var0) goto bb2; else goto bb3;
	// ^ If( _0 : 2, 3)
bb2:
	var0 = 0 == cmp128s(make128s_raw(18446744073709551615ull, 18446744073709551615ull), arg1);	// _0 = BinOp(a1 EQ -1 i128)
	if(var0) goto bb6; else goto bb3;
	// ^ If( _0 : 6, 3)
bb3:
	var1 = div128s(arg0, arg1);
	// ^ Call( _1 = "unchecked_div"::<i128,>( a0, a1, ), bb4, bb5)
	rv.DATA.TAG = 1;
	rv.DATA.var_1._0 = var1;	// retval = Variant(::"core-0_0_0"::option::Option<i128,> #1, {_1})
	return rv;
	// ^ Return
bb5: _Unwind_Resume(); // Diverge
bb6:
	rv.DATA.TAG = 0;	// retval = Variant(::"core-0_0_0"::option::Option<i128,> #0, {})
	return rv;
	// ^ Return
}
// <i128 /*- */>::checked_rem
static struct e_ZRG2cE9core0_0_06option6Option1gCj  ZRICj11checked_rem0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> ::"core-0_0_0"::option::Option<i128,>/*E*/

{
	struct e_ZRG2cE9core0_0_06option6Option1gCj rv;
	RUST_BOOL var0;	// bool
	int128_t var1;	// i128
	var0 = 0 == cmp128s(make128s_raw(0ull, 0ull), arg1);	// _0 = BinOp(a1 EQ +0 i128)
	if(var0) goto bb6; else goto bb1;
	// ^ If( _0 : 6, 1)
bb1:
	var0 = 0 == cmp128s(make128s_raw(9223372036854775808ull, 0ull), arg0);	// _0 = BinOp(a0 EQ --170141183460469231731687303715884105728 i128)
	if(var0) goto bb2; else goto bb3;
	// ^ If( _0 : 2, 3)
bb2:
	var0 = 0 == cmp128s(make128s_raw(18446744073709551615ull, 18446744073709551615ull), arg1);	// _0 = BinOp(a1 EQ -1 i128)
	if(var0) goto bb6; else goto bb3;
	// ^ If( _0 : 6, 3)
bb3:
	var1 = mod128s(arg0, arg1);
	// ^ Call( _1 = "unchecked_rem"::<i128,>( a0, a1, ), bb4, bb5)
	rv.DATA.TAG = 1;
	rv.DATA.var_1._0 = var1;	// retval = Variant(::"core-0_0_0"::option::Option<i128,> #1, {_1})
	return rv;
	// ^ Return
bb5: _Unwind_Resume(); // Diverge
bb6:
	rv.DATA.TAG = 0;	// retval = Variant(::"core-0_0_0"::option::Option<i128,> #0, {})
	return rv;
	// ^ Return
}
// <::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/ /*- */>::to_ge_abi
int32_t  ZRIG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g9to_ge_abi0g(
		struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g arg0 // ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
		) // -> i32

{
	int32_t rv;
	switch(arg0.TAG) {
	case 0: goto bb3;break;
	case 1: goto bb1;break;
	case 2: goto bb2;break;
	case 3: goto bb3;break;
	default: abort();
	}
	// ^ Switch( a0 : 0 => bb3, 1 => bb1, 2 => bb2, 3 => bb3, )
bb1:
	rv = 0;	// retval = Constant(+0 i32)
	return rv;
	// ^ Return
bb2:
	rv = 1;	// retval = Constant(+1 i32)
	return rv;
	// ^ Return
bb3:
	rv = -1;	// retval = Constant(-1 i32)
	return rv;
	// ^ Return
}
// <::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/ /*- */>::to_le_abi
int32_t  ZRIG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g9to_le_abi0g(
		struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g arg0 // ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
		) // -> i32

{
	int32_t rv;
	switch(arg0.TAG) {
	case 0: goto bb1;break;
	case 1: goto bb2;break;
	case 2: goto bb3;break;
	case 3: goto bb3;break;
	default: abort();
	}
	// ^ Switch( a0 : 0 => bb1, 1 => bb2, 2 => bb3, 3 => bb3, )
bb1:
	rv = -1;	// retval = Constant(-1 i32)
	return rv;
	// ^ Return
bb2:
	rv = 0;	// retval = Constant(+0 i32)
	return rv;
	// ^ Return
bb3:
	rv = 1;	// retval = Constant(+1 i32)
	return rv;
	// ^ Return
}
// <::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmoddi4_1/*S*/ /*- */>::call_free
int64_t  ZRIG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmoddi4_10g9call_free0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64

{
	int64_t rv;
	rv = ZRQCh3cR25compiler_builtins0_0_0_Hb3int4sdiv3Div0g3div0g( arg0, arg1 );
	// ^ Call( retval = <i64 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Div>::div( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmodsi4_0/*S*/ /*- */>::call_free
int32_t  ZRIG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmodsi4_00g9call_free0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32

{
	int32_t rv;
	rv = ZRQCf3cR25compiler_builtins0_0_0_Hb3int4sdiv3Div0g3div0g( arg0, arg1 );
	// ^ Call( retval = <i32 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Div>::div( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<usize,>>::cast
uintptr_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCu4cast0g(
		uint32_t arg0 // u32
		) // -> usize

{
	uintptr_t rv;
	rv = (uintptr_t )arg0;	// retval = Cast(a0 as usize)
	return rv;
	// ^ Return
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<isize,>>::cast
intptr_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCv4cast0g(
		uint32_t arg0 // u32
		) // -> isize

{
	intptr_t rv;
	rv = (intptr_t )arg0;	// retval = Cast(a0 as isize)
	return rv;
	// ^ Return
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u32,>>::cast
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCe4cast0g(
		uint32_t arg0 // u32
		) // -> u32

{
	uint32_t rv;
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i32,>>::cast
int32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCf4cast0g(
		uint32_t arg0 // u32
		) // -> i32

{
	int32_t rv;
	rv = (int32_t )arg0;	// retval = Cast(a0 as i32)
	return rv;
	// ^ Return
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u64,>>::cast
uint64_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCg4cast0g(
		uint32_t arg0 // u32
		) // -> u64

{
	uint64_t rv;
	rv = (uint64_t )arg0;	// retval = Cast(a0 as u64)
	return rv;
	// ^ Return
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i64,>>::cast
int64_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCh4cast0g(
		uint32_t arg0 // u32
		) // -> i64

{
	int64_t rv;
	rv = (int64_t )arg0;	// retval = Cast(a0 as i64)
	return rv;
	// ^ Return
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u128,>>::cast
uint128_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCi4cast0g(
		uint32_t arg0 // u32
		) // -> u128

{
	uint128_t rv;
	rv.lo = arg0; rv.hi = arg0 < 0 ? -1 : 0;	// retval = Cast(a0 as u128)
	return rv;
	// ^ Return
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i128,>>::cast
int128_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCj4cast0g(
		uint32_t arg0 // u32
		) // -> i128

{
	int128_t rv;
	rv.lo = arg0; rv.hi = arg0 < 0 ? -1 : 0;	// retval = Cast(a0 as i128)
	return rv;
	// ^ Return
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32

{
	uint32_t rv;
	struct e_ZRG2cE9core0_0_06option6Option1gCe var0;	// ::"core-0_0_0"::option::Option<u32,>/*E*/
	var0 = ZRICe11checked_div0g( arg0, arg1 );
	// ^ Call( _0 = <u32 /*- */>::checked_div( a0, a1, ), bb1, bb3)
	rv = ZRG2cR25compiler_builtins0_0_0_Hb3int6unwrap1gCe( var0 );
	// ^ Call( retval = ::"compiler_builtins-0_0_0_Hb"::int::unwrap<u32,>( _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_rem
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_rem0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32

{
	uint32_t rv;
	struct e_ZRG2cE9core0_0_06option6Option1gCe var0;	// ::"core-0_0_0"::option::Option<u32,>/*E*/
	var0 = ZRICe11checked_rem0g( arg0, arg1 );
	// ^ Call( _0 = <u32 /*- */>::checked_rem( a0, a1, ), bb1, bb3)
	rv = ZRG2cR25compiler_builtins0_0_0_Hb3int6unwrap1gCe( var0 );
	// ^ Call( retval = ::"compiler_builtins-0_0_0_Hb"::int::unwrap<u32,>( _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::extract_sign
TUP_2_ZRTCw_ZRTCe  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g12extract_sign0g(
		uint32_t arg0 // u32
		) // -> (bool, u32, )

{
	TUP_2_ZRTCw_ZRTCe rv;
	;
	rv._0 = false;
	rv._1 = arg0;	// retval = Tuple(false, a0)
	return rv;
	// ^ Return
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::from_bool
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g9from_bool0g(
		RUST_BOOL arg0 // bool
		) // -> u32

{
	uint32_t rv;
	rv = (uint32_t )arg0;	// retval = Cast(a0 as u32)
	return rv;
	// ^ Return
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::from_unsigned
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g13from_unsigned0g(
		uint32_t arg0 // u32
		) // -> u32

{
	uint32_t rv;
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::leading_zeros
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g13leading_zeros0g(
		uint32_t arg0 // u32
		) // -> u32

{
	uint32_t rv;
	rv = (arg0 != 0 ? __builtin_clz(arg0) : sizeof(uint32_t )*8);
	// ^ Call( retval = "ctlz"::<u32,>( a0, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::max_value
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g9max_value0g(void) // -> u32

{
	uint32_t rv;
	rv = 0xffffffff;	// retval = Constant(0xffffffff u32)
	return rv;
	// ^ Return
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::min_value
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g9min_value0g(void) // -> u32

{
	uint32_t rv;
	rv = 0x0;	// retval = Constant(0x0 u32)
	return rv;
	// ^ Return
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::overflowing_add
TUP_2_ZRTCe_ZRTCw  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g15overflowing_add0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> (u32, bool, )

{
	TUP_2_ZRTCe_ZRTCw rv;
	TUP_2_ZRTCe_ZRTCw var0;	// (u32, bool, )
	var0._1 = __builtin_add_overflow(arg0, arg1, &var0._0);
	// ^ Call( _0 = "add_with_overflow"::<u32,>( a0, a1, ), bb1, bb2)
	;
	rv._0 = var0._0;
	rv._1 = var0._1;	// retval = Tuple(_0.0, _0.1)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::unsigned
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g8unsigned0g(
		uint32_t arg0 // u32
		) // -> u32

{
	uint32_t rv;
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_add
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_add0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32

{
	uint32_t rv;
	__builtin_add_overflow(arg0, arg1, &rv);
	// ^ Call( retval = "overflowing_add"::<u32,>( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_mul
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_mul0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32

{
	uint32_t rv;
	__builtin_mul_overflow(arg0, arg1, &rv);
	// ^ Call( retval = "overflowing_mul"::<u32,>( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_shl
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_shl0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32

{
	uint32_t rv;
	uint32_t var0;	// u32
	var0 = arg1 & 0x1f;	// _0 = BinOp(a1 BIT_AND 0x1f u32)
	rv = arg0 << var0;
	// ^ Call( retval = "unchecked_shl"::<u32,>( a0, _0, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_sub
uint32_t  ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_sub0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32

{
	uint32_t rv;
	__builtin_sub_overflow(arg0, arg1, &rv);
	// ^ Call( retval = "overflowing_sub"::<u32,>( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::WideInt>::wide_mul
TUP_2_ZRTCe_ZRTCe  ZRQCe2cR25compiler_builtins0_0_0_Hb3int7WideInt0g8wide_mul0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> (u32, u32, )

{
	TUP_2_ZRTCe_ZRTCe rv;
	uint64_t var0;	// u64
	uint64_t var1;	// u64
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	uint64_t var4;	// u64
	uint64_t var5;	// u64
	var4 = (uint64_t )arg0;	// _4 = Cast(a0 as u64)
	var5 = (uint64_t )arg1;	// _5 = Cast(a1 as u64)
	__builtin_mul_overflow(var4, var5, &var0);
	// ^ Call( _0 = "overflowing_mul"::<u64,>( _4, _5, ), bb1, bb2)
	var1 = var0 >> 0x20;	// _1 = BinOp(_0 BIT_SHR 0x20 u32)
	var2 = (uint32_t )var1;	// _2 = Cast(_1 as u32)
	var3 = (uint32_t )var0;	// _3 = Cast(_0 as u32)
	;
	rv._0 = var2;
	rv._1 = var3;	// retval = Tuple(_2, _3)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::WideInt>::wide_shift_left<'#omitted,'#omitted,>
void  ZRQCe2cR25compiler_builtins0_0_0_Hb3int7WideInt0g15wide_shift_left0g(
		uint32_t *arg0, // &'#omitted mut u32
		uint32_t *arg1, // &'#omitted mut u32
		int32_t arg2 // i32
		) // -> ()

{
	tUNIT rv;
	uint32_t var0;	// u32
	uint32_t var1;	// u32
	int32_t var2;	// i32
	var0 = (*arg0) << arg2;	// _0 = BinOp(a0* BIT_SHL a2)
	var2 = 32 - arg2;	// _2 = BinOp(+32 i32 SUB a2)
	var1 = (*arg1) >> var2;	// _1 = BinOp(a1* BIT_SHR _2)
	(*arg0) = var0 | var1;	// a0* = BinOp(_0 BIT_OR _1)
	(*arg1) = (*arg1) << arg2;	// a1* = BinOp(a1* BIT_SHL a2)
	/* ZST assign */
	// ^ drop(a0)
	// ^ drop(a1)
	return ;
	// ^ Return
}
// <u32 as ::"compiler_builtins-0_0_0_Hb"::int::WideInt>::wide_shift_right_with_sticky<'#omitted,'#omitted,>
void  ZRQCe2cR25compiler_builtins0_0_0_Hb3int7WideInt0g28wide_shift_right_with_sticky0g(
		uint32_t *arg0, // &'#omitted mut u32
		uint32_t *arg1, // &'#omitted mut u32
		int32_t arg2 // i32
		) // -> ()

{
	tUNIT rv;
	uint32_t var0;	// u32
	uint32_t var1;	// u32
	RUST_BOOL var2;	// bool
	int32_t var3;	// i32
	uint32_t var4;	// u32
	uint32_t var5;	// u32
	int32_t var6;	// i32
	uint32_t var7;	// u32
	uint32_t var8;	// u32
	int32_t var9;	// i32
	uint32_t var10;	// u32
	int32_t var11;	// i32
	var2 = arg2 < 32;	// _2 = BinOp(a2 LT +32 i32)
	if(var2) goto bb1; else goto bb2;
	// ^ If( _2 : 1, 2)
bb1:
	var3 = 32 - arg2;	// _3 = BinOp(+32 i32 SUB a2)
	var0 = (*arg1) << var3;	// _0 = BinOp(a1* BIT_SHL _3)
	var6 = 32 - arg2;	// _6 = BinOp(+32 i32 SUB a2)
	var5 = (*arg0) << var6;	// _5 = BinOp(a0* BIT_SHL _6)
	var7 = (*arg1) >> arg2;	// _7 = BinOp(a1* BIT_SHR a2)
	var4 = var5 | var7;	// _4 = BinOp(_5 BIT_OR _7)
	(*arg1) = var4 | var0;	// a1* = BinOp(_4 BIT_OR _0)
	(*arg0) = (*arg0) >> arg2;	// a0* = BinOp(a0* BIT_SHR a2)
	/* ZST assign */
	goto bb5;
	// ^ Goto(5)
bb2:
	var2 = arg2 < 64;	// _2 = BinOp(a2 LT +64 i32)
	if(var2) goto bb3; else goto bb4;
	// ^ If( _2 : 3, 4)
bb3:
	var9 = 64 - arg2;	// _9 = BinOp(+64 i32 SUB a2)
	var8 = (*arg0) << var9;	// _8 = BinOp(a0* BIT_SHL _9)
	var1 = var8 | (*arg1);	// _1 = BinOp(_8 BIT_OR a1*)
	var11 = arg2 - 32;	// _11 = BinOp(a2 SUB +32 i32)
	var10 = (*arg0) >> var11;	// _10 = BinOp(a0* BIT_SHR _11)
	(*arg1) = var10 | var1;	// a1* = BinOp(_10 BIT_OR _1)
	(*arg0) = 0x0;	// a0* = Constant(0x0 u32)
	/* ZST assign */
	goto bb5;
	// ^ Goto(5)
bb4:
	(*arg0) = (*arg0) | (*arg1);	// a0* = BinOp(a0* BIT_OR a1*)
	(*arg0) = 0x0;	// a0* = Constant(0x0 u32)
	/* ZST assign */
	// ^ Goto(5)
bb5:
	// ^ drop(a0)
	// ^ drop(a1)
	return ;
	// ^ Return
}
// <u32 as ::"core-0_0_0"::cmp::PartialEq<u32,>>::eq<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCe2cE9core0_0_03cmp9PartialEq1gCe2eq0g(
		uint32_t *arg0, // &'#omitted u32
		uint32_t *arg1 // &'#omitted u32
		) // -> bool

{
	RUST_BOOL rv;
	rv = (*arg0) == (*arg1);	// retval = BinOp(a0* EQ a1*)
	return rv;
	// ^ Return
}
// <u32 as ::"core-0_0_0"::cmp::PartialEq<u32,>>::ne<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCe2cE9core0_0_03cmp9PartialEq1gCe2ne0g(
		uint32_t *arg0, // &'#omitted u32
		uint32_t *arg1 // &'#omitted u32
		) // -> bool

{
	RUST_BOOL rv;
	rv = (*arg0) != (*arg1);	// retval = BinOp(a0* NE a1*)
	return rv;
	// ^ Return
}
// <u32 as ::"core-0_0_0"::cmp::PartialOrd<u32,>>::ge<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCe2cE9core0_0_03cmp10PartialOrd1gCe2ge0g(
		uint32_t *arg0, // &'#omitted u32
		uint32_t *arg1 // &'#omitted u32
		) // -> bool

{
	RUST_BOOL rv;
	rv = (*arg0) >= (*arg1);	// retval = BinOp(a0* GE a1*)
	return rv;
	// ^ Return
}
// <u32 as ::"core-0_0_0"::cmp::PartialOrd<u32,>>::gt<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCe2cE9core0_0_03cmp10PartialOrd1gCe2gt0g(
		uint32_t *arg0, // &'#omitted u32
		uint32_t *arg1 // &'#omitted u32
		) // -> bool

{
	RUST_BOOL rv;
	rv = (*arg0) > (*arg1);	// retval = BinOp(a0* GT a1*)
	return rv;
	// ^ Return
}
// <u32 as ::"core-0_0_0"::cmp::PartialOrd<u32,>>::lt<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCe2cE9core0_0_03cmp10PartialOrd1gCe2lt0g(
		uint32_t *arg0, // &'#omitted u32
		uint32_t *arg1 // &'#omitted u32
		) // -> bool

{
	RUST_BOOL rv;
	rv = (*arg0) < (*arg1);	// retval = BinOp(a0* LT a1*)
	return rv;
	// ^ Return
}
// <u32 as ::"core-0_0_0"::ops::arith::AddAssign<u32,>>::add_assign<'#omitted,>
static void  ZRQCe3cE9core0_0_03ops5arith9AddAssign1gCe10add_assign0g(
		uint32_t *arg0, // &'#omitted mut u32
		uint32_t arg1 // u32
		) // -> ()

{
	tUNIT rv;
	(*arg0) = (*arg0) + arg1;	// a0* = BinOp(a0* ADD a1)
	/* ZST assign */
	// ^ drop(a0)
	return ;
	// ^ Return
}
// <u32 as ::"core-0_0_0"::ops::arith::Sub<u32,>>::sub
static uint32_t  ZRQCe3cE9core0_0_03ops5arith3Sub1gCe3sub0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32

{
	uint32_t rv;
	rv = arg0 - arg1;	// retval = BinOp(a0 SUB a1)
	return rv;
	// ^ Return
}
// <u32 as ::"core-0_0_0"::ops::bit::BitAnd<u32,>>::bitand
static uint32_t  ZRQCe3cE9core0_0_03ops3bit6BitAnd1gCe6bitand0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32

{
	uint32_t rv;
	rv = arg0 & arg1;	// retval = BinOp(a0 BIT_AND a1)
	return rv;
	// ^ Return
}
// <u32 as ::"core-0_0_0"::ops::bit::BitAndAssign<u32,>>::bitand_assign<'#omitted,>
static void  ZRQCe3cE9core0_0_03ops3bit12BitAndAssign1gCe13bitand_assign0g(
		uint32_t *arg0, // &'#omitted mut u32
		uint32_t arg1 // u32
		) // -> ()

{
	tUNIT rv;
	(*arg0) = (*arg0) & arg1;	// a0* = BinOp(a0* BIT_AND a1)
	/* ZST assign */
	// ^ drop(a0)
	return ;
	// ^ Return
}
// <u32 as ::"core-0_0_0"::ops::bit::BitOr<u32,>>::bitor
static uint32_t  ZRQCe3cE9core0_0_03ops3bit5BitOr1gCe5bitor0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32

{
	uint32_t rv;
	rv = arg0 | arg1;	// retval = BinOp(a0 BIT_OR a1)
	return rv;
	// ^ Return
}
// <u32 as ::"core-0_0_0"::ops::bit::BitOrAssign<u32,>>::bitor_assign<'#omitted,>
static void  ZRQCe3cE9core0_0_03ops3bit11BitOrAssign1gCe12bitor_assign0g(
		uint32_t *arg0, // &'#omitted mut u32
		uint32_t arg1 // u32
		) // -> ()

{
	tUNIT rv;
	(*arg0) = (*arg0) | arg1;	// a0* = BinOp(a0* BIT_OR a1)
	/* ZST assign */
	// ^ drop(a0)
	return ;
	// ^ Return
}
// <u32 as ::"core-0_0_0"::ops::bit::BitXor<u32,>>::bitxor
static uint32_t  ZRQCe3cE9core0_0_03ops3bit6BitXor1gCe6bitxor0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32

{
	uint32_t rv;
	rv = arg0 ^ arg1;	// retval = BinOp(a0 BIT_XOR a1)
	return rv;
	// ^ Return
}
// <u32 as ::"core-0_0_0"::ops::bit::Not>::not
static uint32_t  ZRQCe3cE9core0_0_03ops3bit3Not0g3not0g(
		uint32_t arg0 // u32
		) // -> u32

{
	uint32_t rv;
	rv = ~arg0;	// retval = UniOp(a0 INV)
	return rv;
	// ^ Return
}
// <u32 as ::"core-0_0_0"::ops::bit::Shl<u32,>>::shl
static uint32_t  ZRQCe3cE9core0_0_03ops3bit3Shl1gCe3shl0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32

{
	uint32_t rv;
	rv = arg0 << arg1;	// retval = BinOp(a0 BIT_SHL a1)
	return rv;
	// ^ Return
}
// <u32 as ::"core-0_0_0"::ops::bit::ShlAssign<i32,>>::shl_assign<'#omitted,>
static void  ZRQCe3cE9core0_0_03ops3bit9ShlAssign1gCf10shl_assign0g(
		uint32_t *arg0, // &'#omitted mut u32
		int32_t arg1 // i32
		) // -> ()

{
	tUNIT rv;
	(*arg0) = (*arg0) << arg1;	// a0* = BinOp(a0* BIT_SHL a1)
	/* ZST assign */
	// ^ drop(a0)
	return ;
	// ^ Return
}
// <u32 as ::"core-0_0_0"::ops::bit::Shr<u32,>>::shr
static uint32_t  ZRQCe3cE9core0_0_03ops3bit3Shr1gCe3shr0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u32

{
	uint32_t rv;
	rv = arg0 >> arg1;	// retval = BinOp(a0 BIT_SHR a1)
	return rv;
	// ^ Return
}
// <u32 as ::"core-0_0_0"::ops::bit::ShrAssign<u32,>>::shr_assign<'#omitted,>
static void  ZRQCe3cE9core0_0_03ops3bit9ShrAssign1gCe10shr_assign0g(
		uint32_t *arg0, // &'#omitted mut u32
		uint32_t arg1 // u32
		) // -> ()

{
	tUNIT rv;
	(*arg0) = (*arg0) >> arg1;	// a0* = BinOp(a0* BIT_SHR a1)
	/* ZST assign */
	// ^ drop(a0)
	return ;
	// ^ Return
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<usize,>>::cast
uintptr_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCu4cast0g(
		int32_t arg0 // i32
		) // -> usize

{
	uintptr_t rv;
	rv = (uintptr_t )arg0;	// retval = Cast(a0 as usize)
	return rv;
	// ^ Return
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<isize,>>::cast
intptr_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCv4cast0g(
		int32_t arg0 // i32
		) // -> isize

{
	intptr_t rv;
	rv = (intptr_t )arg0;	// retval = Cast(a0 as isize)
	return rv;
	// ^ Return
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u32,>>::cast
uint32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCe4cast0g(
		int32_t arg0 // i32
		) // -> u32

{
	uint32_t rv;
	rv = (uint32_t )arg0;	// retval = Cast(a0 as u32)
	return rv;
	// ^ Return
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i32,>>::cast
int32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCf4cast0g(
		int32_t arg0 // i32
		) // -> i32

{
	int32_t rv;
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u64,>>::cast
uint64_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCg4cast0g(
		int32_t arg0 // i32
		) // -> u64

{
	uint64_t rv;
	rv = (uint64_t )arg0;	// retval = Cast(a0 as u64)
	return rv;
	// ^ Return
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i64,>>::cast
int64_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCh4cast0g(
		int32_t arg0 // i32
		) // -> i64

{
	int64_t rv;
	rv = (int64_t )arg0;	// retval = Cast(a0 as i64)
	return rv;
	// ^ Return
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u128,>>::cast
uint128_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCi4cast0g(
		int32_t arg0 // i32
		) // -> u128

{
	uint128_t rv;
	rv.lo = arg0; rv.hi = arg0 < 0 ? -1 : 0;	// retval = Cast(a0 as u128)
	return rv;
	// ^ Return
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i128,>>::cast
int128_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCj4cast0g(
		int32_t arg0 // i32
		) // -> i128

{
	int128_t rv;
	rv.lo = arg0; rv.hi = arg0 < 0 ? -1 : 0;	// retval = Cast(a0 as i128)
	return rv;
	// ^ Return
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div
int32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32

{
	int32_t rv;
	struct e_ZRG2cE9core0_0_06option6Option1gCf var0;	// ::"core-0_0_0"::option::Option<i32,>/*E*/
	var0 = ZRICf11checked_div0g( arg0, arg1 );
	// ^ Call( _0 = <i32 /*- */>::checked_div( a0, a1, ), bb1, bb3)
	rv = ZRG2cR25compiler_builtins0_0_0_Hb3int6unwrap1gCf( var0 );
	// ^ Call( retval = ::"compiler_builtins-0_0_0_Hb"::int::unwrap<i32,>( _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_rem
int32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_rem0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32

{
	int32_t rv;
	struct e_ZRG2cE9core0_0_06option6Option1gCf var0;	// ::"core-0_0_0"::option::Option<i32,>/*E*/
	var0 = ZRICf11checked_rem0g( arg0, arg1 );
	// ^ Call( _0 = <i32 /*- */>::checked_rem( a0, a1, ), bb1, bb3)
	rv = ZRG2cR25compiler_builtins0_0_0_Hb3int6unwrap1gCf( var0 );
	// ^ Call( retval = ::"compiler_builtins-0_0_0_Hb"::int::unwrap<i32,>( _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::extract_sign
TUP_2_ZRTCw_ZRTCe  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g12extract_sign0g(
		int32_t arg0 // i32
		) // -> (bool, u32, )

{
	TUP_2_ZRTCw_ZRTCe rv;
	RUST_BOOL var0;	// bool
	uint32_t var1;	// u32
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	uint32_t var4;	// u32
	var0 = arg0 < 0;	// _0 = BinOp(a0 LT +0 i32)
	if(var0) goto bb1; else goto bb3;
	// ^ If( _0 : 1, 3)
bb1:
	var1 = (uint32_t )arg0;	// _1 = Cast(a0 as u32)
	var4 = ~var1;	// _4 = UniOp(_1 INV)
	__builtin_add_overflow(var4, 0x1, &var3);
	// ^ Call( _3 = "overflowing_add"::<u32,>( _4, 0x1 u32, ), bb2, bb4)
	;
	rv._0 = true;
	rv._1 = var3;	// retval = Tuple(true, _3)
	return rv;
	// ^ Return
bb3:
	var2 = (uint32_t )arg0;	// _2 = Cast(a0 as u32)
	;
	rv._0 = false;
	rv._1 = var2;	// retval = Tuple(false, _2)
	return rv;
	// ^ Return
bb4: _Unwind_Resume(); // Diverge
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::from_bool
int32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g9from_bool0g(
		RUST_BOOL arg0 // bool
		) // -> i32

{
	int32_t rv;
	rv = (int32_t )arg0;	// retval = Cast(a0 as i32)
	return rv;
	// ^ Return
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::from_unsigned
int32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g13from_unsigned0g(
		uint32_t arg0 // u32
		) // -> i32

{
	int32_t rv;
	rv = (int32_t )arg0;	// retval = Cast(a0 as i32)
	return rv;
	// ^ Return
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::leading_zeros
uint32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g13leading_zeros0g(
		int32_t arg0 // i32
		) // -> u32

{
	uint32_t rv;
	uint32_t var0;	// u32
	var0 = (uint32_t )arg0;	// _0 = Cast(a0 as u32)
	rv = (var0 != 0 ? __builtin_clz(var0) : sizeof(uint32_t )*8);
	// ^ Call( retval = "ctlz"::<u32,>( _0, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::max_value
int32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g9max_value0g(void) // -> i32

{
	int32_t rv;
	rv = 2147483647;	// retval = Constant(+2147483647 i32)
	return rv;
	// ^ Return
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::min_value
int32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g9min_value0g(void) // -> i32

{
	int32_t rv;
	rv = -2147483648;	// retval = Constant(-2147483648 i32)
	return rv;
	// ^ Return
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::overflowing_add
TUP_2_ZRTCf_ZRTCw  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g15overflowing_add0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> (i32, bool, )

{
	TUP_2_ZRTCf_ZRTCw rv;
	TUP_2_ZRTCf_ZRTCw var0;	// (i32, bool, )
	var0._1 = __builtin_add_overflow(arg0, arg1, &var0._0);
	// ^ Call( _0 = "add_with_overflow"::<i32,>( a0, a1, ), bb1, bb2)
	;
	rv._0 = var0._0;
	rv._1 = var0._1;	// retval = Tuple(_0.0, _0.1)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::unsigned
uint32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g8unsigned0g(
		int32_t arg0 // i32
		) // -> u32

{
	uint32_t rv;
	rv = (uint32_t )arg0;	// retval = Cast(a0 as u32)
	return rv;
	// ^ Return
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_add
int32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_add0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32

{
	int32_t rv;
	__builtin_add_overflow(arg0, arg1, &rv);
	// ^ Call( retval = "overflowing_add"::<i32,>( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_mul
int32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_mul0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32

{
	int32_t rv;
	__builtin_mul_overflow(arg0, arg1, &rv);
	// ^ Call( retval = "overflowing_mul"::<i32,>( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_shl
int32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_shl0g(
		int32_t arg0, // i32
		uint32_t arg1 // u32
		) // -> i32

{
	int32_t rv;
	uint32_t var0;	// u32
	int32_t var1;	// i32
	var0 = arg1 & 0x1f;	// _0 = BinOp(a1 BIT_AND 0x1f u32)
	var1 = (int32_t )var0;	// _1 = Cast(_0 as i32)
	rv = arg0 << var1;
	// ^ Call( retval = "unchecked_shl"::<i32,>( a0, _1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_sub
int32_t  ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_sub0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32

{
	int32_t rv;
	__builtin_sub_overflow(arg0, arg1, &rv);
	// ^ Call( retval = "overflowing_sub"::<i32,>( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::mul::Mulo>::mulo<'#omitted,>
int32_t  ZRQCf3cR25compiler_builtins0_0_0_Hb3int3mul4Mulo0g4mulo0g(
		int32_t arg0, // i32
		int32_t arg1, // i32
		int32_t *arg2 // &'#omitted mut i32
		) // -> i32

{
	int32_t rv;
	int32_t var0;	// i32
	int32_t var1;	// i32
	int32_t var2;	// i32
	int32_t var3;	// i32
	int32_t var4;	// i32
	int32_t var5;	// i32
	RUST_BOOL var6;	// bool
	int32_t var7;	// i32
	int32_t var8;	// i32
	int32_t var9;	// i32
	int32_t var10;	// i32
	int32_t *var11;	// &'#omitted i32
	int32_t var12;	// i32
	int32_t *var13;	// &'#omitted i32
	(*arg2) = 0;	// a2* = Constant(+0 i32)
	__builtin_mul_overflow(arg0, arg1, &var0);
	// ^ Call( _0 = "overflowing_mul"::<i32,>( a0, a1, ), bb1, bb2)
	var6 = arg0 == -2147483648;	// _6 = BinOp(a0 EQ -2147483648 i32)
	if(var6) goto bb3; else goto bb4;
	// ^ If( _6 : 3, 4)
bb2: _Unwind_Resume(); // Diverge
bb3:
	var6 = arg1 != 0;	// _6 = BinOp(a1 NE +0 i32)
	if(var6) goto bb17; else goto bb15;
	// ^ If( _6 : 17, 15)
bb4:
	var6 = arg1 == -2147483648;	// _6 = BinOp(a1 EQ -2147483648 i32)
	if(var6) goto bb5; else goto bb6;
	// ^ If( _6 : 5, 6)
bb5:
	var6 = arg0 != 0;	// _6 = BinOp(a0 NE +0 i32)
	if(var6) goto bb16; else goto bb15;
	// ^ If( _6 : 16, 15)
bb6:
	var1 = arg0 >> 0x1f;	// _1 = BinOp(a0 BIT_SHR 0x1f u32)
	var9 = arg0 ^ var1;	// _9 = BinOp(a0 BIT_XOR _1)
	var2 = var9 - var1;	// _2 = BinOp(_9 SUB _1)
	var3 = arg1 >> 0x1f;	// _3 = BinOp(a1 BIT_SHR 0x1f u32)
	var10 = arg1 ^ var3;	// _10 = BinOp(a1 BIT_XOR _3)
	var4 = var10 - var3;	// _4 = BinOp(_10 SUB _3)
	var5 = 2;	// _5 = Constant(+2 i32)
	var6 = var2 < 2;	// _6 = BinOp(_2 LT +2 i32)
	if(var6) goto bb15; else goto bb7;
	// ^ If( _6 : 15, 7)
bb7:
	var6 = var4 < var5;	// _6 = BinOp(_4 LT _5)
	if(var6) goto bb15; else goto bb8;
	// ^ If( _6 : 15, 8)
bb8:
	var6 = var1 == var3;	// _6 = BinOp(_1 EQ _3)
	if(var6) goto bb9; else goto bb11;
	// ^ If( _6 : 9, 11)
bb9:
	var11 = & var2;	// _11 = Borrow(Shared, _2)
	var7 = ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g( 2147483647, var4 );
	// ^ Call( _7 = <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div( +2147483647 i32, _4, ), bb10, bb2)
	var6 = (*var11) > var7;	// _6 = BinOp(_11* GT _7)
	goto bb13;
	// ^ Goto(13)
bb11:
	var13 = & var2;	// _13 = Borrow(Shared, _2)
	var12 = -var4;	// _12 = UniOp(_4 NEG)
	var8 = ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g( -2147483648, var12 );
	// ^ Call( _8 = <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div( -2147483648 i32, _12, ), bb12, bb2)
	var6 = (*var13) > var8;	// _6 = BinOp(_13* GT _8)
	// ^ Goto(13)
bb13:
	if(var6) goto bb14; else goto bb15;
	// ^ If( _6 : 14, 15)
bb14:
	(*arg2) = 1;	// a2* = Constant(+1 i32)
	// ^ Goto(15)
bb15:
	rv = var0;	// retval = Use(_0)
	// ^ drop(a2)
	return rv;
	// ^ Return
bb16:
	var6 = arg0 != 1;	// _6 = BinOp(a0 NE +1 i32)
	goto bb13;
	// ^ Goto(13)
bb17:
	var6 = arg1 != 1;	// _6 = BinOp(a1 NE +1 i32)
	goto bb13;
	// ^ Goto(13)
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Div>::div
int32_t  ZRQCf3cR25compiler_builtins0_0_0_Hb3int4sdiv3Div0g3div0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32

{
	int32_t rv;
	int32_t var0;	// i32
	int32_t var1;	// i32
	int32_t var2;	// i32
	int32_t var3;	// i32
	int32_t var4;	// i32
	uint32_t var5;	// u32
	int32_t var6;	// i32
	uint32_t var7;	// u32
	int32_t var8;	// i32
	uint32_t var9;	// u32
	int32_t var10;	// i32
	int32_t var11;	// i32
	var0 = arg0 >> 0x1f;	// _0 = BinOp(a0 BIT_SHR 0x1f u32)
	var1 = arg1 >> 0x1f;	// _1 = BinOp(a1 BIT_SHR 0x1f u32)
	var3 = arg0 ^ var0;	// _3 = BinOp(a0 BIT_XOR _0)
	__builtin_sub_overflow(var3, var0, &var6);
	// ^ Call( _6 = "overflowing_sub"::<i32,>( _3, _0, ), bb1, bb4)
	var4 = arg1 ^ var1;	// _4 = BinOp(a1 BIT_XOR _1)
	__builtin_sub_overflow(var4, var1, &var8);
	// ^ Call( _8 = "overflowing_sub"::<i32,>( _4, _1, ), bb2, bb4)
	var2 = var0 ^ var1;	// _2 = BinOp(_0 BIT_XOR _1)
	var5 = (uint32_t )var6;	// _5 = Cast(_6 as u32)
	var7 = (uint32_t )var8;	// _7 = Cast(_8 as u32)
	var9 = ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g( var5, var7 );
	// ^ Call( _9 = <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div( _5, _7, ), bb3, bb4)
	var10 = (int32_t )var9;	// _10 = Cast(_9 as i32)
	var11 = var10 ^ var2;	// _11 = BinOp(_10 BIT_XOR _2)
	rv = var11 - var2;	// retval = BinOp(_11 SUB _2)
	return rv;
	// ^ Return
bb4: _Unwind_Resume(); // Diverge
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Divmod>::divmod<'#omitted,::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmodsi4_0/*S*/,>
int32_t  ZRQCf3cR25compiler_builtins0_0_0_Hb3int4sdiv6Divmod0g6divmod1gG3c_A_B_CH20closure__divmodsi4_00g(
		int32_t arg0, // i32
		int32_t arg1, // i32
		int32_t *arg2, // &'#omitted mut i32
		struct s_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmodsi4_00g arg3 // ::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmodsi4_0/*S*/
		) // -> i32

{
	int32_t rv;
	int32_t var0;	// i32
	int32_t var1;	// i32
	var0 = ZRQCf3cR25compiler_builtins0_0_0_Hb3int4sdiv3Div0g3div0g( arg0, arg1 );
	// ^ Call( _0 = <i32 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Div>::div( a0, a1, ), bb1, bb3)
	__builtin_mul_overflow(var0, arg1, &var1);
	// ^ Call( _1 = "overflowing_mul"::<i32,>( _0, a1, ), bb2, bb3)
	(*arg2) = arg0 - var1;	// a2* = BinOp(a0 SUB _1)
	rv = var0;	// retval = Use(_0)
	// ^ drop(a2)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// <i32 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Mod>::mod_
int32_t  ZRQCf3cR25compiler_builtins0_0_0_Hb3int4sdiv3Mod0g4mod_0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32

{
	int32_t rv;
	int32_t var0;	// i32
	int32_t var1;	// i32
	int32_t var2;	// i32
	int32_t var3;	// i32
	uint32_t var4;	// u32
	int32_t var5;	// i32
	uint32_t var6;	// u32
	int32_t var7;	// i32
	uint32_t var8;	// u32
	int32_t var9;	// i32
	int32_t var10;	// i32
	var0 = arg1 >> 0x1f;	// _0 = BinOp(a1 BIT_SHR 0x1f u32)
	var2 = arg1 ^ var0;	// _2 = BinOp(a1 BIT_XOR _0)
	__builtin_sub_overflow(var2, var0, &var7);
	// ^ Call( _7 = "overflowing_sub"::<i32,>( _2, _0, ), bb1, bb4)
	var1 = arg0 >> 0x1f;	// _1 = BinOp(a0 BIT_SHR 0x1f u32)
	var3 = arg0 ^ var1;	// _3 = BinOp(a0 BIT_XOR _1)
	__builtin_sub_overflow(var3, var1, &var5);
	// ^ Call( _5 = "overflowing_sub"::<i32,>( _3, _1, ), bb2, bb4)
	var4 = (uint32_t )var5;	// _4 = Cast(_5 as u32)
	var6 = (uint32_t )var7;	// _6 = Cast(_7 as u32)
	var8 = ZRQCe2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_rem0g( var4, var6 );
	// ^ Call( _8 = <u32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_rem( _4, _6, ), bb3, bb4)
	var9 = (int32_t )var8;	// _9 = Cast(_8 as i32)
	var10 = var9 ^ var1;	// _10 = BinOp(_9 BIT_XOR _1)
	rv = var10 - var1;	// retval = BinOp(_10 SUB _1)
	return rv;
	// ^ Return
bb4: _Unwind_Resume(); // Diverge
}
// <i32 as ::"core-0_0_0"::cmp::PartialEq<i32,>>::eq<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCf2cE9core0_0_03cmp9PartialEq1gCf2eq0g(
		int32_t *arg0, // &'#omitted i32
		int32_t *arg1 // &'#omitted i32
		) // -> bool

{
	RUST_BOOL rv;
	rv = (*arg0) == (*arg1);	// retval = BinOp(a0* EQ a1*)
	return rv;
	// ^ Return
}
// <i32 as ::"core-0_0_0"::cmp::PartialEq<i32,>>::ne<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCf2cE9core0_0_03cmp9PartialEq1gCf2ne0g(
		int32_t *arg0, // &'#omitted i32
		int32_t *arg1 // &'#omitted i32
		) // -> bool

{
	RUST_BOOL rv;
	rv = (*arg0) != (*arg1);	// retval = BinOp(a0* NE a1*)
	return rv;
	// ^ Return
}
// <i32 as ::"core-0_0_0"::cmp::PartialOrd<i32,>>::ge<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCf2cE9core0_0_03cmp10PartialOrd1gCf2ge0g(
		int32_t *arg0, // &'#omitted i32
		int32_t *arg1 // &'#omitted i32
		) // -> bool

{
	RUST_BOOL rv;
	rv = (*arg0) >= (*arg1);	// retval = BinOp(a0* GE a1*)
	return rv;
	// ^ Return
}
// <i32 as ::"core-0_0_0"::cmp::PartialOrd<i32,>>::gt<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCf2cE9core0_0_03cmp10PartialOrd1gCf2gt0g(
		int32_t *arg0, // &'#omitted i32
		int32_t *arg1 // &'#omitted i32
		) // -> bool

{
	RUST_BOOL rv;
	rv = (*arg0) > (*arg1);	// retval = BinOp(a0* GT a1*)
	return rv;
	// ^ Return
}
// <i32 as ::"core-0_0_0"::cmp::PartialOrd<i32,>>::lt<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCf2cE9core0_0_03cmp10PartialOrd1gCf2lt0g(
		int32_t *arg0, // &'#omitted i32
		int32_t *arg1 // &'#omitted i32
		) // -> bool

{
	RUST_BOOL rv;
	rv = (*arg0) < (*arg1);	// retval = BinOp(a0* LT a1*)
	return rv;
	// ^ Return
}
// <i32 as ::"core-0_0_0"::ops::arith::Add<i32,>>::add
static int32_t  ZRQCf3cE9core0_0_03ops5arith3Add1gCf3add0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32

{
	int32_t rv;
	rv = arg0 + arg1;	// retval = BinOp(a0 ADD a1)
	return rv;
	// ^ Return
}
// <i32 as ::"core-0_0_0"::ops::arith::Neg>::neg
static int32_t  ZRQCf3cE9core0_0_03ops5arith3Neg0g3neg0g(
		int32_t arg0 // i32
		) // -> i32

{
	int32_t rv;
	rv = -arg0;	// retval = UniOp(a0 NEG)
	return rv;
	// ^ Return
}
// <i32 as ::"core-0_0_0"::ops::arith::Sub<i32,>>::sub
static int32_t  ZRQCf3cE9core0_0_03ops5arith3Sub1gCf3sub0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32

{
	int32_t rv;
	rv = arg0 - arg1;	// retval = BinOp(a0 SUB a1)
	return rv;
	// ^ Return
}
// <i32 as ::"core-0_0_0"::ops::bit::BitAnd<i32,>>::bitand
static int32_t  ZRQCf3cE9core0_0_03ops3bit6BitAnd1gCf6bitand0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32

{
	int32_t rv;
	rv = arg0 & arg1;	// retval = BinOp(a0 BIT_AND a1)
	return rv;
	// ^ Return
}
// <i32 as ::"core-0_0_0"::ops::bit::BitXor<i32,>>::bitxor
static int32_t  ZRQCf3cE9core0_0_03ops3bit6BitXor1gCf6bitxor0g(
		int32_t arg0, // i32
		int32_t arg1 // i32
		) // -> i32

{
	int32_t rv;
	rv = arg0 ^ arg1;	// retval = BinOp(a0 BIT_XOR a1)
	return rv;
	// ^ Return
}
// <i32 as ::"core-0_0_0"::ops::bit::Shr<u32,>>::shr
static int32_t  ZRQCf3cE9core0_0_03ops3bit3Shr1gCe3shr0g(
		int32_t arg0, // i32
		uint32_t arg1 // u32
		) // -> i32

{
	int32_t rv;
	rv = arg0 >> arg1;	// retval = BinOp(a0 BIT_SHR a1)
	return rv;
	// ^ Return
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<usize,>>::cast
uintptr_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCu4cast0g(
		uint64_t arg0 // u64
		) // -> usize

{
	uintptr_t rv;
	rv = (uintptr_t )arg0;	// retval = Cast(a0 as usize)
	return rv;
	// ^ Return
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<isize,>>::cast
intptr_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCv4cast0g(
		uint64_t arg0 // u64
		) // -> isize

{
	intptr_t rv;
	rv = (intptr_t )arg0;	// retval = Cast(a0 as isize)
	return rv;
	// ^ Return
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u32,>>::cast
uint32_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCe4cast0g(
		uint64_t arg0 // u64
		) // -> u32

{
	uint32_t rv;
	rv = (uint32_t )arg0;	// retval = Cast(a0 as u32)
	return rv;
	// ^ Return
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i32,>>::cast
int32_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCf4cast0g(
		uint64_t arg0 // u64
		) // -> i32

{
	int32_t rv;
	rv = (int32_t )arg0;	// retval = Cast(a0 as i32)
	return rv;
	// ^ Return
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u64,>>::cast
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCg4cast0g(
		uint64_t arg0 // u64
		) // -> u64

{
	uint64_t rv;
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i64,>>::cast
int64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCh4cast0g(
		uint64_t arg0 // u64
		) // -> i64

{
	int64_t rv;
	rv = (int64_t )arg0;	// retval = Cast(a0 as i64)
	return rv;
	// ^ Return
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u128,>>::cast
uint128_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCi4cast0g(
		uint64_t arg0 // u64
		) // -> u128

{
	uint128_t rv;
	rv.lo = arg0; rv.hi = arg0 < 0 ? -1 : 0;	// retval = Cast(a0 as u128)
	return rv;
	// ^ Return
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i128,>>::cast
int128_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCj4cast0g(
		uint64_t arg0 // u64
		) // -> i128

{
	int128_t rv;
	rv.lo = arg0; rv.hi = arg0 < 0 ? -1 : 0;	// retval = Cast(a0 as i128)
	return rv;
	// ^ Return
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64

{
	uint64_t rv;
	struct e_ZRG2cE9core0_0_06option6Option1gCg var0;	// ::"core-0_0_0"::option::Option<u64,>/*E*/
	var0 = ZRICg11checked_div0g( arg0, arg1 );
	// ^ Call( _0 = <u64 /*- */>::checked_div( a0, a1, ), bb1, bb3)
	rv = ZRG2cR25compiler_builtins0_0_0_Hb3int6unwrap1gCg( var0 );
	// ^ Call( retval = ::"compiler_builtins-0_0_0_Hb"::int::unwrap<u64,>( _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_rem
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_rem0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64

{
	uint64_t rv;
	struct e_ZRG2cE9core0_0_06option6Option1gCg var0;	// ::"core-0_0_0"::option::Option<u64,>/*E*/
	var0 = ZRICg11checked_rem0g( arg0, arg1 );
	// ^ Call( _0 = <u64 /*- */>::checked_rem( a0, a1, ), bb1, bb3)
	rv = ZRG2cR25compiler_builtins0_0_0_Hb3int6unwrap1gCg( var0 );
	// ^ Call( retval = ::"compiler_builtins-0_0_0_Hb"::int::unwrap<u64,>( _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::extract_sign
TUP_2_ZRTCw_ZRTCg  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g12extract_sign0g(
		uint64_t arg0 // u64
		) // -> (bool, u64, )

{
	TUP_2_ZRTCw_ZRTCg rv;
	;
	rv._0 = false;
	rv._1 = arg0;	// retval = Tuple(false, a0)
	return rv;
	// ^ Return
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::from_bool
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g9from_bool0g(
		RUST_BOOL arg0 // bool
		) // -> u64

{
	uint64_t rv;
	rv = (uint64_t )arg0;	// retval = Cast(a0 as u64)
	return rv;
	// ^ Return
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::from_unsigned
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g13from_unsigned0g(
		uint64_t arg0 // u64
		) // -> u64

{
	uint64_t rv;
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::leading_zeros
uint32_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g13leading_zeros0g(
		uint64_t arg0 // u64
		) // -> u32

{
	uint32_t rv;
	uint64_t var0;	// u64
	var0 = (arg0 != 0 ? __builtin_clz64(arg0) : sizeof(uint64_t )*8);
	// ^ Call( _0 = "ctlz"::<u64,>( a0, ), bb1, bb2)
	rv = (uint32_t )var0;	// retval = Cast(_0 as u32)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::max_value
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g9max_value0g(void) // -> u64

{
	uint64_t rv;
	rv = 0xffffffffffffffffull;	// retval = Constant(0xffffffffffffffff u64)
	return rv;
	// ^ Return
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::min_value
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g9min_value0g(void) // -> u64

{
	uint64_t rv;
	rv = 0x0ull;	// retval = Constant(0x0 u64)
	return rv;
	// ^ Return
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::overflowing_add
TUP_2_ZRTCg_ZRTCw  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g15overflowing_add0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> (u64, bool, )

{
	TUP_2_ZRTCg_ZRTCw rv;
	TUP_2_ZRTCg_ZRTCw var0;	// (u64, bool, )
	var0._1 = __builtin_add_overflow(arg0, arg1, &var0._0);
	// ^ Call( _0 = "add_with_overflow"::<u64,>( a0, a1, ), bb1, bb2)
	;
	rv._0 = var0._0;
	rv._1 = var0._1;	// retval = Tuple(_0.0, _0.1)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::unsigned
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g8unsigned0g(
		uint64_t arg0 // u64
		) // -> u64

{
	uint64_t rv;
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_add
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_add0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64

{
	uint64_t rv;
	__builtin_add_overflow(arg0, arg1, &rv);
	// ^ Call( retval = "overflowing_add"::<u64,>( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_mul
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_mul0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64

{
	uint64_t rv;
	__builtin_mul_overflow(arg0, arg1, &rv);
	// ^ Call( retval = "overflowing_mul"::<u64,>( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_shl
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_shl0g(
		uint64_t arg0, // u64
		uint32_t arg1 // u32
		) // -> u64

{
	uint64_t rv;
	uint32_t var0;	// u32
	uint64_t var1;	// u64
	var0 = arg1 & 0x3f;	// _0 = BinOp(a1 BIT_AND 0x3f u32)
	var1 = (uint64_t )var0;	// _1 = Cast(_0 as u64)
	rv = arg0 << var1;
	// ^ Call( retval = "unchecked_shl"::<u64,>( a0, _1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_sub
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_sub0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64

{
	uint64_t rv;
	__builtin_sub_overflow(arg0, arg1, &rv);
	// ^ Call( retval = "overflowing_sub"::<u64,>( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::from_parts
uint64_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g10from_parts0g(
		uint32_t arg0, // u32
		uint32_t arg1 // u32
		) // -> u64

{
	uint64_t rv;
	uint64_t var0;	// u64
	uint64_t var1;	// u64
	uint64_t var2;	// u64
	var0 = (uint64_t )arg0;	// _0 = Cast(a0 as u64)
	var2 = (uint64_t )arg1;	// _2 = Cast(a1 as u64)
	var1 = var2 << 32;	// _1 = BinOp(_2 BIT_SHL +32 i32)
	rv = var0 | var1;	// retval = BinOp(_0 BIT_OR _1)
	return rv;
	// ^ Return
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::high
uint32_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g4high0g(
		uint64_t arg0 // u64
		) // -> u32

{
	uint32_t rv;
	uint64_t var0;	// u64
	var0 = arg0 >> 32;	// _0 = BinOp(a0 BIT_SHR +32 i32)
	rv = (uint32_t )var0;	// retval = Cast(_0 as u32)
	return rv;
	// ^ Return
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::high_as_low
uint32_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g11high_as_low0g(
		uint32_t arg0 // u32
		) // -> u32

{
	uint32_t rv;
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::low
uint32_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g3low0g(
		uint64_t arg0 // u64
		) // -> u32

{
	uint32_t rv;
	rv = (uint32_t )arg0;	// retval = Cast(a0 as u32)
	return rv;
	// ^ Return
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::low_as_high
uint32_t  ZRQCg2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g11low_as_high0g(
		uint32_t arg0 // u32
		) // -> u32

{
	uint32_t rv;
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::WideInt>::wide_mul
TUP_2_ZRTCg_ZRTCg  ZRQCg2cR25compiler_builtins0_0_0_Hb3int7WideInt0g8wide_mul0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> (u64, u64, )

{
	TUP_2_ZRTCg_ZRTCg rv;
	uint128_t var0;	// u128
	uint128_t var1;	// u128
	uint64_t var2;	// u64
	uint64_t var3;	// u64
	uint128_t var4;	// u128
	uint128_t var5;	// u128
	var4.lo = arg0; var4.hi = arg0 < 0 ? -1 : 0;	// _4 = Cast(a0 as u128)
	var5.lo = arg1; var5.hi = arg1 < 0 ? -1 : 0;	// _5 = Cast(a1 as u128)
	mul128_o(var4, var5, &var0);
	// ^ Call( _0 = "overflowing_mul"::<u128,>( _4, _5, ), bb1, bb2)
	var1 = shr128(var0, 0x40ull);	// _1 = BinOp(_0 BIT_SHR 0x40 u64)
	var2 = var1.lo;	// _2 = Cast(_1 as u64)
	var3 = var0.lo;	// _3 = Cast(_0 as u64)
	;
	rv._0 = var2;
	rv._1 = var3;	// retval = Tuple(_2, _3)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::WideInt>::wide_shift_left<'#omitted,'#omitted,>
void  ZRQCg2cR25compiler_builtins0_0_0_Hb3int7WideInt0g15wide_shift_left0g(
		uint64_t *arg0, // &'#omitted mut u64
		uint64_t *arg1, // &'#omitted mut u64
		int32_t arg2 // i32
		) // -> ()

{
	tUNIT rv;
	uint64_t var0;	// u64
	uint64_t var1;	// u64
	int32_t var2;	// i32
	var0 = (*arg0) << arg2;	// _0 = BinOp(a0* BIT_SHL a2)
	var2 = 64 - arg2;	// _2 = BinOp(+64 i32 SUB a2)
	var1 = (*arg1) >> var2;	// _1 = BinOp(a1* BIT_SHR _2)
	(*arg0) = var0 | var1;	// a0* = BinOp(_0 BIT_OR _1)
	(*arg1) = (*arg1) << arg2;	// a1* = BinOp(a1* BIT_SHL a2)
	/* ZST assign */
	// ^ drop(a0)
	// ^ drop(a1)
	return ;
	// ^ Return
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::WideInt>::wide_shift_right_with_sticky<'#omitted,'#omitted,>
void  ZRQCg2cR25compiler_builtins0_0_0_Hb3int7WideInt0g28wide_shift_right_with_sticky0g(
		uint64_t *arg0, // &'#omitted mut u64
		uint64_t *arg1, // &'#omitted mut u64
		int32_t arg2 // i32
		) // -> ()

{
	tUNIT rv;
	uint64_t var0;	// u64
	uint64_t var1;	// u64
	RUST_BOOL var2;	// bool
	int32_t var3;	// i32
	uint64_t var4;	// u64
	uint64_t var5;	// u64
	int32_t var6;	// i32
	uint64_t var7;	// u64
	uint64_t var8;	// u64
	int32_t var9;	// i32
	uint64_t var10;	// u64
	int32_t var11;	// i32
	var2 = arg2 < 64;	// _2 = BinOp(a2 LT +64 i32)
	if(var2) goto bb1; else goto bb2;
	// ^ If( _2 : 1, 2)
bb1:
	var3 = 64 - arg2;	// _3 = BinOp(+64 i32 SUB a2)
	var0 = (*arg1) << var3;	// _0 = BinOp(a1* BIT_SHL _3)
	var6 = 64 - arg2;	// _6 = BinOp(+64 i32 SUB a2)
	var5 = (*arg0) << var6;	// _5 = BinOp(a0* BIT_SHL _6)
	var7 = (*arg1) >> arg2;	// _7 = BinOp(a1* BIT_SHR a2)
	var4 = var5 | var7;	// _4 = BinOp(_5 BIT_OR _7)
	(*arg1) = var4 | var0;	// a1* = BinOp(_4 BIT_OR _0)
	(*arg0) = (*arg0) >> arg2;	// a0* = BinOp(a0* BIT_SHR a2)
	/* ZST assign */
	goto bb5;
	// ^ Goto(5)
bb2:
	var2 = arg2 < 128;	// _2 = BinOp(a2 LT +128 i32)
	if(var2) goto bb3; else goto bb4;
	// ^ If( _2 : 3, 4)
bb3:
	var9 = 128 - arg2;	// _9 = BinOp(+128 i32 SUB a2)
	var8 = (*arg0) << var9;	// _8 = BinOp(a0* BIT_SHL _9)
	var1 = var8 | (*arg1);	// _1 = BinOp(_8 BIT_OR a1*)
	var11 = arg2 - 64;	// _11 = BinOp(a2 SUB +64 i32)
	var10 = (*arg0) >> var11;	// _10 = BinOp(a0* BIT_SHR _11)
	(*arg1) = var10 | var1;	// a1* = BinOp(_10 BIT_OR _1)
	(*arg0) = 0x0ull;	// a0* = Constant(0x0 u64)
	/* ZST assign */
	goto bb5;
	// ^ Goto(5)
bb4:
	(*arg0) = (*arg0) | (*arg1);	// a0* = BinOp(a0* BIT_OR a1*)
	(*arg0) = 0x0ull;	// a0* = Constant(0x0 u64)
	/* ZST assign */
	// ^ Goto(5)
bb5:
	// ^ drop(a0)
	// ^ drop(a1)
	return ;
	// ^ Return
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::mul::Mul>::mul
uint64_t  ZRQCg3cR25compiler_builtins0_0_0_Hb3int3mul3Mul0g_C0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64

{
	uint64_t rv;
	uint32_t var0;	// u32
	uint32_t var1;	// u32
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	uint32_t var4;	// u32
	uint32_t *var5;	// &'#omitted mut u32
	uint32_t *var6;	// &'#omitted mut u32
	uint32_t *var7;	// &'#omitted mut u32
	uint32_t *var8;	// &'#omitted mut u32
	uint32_t *var9;	// &'#omitted mut u32
	uint32_t *var10;	// &'#omitted mut u32
	uint32_t *var11;	// &'#omitted mut u32
	uint32_t *var12;	// &'#omitted mut u32
	uint32_t var13;	// u32
	uint32_t var14;	// u32
	uint32_t var15;	// u32
	uint32_t var16;	// u32
	uint32_t var17;	// u32
	uint32_t var18;	// u32
	uint32_t var19;	// u32
	uint32_t var20;	// u32
	uint32_t var21;	// u32
	uint32_t var22;	// u32
	uint32_t var23;	// u32
	uint32_t var24;	// u32
	uint32_t var25;	// u32
	uint32_t var26;	// u32
	uint32_t var27;	// u32
	uint32_t var28;	// u32
	uint32_t var29;	// u32
	uint32_t var30;	// u32
	uint32_t var31;	// u32
	uint32_t var32;	// u32
	uint32_t var33;	// u32
	uint32_t var34;	// u32
	uint32_t var35;	// u32
	uint32_t var36;	// u32
	uint64_t var37;	// u64
	uint32_t var38;	// u32
	uint32_t var39;	// u32
	uint32_t var40;	// u32
	uint64_t var41;	// u64
	uint32_t var42;	// u32
	uint32_t var43;	// u32
	uint32_t var44;	// u32
	uint32_t var45;	// u32
	uint64_t var46;	// u64
	uint64_t var47;	// u64
	uint64_t var48;	// u64
	var0 = 0x10;	// _0 = Constant(0x10 u32)
	var1 = 0xffff;	// _1 = Constant(0xffff u32)
	var13 = (uint32_t )arg0;	// _13 = Cast(a0 as u32)
	var15 = var13 & 0xffff;	// _15 = BinOp(_13 BIT_AND 0xffff u32)
	var14 = (uint32_t )arg1;	// _14 = Cast(a1 as u32)
	var16 = var14 & 0xffff;	// _16 = BinOp(_14 BIT_AND 0xffff u32)
	__builtin_mul_overflow(var15, var16, &var2);
	// ^ Call( _2 = "overflowing_mul"::<u32,>( _15, _16, ), bb1, bb9)
	var3 = var2 >> var0;	// _3 = BinOp(_2 BIT_SHR _0)
	var5 = & var2;	// _5 = Borrow(Unique, _2)
	(*var5) = (*var5) & var1;	// _5* = BinOp(_5* BIT_AND _1)
	// ^ drop(_5)
	var6 = & var3;	// _6 = Borrow(Unique, _3)
	var17 = (uint32_t )arg0;	// _17 = Cast(a0 as u32)
	var19 = var17 >> var0;	// _19 = BinOp(_17 BIT_SHR _0)
	var18 = (uint32_t )arg1;	// _18 = Cast(a1 as u32)
	var20 = var18 & var1;	// _20 = BinOp(_18 BIT_AND _1)
	__builtin_mul_overflow(var19, var20, &var21);
	// ^ Call( _21 = "overflowing_mul"::<u32,>( _19, _20, ), bb2, bb9)
	(*var6) = (*var6) + var21;	// _6* = BinOp(_6* ADD _21)
	// ^ drop(_6)
	var7 = & var2;	// _7 = Borrow(Unique, _2)
	var22 = var3 & var1;	// _22 = BinOp(_3 BIT_AND _1)
	var23 = var22 << var0;	// _23 = BinOp(_22 BIT_SHL _0)
	(*var7) = (*var7) + var23;	// _7* = BinOp(_7* ADD _23)
	// ^ drop(_7)
	var4 = var3 >> var0;	// _4 = BinOp(_3 BIT_SHR _0)
	var3 = var2 >> var0;	// _3 = BinOp(_2 BIT_SHR _0)
	var8 = & var2;	// _8 = Borrow(Unique, _2)
	(*var8) = (*var8) & var1;	// _8* = BinOp(_8* BIT_AND _1)
	// ^ drop(_8)
	var9 = & var3;	// _9 = Borrow(Unique, _3)
	var24 = (uint32_t )arg1;	// _24 = Cast(a1 as u32)
	var26 = var24 >> var0;	// _26 = BinOp(_24 BIT_SHR _0)
	var25 = (uint32_t )arg0;	// _25 = Cast(a0 as u32)
	var27 = var25 & var1;	// _27 = BinOp(_25 BIT_AND _1)
	__builtin_mul_overflow(var26, var27, &var28);
	// ^ Call( _28 = "overflowing_mul"::<u32,>( _26, _27, ), bb3, bb9)
	(*var9) = (*var9) + var28;	// _9* = BinOp(_9* ADD _28)
	// ^ drop(_9)
	var10 = & var2;	// _10 = Borrow(Unique, _2)
	var29 = var3 & var1;	// _29 = BinOp(_3 BIT_AND _1)
	var30 = var29 << var0;	// _30 = BinOp(_29 BIT_SHL _0)
	(*var10) = (*var10) + var30;	// _10* = BinOp(_10* ADD _30)
	// ^ drop(_10)
	var11 = & var4;	// _11 = Borrow(Unique, _4)
	var31 = var3 >> var0;	// _31 = BinOp(_3 BIT_SHR _0)
	(*var11) = (*var11) + var31;	// _11* = BinOp(_11* ADD _31)
	// ^ drop(_11)
	var12 = & var4;	// _12 = Borrow(Unique, _4)
	var32 = (uint32_t )arg0;	// _32 = Cast(a0 as u32)
	var34 = var32 >> var0;	// _34 = BinOp(_32 BIT_SHR _0)
	var33 = (uint32_t )arg1;	// _33 = Cast(a1 as u32)
	var35 = var33 >> var0;	// _35 = BinOp(_33 BIT_SHR _0)
	__builtin_mul_overflow(var34, var35, &var36);
	// ^ Call( _36 = "overflowing_mul"::<u32,>( _34, _35, ), bb4, bb9)
	(*var12) = (*var12) + var36;	// _12* = BinOp(_12* ADD _36)
	// ^ drop(_12)
	var37 = arg0 >> 32;	// _37 = BinOp(a0 BIT_SHR +32 i32)
	var38 = (uint32_t )var37;	// _38 = Cast(_37 as u32)
	var39 = (uint32_t )arg1;	// _39 = Cast(a1 as u32)
	__builtin_mul_overflow(var38, var39, &var40);
	// ^ Call( _40 = "overflowing_mul"::<u32,>( _38, _39, ), bb5, bb9)
	__builtin_add_overflow(var4, var40, &var44);
	// ^ Call( _44 = "overflowing_add"::<u32,>( _4, _40, ), bb6, bb9)
	var42 = (uint32_t )arg0;	// _42 = Cast(a0 as u32)
	var41 = arg1 >> 32;	// _41 = BinOp(a1 BIT_SHR +32 i32)
	var43 = (uint32_t )var41;	// _43 = Cast(_41 as u32)
	__builtin_mul_overflow(var42, var43, &var45);
	// ^ Call( _45 = "overflowing_mul"::<u32,>( _42, _43, ), bb7, bb9)
	__builtin_add_overflow(var44, var45, &var4);
	// ^ Call( _4 = "overflowing_add"::<u32,>( _44, _45, ), bb8, bb9)
	var46 = (uint64_t )var2;	// _46 = Cast(_2 as u64)
	var48 = (uint64_t )var4;	// _48 = Cast(_4 as u64)
	var47 = var48 << 32;	// _47 = BinOp(_48 BIT_SHL +32 i32)
	rv = var46 | var47;	// retval = BinOp(_46 BIT_OR _47)
	return rv;
	// ^ Return
bb9: _Unwind_Resume(); // Diverge
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Ashl>::ashl
uint64_t  ZRQCg3cR25compiler_builtins0_0_0_Hb3int5shift4Ashl0g4ashl0g(
		uint64_t arg0, // u64
		uint32_t arg1 // u32
		) // -> u64

{
	uint64_t rv;
	uint32_t var0;	// u32
	RUST_BOOL var1;	// bool
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	uint32_t var4;	// u32
	uint64_t var5;	// u64
	uint64_t var6;	// u64
	uint32_t var7;	// u32
	uint32_t var8;	// u32
	uint64_t var9;	// u64
	uint32_t var10;	// u32
	uint32_t var11;	// u32
	uint32_t var12;	// u32
	uint32_t var13;	// u32
	uint32_t var14;	// u32
	uint64_t var15;	// u64
	uint64_t var16;	// u64
	uint64_t var17;	// u64
	uint32_t var18;	// u32
	uint32_t var19;	// u32
	var0 = 0x20;	// _0 = Constant(0x20 u32)
	var2 = arg1 & 0x20;	// _2 = BinOp(a1 BIT_AND 0x20 u32)
	var1 = var2 != 0x0;	// _1 = BinOp(_2 NE 0x0 u32)
	if(var1) goto bb1; else goto bb2;
	// ^ If( _1 : 1, 2)
bb1:
	var3 = (uint32_t )arg0;	// _3 = Cast(a0 as u32)
	var4 = arg1 - var0;	// _4 = BinOp(a1 SUB _0)
	var7 = var3 << var4;	// _7 = BinOp(_3 BIT_SHL _4)
	var6 = (uint64_t )var7;	// _6 = Cast(_7 as u64)
	var5 = var6 << 32;	// _5 = BinOp(_6 BIT_SHL +32 i32)
	rv = 0x0ull | var5;	// retval = BinOp(0x0 u64 BIT_OR _5)
	return rv;
	// ^ Return
bb2:
	var1 = arg1 == 0x0;	// _1 = BinOp(a1 EQ 0x0 u32)
	if(var1) goto bb3; else goto bb4;
	// ^ If( _1 : 3, 4)
bb3:
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
bb4:
	var8 = (uint32_t )arg0;	// _8 = Cast(a0 as u32)
	var18 = var8 << arg1;	// _18 = BinOp(_8 BIT_SHL a1)
	var9 = arg0 >> 32;	// _9 = BinOp(a0 BIT_SHR +32 i32)
	var10 = (uint32_t )var9;	// _10 = Cast(_9 as u32)
	var13 = var10 << arg1;	// _13 = BinOp(_10 BIT_SHL a1)
	var11 = (uint32_t )arg0;	// _11 = Cast(a0 as u32)
	var12 = var0 - arg1;	// _12 = BinOp(_0 SUB a1)
	var14 = var11 >> var12;	// _14 = BinOp(_11 BIT_SHR _12)
	var19 = var13 | var14;	// _19 = BinOp(_13 BIT_OR _14)
	var15 = (uint64_t )var18;	// _15 = Cast(_18 as u64)
	var17 = (uint64_t )var19;	// _17 = Cast(_19 as u64)
	var16 = var17 << 32;	// _16 = BinOp(_17 BIT_SHL +32 i32)
	rv = var15 | var16;	// retval = BinOp(_15 BIT_OR _16)
	return rv;
	// ^ Return
}
// <u64 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Lshr>::lshr
uint64_t  ZRQCg3cR25compiler_builtins0_0_0_Hb3int5shift4Lshr0g4lshr0g(
		uint64_t arg0, // u64
		uint32_t arg1 // u32
		) // -> u64

{
	uint64_t rv;
	uint32_t var0;	// u32
	RUST_BOOL var1;	// bool
	uint32_t var2;	// u32
	uint64_t var3;	// u64
	uint32_t var4;	// u32
	uint32_t var5;	// u32
	uint64_t var6;	// u64
	uint32_t var7;	// u32
	uint64_t var8;	// u64
	uint32_t var9;	// u32
	uint32_t var10;	// u32
	uint32_t var11;	// u32
	uint32_t var12;	// u32
	uint32_t var13;	// u32
	uint64_t var14;	// u64
	uint32_t var15;	// u32
	uint64_t var16;	// u64
	uint64_t var17;	// u64
	uint64_t var18;	// u64
	uint32_t var19;	// u32
	uint32_t var20;	// u32
	var0 = 0x20;	// _0 = Constant(0x20 u32)
	var2 = arg1 & 0x20;	// _2 = BinOp(a1 BIT_AND 0x20 u32)
	var1 = var2 != 0x0;	// _1 = BinOp(_2 NE 0x0 u32)
	if(var1) goto bb1; else goto bb2;
	// ^ If( _1 : 1, 2)
bb1:
	var3 = arg0 >> 32;	// _3 = BinOp(a0 BIT_SHR +32 i32)
	var4 = (uint32_t )var3;	// _4 = Cast(_3 as u32)
	var5 = arg1 - var0;	// _5 = BinOp(a1 SUB _0)
	var7 = var4 >> var5;	// _7 = BinOp(_4 BIT_SHR _5)
	var6 = (uint64_t )var7;	// _6 = Cast(_7 as u64)
	rv = var6 | 0x0ull;	// retval = BinOp(_6 BIT_OR 0x0 u64)
	return rv;
	// ^ Return
bb2:
	var1 = arg1 == 0x0;	// _1 = BinOp(a1 EQ 0x0 u32)
	if(var1) goto bb3; else goto bb4;
	// ^ If( _1 : 3, 4)
bb3:
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
bb4:
	var8 = arg0 >> 32;	// _8 = BinOp(a0 BIT_SHR +32 i32)
	var9 = (uint32_t )var8;	// _9 = Cast(_8 as u32)
	var10 = var0 - arg1;	// _10 = BinOp(_0 SUB a1)
	var12 = var9 << var10;	// _12 = BinOp(_9 BIT_SHL _10)
	var11 = (uint32_t )arg0;	// _11 = Cast(a0 as u32)
	var13 = var11 >> arg1;	// _13 = BinOp(_11 BIT_SHR a1)
	var19 = var12 | var13;	// _19 = BinOp(_12 BIT_OR _13)
	var14 = arg0 >> 32;	// _14 = BinOp(a0 BIT_SHR +32 i32)
	var15 = (uint32_t )var14;	// _15 = Cast(_14 as u32)
	var20 = var15 >> arg1;	// _20 = BinOp(_15 BIT_SHR a1)
	var16 = (uint64_t )var19;	// _16 = Cast(_19 as u64)
	var18 = (uint64_t )var20;	// _18 = Cast(_20 as u64)
	var17 = var18 << 32;	// _17 = BinOp(_18 BIT_SHL +32 i32)
	rv = var16 | var17;	// retval = BinOp(_16 BIT_OR _17)
	return rv;
	// ^ Return
}
// <u64 as ::"core-0_0_0"::cmp::PartialEq<u64,>>::eq<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCg2cE9core0_0_03cmp9PartialEq1gCg2eq0g(
		uint64_t *arg0, // &'#omitted u64
		uint64_t *arg1 // &'#omitted u64
		) // -> bool

{
	RUST_BOOL rv;
	rv = (*arg0) == (*arg1);	// retval = BinOp(a0* EQ a1*)
	return rv;
	// ^ Return
}
// <u64 as ::"core-0_0_0"::cmp::PartialEq<u64,>>::ne<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCg2cE9core0_0_03cmp9PartialEq1gCg2ne0g(
		uint64_t *arg0, // &'#omitted u64
		uint64_t *arg1 // &'#omitted u64
		) // -> bool

{
	RUST_BOOL rv;
	rv = (*arg0) != (*arg1);	// retval = BinOp(a0* NE a1*)
	return rv;
	// ^ Return
}
// <u64 as ::"core-0_0_0"::cmp::PartialOrd<u64,>>::ge<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCg2cE9core0_0_03cmp10PartialOrd1gCg2ge0g(
		uint64_t *arg0, // &'#omitted u64
		uint64_t *arg1 // &'#omitted u64
		) // -> bool

{
	RUST_BOOL rv;
	rv = (*arg0) >= (*arg1);	// retval = BinOp(a0* GE a1*)
	return rv;
	// ^ Return
}
// <u64 as ::"core-0_0_0"::cmp::PartialOrd<u64,>>::gt<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCg2cE9core0_0_03cmp10PartialOrd1gCg2gt0g(
		uint64_t *arg0, // &'#omitted u64
		uint64_t *arg1 // &'#omitted u64
		) // -> bool

{
	RUST_BOOL rv;
	rv = (*arg0) > (*arg1);	// retval = BinOp(a0* GT a1*)
	return rv;
	// ^ Return
}
// <u64 as ::"core-0_0_0"::cmp::PartialOrd<u64,>>::lt<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCg2cE9core0_0_03cmp10PartialOrd1gCg2lt0g(
		uint64_t *arg0, // &'#omitted u64
		uint64_t *arg1 // &'#omitted u64
		) // -> bool

{
	RUST_BOOL rv;
	rv = (*arg0) < (*arg1);	// retval = BinOp(a0* LT a1*)
	return rv;
	// ^ Return
}
// <u64 as ::"core-0_0_0"::ops::arith::AddAssign<u64,>>::add_assign<'#omitted,>
static void  ZRQCg3cE9core0_0_03ops5arith9AddAssign1gCg10add_assign0g(
		uint64_t *arg0, // &'#omitted mut u64
		uint64_t arg1 // u64
		) // -> ()

{
	tUNIT rv;
	(*arg0) = (*arg0) + arg1;	// a0* = BinOp(a0* ADD a1)
	/* ZST assign */
	// ^ drop(a0)
	return ;
	// ^ Return
}
// <u64 as ::"core-0_0_0"::ops::arith::Sub<u64,>>::sub
static uint64_t  ZRQCg3cE9core0_0_03ops5arith3Sub1gCg3sub0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64

{
	uint64_t rv;
	rv = arg0 - arg1;	// retval = BinOp(a0 SUB a1)
	return rv;
	// ^ Return
}
// <u64 as ::"core-0_0_0"::ops::bit::BitAnd<u64,>>::bitand
static uint64_t  ZRQCg3cE9core0_0_03ops3bit6BitAnd1gCg6bitand0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64

{
	uint64_t rv;
	rv = arg0 & arg1;	// retval = BinOp(a0 BIT_AND a1)
	return rv;
	// ^ Return
}
// <u64 as ::"core-0_0_0"::ops::bit::BitAndAssign<u64,>>::bitand_assign<'#omitted,>
static void  ZRQCg3cE9core0_0_03ops3bit12BitAndAssign1gCg13bitand_assign0g(
		uint64_t *arg0, // &'#omitted mut u64
		uint64_t arg1 // u64
		) // -> ()

{
	tUNIT rv;
	(*arg0) = (*arg0) & arg1;	// a0* = BinOp(a0* BIT_AND a1)
	/* ZST assign */
	// ^ drop(a0)
	return ;
	// ^ Return
}
// <u64 as ::"core-0_0_0"::ops::bit::BitOr<u64,>>::bitor
static uint64_t  ZRQCg3cE9core0_0_03ops3bit5BitOr1gCg5bitor0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64

{
	uint64_t rv;
	rv = arg0 | arg1;	// retval = BinOp(a0 BIT_OR a1)
	return rv;
	// ^ Return
}
// <u64 as ::"core-0_0_0"::ops::bit::BitOrAssign<u64,>>::bitor_assign<'#omitted,>
static void  ZRQCg3cE9core0_0_03ops3bit11BitOrAssign1gCg12bitor_assign0g(
		uint64_t *arg0, // &'#omitted mut u64
		uint64_t arg1 // u64
		) // -> ()

{
	tUNIT rv;
	(*arg0) = (*arg0) | arg1;	// a0* = BinOp(a0* BIT_OR a1)
	/* ZST assign */
	// ^ drop(a0)
	return ;
	// ^ Return
}
// <u64 as ::"core-0_0_0"::ops::bit::BitXor<u64,>>::bitxor
static uint64_t  ZRQCg3cE9core0_0_03ops3bit6BitXor1gCg6bitxor0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u64

{
	uint64_t rv;
	rv = arg0 ^ arg1;	// retval = BinOp(a0 BIT_XOR a1)
	return rv;
	// ^ Return
}
// <u64 as ::"core-0_0_0"::ops::bit::Not>::not
static uint64_t  ZRQCg3cE9core0_0_03ops3bit3Not0g3not0g(
		uint64_t arg0 // u64
		) // -> u64

{
	uint64_t rv;
	rv = ~arg0;	// retval = UniOp(a0 INV)
	return rv;
	// ^ Return
}
// <u64 as ::"core-0_0_0"::ops::bit::Shl<u32,>>::shl
static uint64_t  ZRQCg3cE9core0_0_03ops3bit3Shl1gCe3shl0g(
		uint64_t arg0, // u64
		uint32_t arg1 // u32
		) // -> u64

{
	uint64_t rv;
	rv = arg0 << arg1;	// retval = BinOp(a0 BIT_SHL a1)
	return rv;
	// ^ Return
}
// <u64 as ::"core-0_0_0"::ops::bit::ShlAssign<i32,>>::shl_assign<'#omitted,>
static void  ZRQCg3cE9core0_0_03ops3bit9ShlAssign1gCf10shl_assign0g(
		uint64_t *arg0, // &'#omitted mut u64
		int32_t arg1 // i32
		) // -> ()

{
	tUNIT rv;
	(*arg0) = (*arg0) << arg1;	// a0* = BinOp(a0* BIT_SHL a1)
	/* ZST assign */
	// ^ drop(a0)
	return ;
	// ^ Return
}
// <u64 as ::"core-0_0_0"::ops::bit::Shr<u32,>>::shr
static uint64_t  ZRQCg3cE9core0_0_03ops3bit3Shr1gCe3shr0g(
		uint64_t arg0, // u64
		uint32_t arg1 // u32
		) // -> u64

{
	uint64_t rv;
	rv = arg0 >> arg1;	// retval = BinOp(a0 BIT_SHR a1)
	return rv;
	// ^ Return
}
// <u64 as ::"core-0_0_0"::ops::bit::ShrAssign<u32,>>::shr_assign<'#omitted,>
static void  ZRQCg3cE9core0_0_03ops3bit9ShrAssign1gCe10shr_assign0g(
		uint64_t *arg0, // &'#omitted mut u64
		uint32_t arg1 // u32
		) // -> ()

{
	tUNIT rv;
	(*arg0) = (*arg0) >> arg1;	// a0* = BinOp(a0* BIT_SHR a1)
	/* ZST assign */
	// ^ drop(a0)
	return ;
	// ^ Return
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<usize,>>::cast
uintptr_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCu4cast0g(
		int64_t arg0 // i64
		) // -> usize

{
	uintptr_t rv;
	rv = (uintptr_t )arg0;	// retval = Cast(a0 as usize)
	return rv;
	// ^ Return
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<isize,>>::cast
intptr_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCv4cast0g(
		int64_t arg0 // i64
		) // -> isize

{
	intptr_t rv;
	rv = (intptr_t )arg0;	// retval = Cast(a0 as isize)
	return rv;
	// ^ Return
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u32,>>::cast
uint32_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCe4cast0g(
		int64_t arg0 // i64
		) // -> u32

{
	uint32_t rv;
	rv = (uint32_t )arg0;	// retval = Cast(a0 as u32)
	return rv;
	// ^ Return
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i32,>>::cast
int32_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCf4cast0g(
		int64_t arg0 // i64
		) // -> i32

{
	int32_t rv;
	rv = (int32_t )arg0;	// retval = Cast(a0 as i32)
	return rv;
	// ^ Return
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u64,>>::cast
uint64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCg4cast0g(
		int64_t arg0 // i64
		) // -> u64

{
	uint64_t rv;
	rv = (uint64_t )arg0;	// retval = Cast(a0 as u64)
	return rv;
	// ^ Return
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i64,>>::cast
int64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCh4cast0g(
		int64_t arg0 // i64
		) // -> i64

{
	int64_t rv;
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u128,>>::cast
uint128_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCi4cast0g(
		int64_t arg0 // i64
		) // -> u128

{
	uint128_t rv;
	rv.lo = arg0; rv.hi = arg0 < 0 ? -1 : 0;	// retval = Cast(a0 as u128)
	return rv;
	// ^ Return
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i128,>>::cast
int128_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCj4cast0g(
		int64_t arg0 // i64
		) // -> i128

{
	int128_t rv;
	rv.lo = arg0; rv.hi = arg0 < 0 ? -1 : 0;	// retval = Cast(a0 as i128)
	return rv;
	// ^ Return
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div
int64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64

{
	int64_t rv;
	struct e_ZRG2cE9core0_0_06option6Option1gCh var0;	// ::"core-0_0_0"::option::Option<i64,>/*E*/
	var0 = ZRICh11checked_div0g( arg0, arg1 );
	// ^ Call( _0 = <i64 /*- */>::checked_div( a0, a1, ), bb1, bb3)
	rv = ZRG2cR25compiler_builtins0_0_0_Hb3int6unwrap1gCh( var0 );
	// ^ Call( retval = ::"compiler_builtins-0_0_0_Hb"::int::unwrap<i64,>( _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_rem
int64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_rem0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64

{
	int64_t rv;
	struct e_ZRG2cE9core0_0_06option6Option1gCh var0;	// ::"core-0_0_0"::option::Option<i64,>/*E*/
	var0 = ZRICh11checked_rem0g( arg0, arg1 );
	// ^ Call( _0 = <i64 /*- */>::checked_rem( a0, a1, ), bb1, bb3)
	rv = ZRG2cR25compiler_builtins0_0_0_Hb3int6unwrap1gCh( var0 );
	// ^ Call( retval = ::"compiler_builtins-0_0_0_Hb"::int::unwrap<i64,>( _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::extract_sign
TUP_2_ZRTCw_ZRTCg  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g12extract_sign0g(
		int64_t arg0 // i64
		) // -> (bool, u64, )

{
	TUP_2_ZRTCw_ZRTCg rv;
	RUST_BOOL var0;	// bool
	uint64_t var1;	// u64
	uint64_t var2;	// u64
	uint64_t var3;	// u64
	uint64_t var4;	// u64
	var0 = arg0 < 0ll;	// _0 = BinOp(a0 LT +0 i64)
	if(var0) goto bb1; else goto bb3;
	// ^ If( _0 : 1, 3)
bb1:
	var1 = (uint64_t )arg0;	// _1 = Cast(a0 as u64)
	var4 = ~var1;	// _4 = UniOp(_1 INV)
	__builtin_add_overflow(var4, 0x1ull, &var3);
	// ^ Call( _3 = "overflowing_add"::<u64,>( _4, 0x1 u64, ), bb2, bb4)
	;
	rv._0 = true;
	rv._1 = var3;	// retval = Tuple(true, _3)
	return rv;
	// ^ Return
bb3:
	var2 = (uint64_t )arg0;	// _2 = Cast(a0 as u64)
	;
	rv._0 = false;
	rv._1 = var2;	// retval = Tuple(false, _2)
	return rv;
	// ^ Return
bb4: _Unwind_Resume(); // Diverge
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::from_bool
int64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g9from_bool0g(
		RUST_BOOL arg0 // bool
		) // -> i64

{
	int64_t rv;
	rv = (int64_t )arg0;	// retval = Cast(a0 as i64)
	return rv;
	// ^ Return
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::from_unsigned
int64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g13from_unsigned0g(
		uint64_t arg0 // u64
		) // -> i64

{
	int64_t rv;
	rv = (int64_t )arg0;	// retval = Cast(a0 as i64)
	return rv;
	// ^ Return
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::leading_zeros
uint32_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g13leading_zeros0g(
		int64_t arg0 // i64
		) // -> u32

{
	uint32_t rv;
	uint64_t var0;	// u64
	uint64_t var1;	// u64
	var1 = (uint64_t )arg0;	// _1 = Cast(a0 as u64)
	var0 = (var1 != 0 ? __builtin_clz64(var1) : sizeof(uint64_t )*8);
	// ^ Call( _0 = "ctlz"::<u64,>( _1, ), bb1, bb2)
	rv = (uint32_t )var0;	// retval = Cast(_0 as u32)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::max_value
int64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g9max_value0g(void) // -> i64

{
	int64_t rv;
	rv = INT64_MAX;	// retval = Constant(+9223372036854775807 i64)
	return rv;
	// ^ Return
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::min_value
int64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g9min_value0g(void) // -> i64

{
	int64_t rv;
	rv = INT64_MIN;	// retval = Constant(-9223372036854775808 i64)
	return rv;
	// ^ Return
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::overflowing_add
TUP_2_ZRTCh_ZRTCw  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g15overflowing_add0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> (i64, bool, )

{
	TUP_2_ZRTCh_ZRTCw rv;
	TUP_2_ZRTCh_ZRTCw var0;	// (i64, bool, )
	var0._1 = __builtin_add_overflow(arg0, arg1, &var0._0);
	// ^ Call( _0 = "add_with_overflow"::<i64,>( a0, a1, ), bb1, bb2)
	;
	rv._0 = var0._0;
	rv._1 = var0._1;	// retval = Tuple(_0.0, _0.1)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::unsigned
uint64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g8unsigned0g(
		int64_t arg0 // i64
		) // -> u64

{
	uint64_t rv;
	rv = (uint64_t )arg0;	// retval = Cast(a0 as u64)
	return rv;
	// ^ Return
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_add
int64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_add0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64

{
	int64_t rv;
	__builtin_add_overflow(arg0, arg1, &rv);
	// ^ Call( retval = "overflowing_add"::<i64,>( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_mul
int64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_mul0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64

{
	int64_t rv;
	__builtin_mul_overflow(arg0, arg1, &rv);
	// ^ Call( retval = "overflowing_mul"::<i64,>( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_shl
int64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_shl0g(
		int64_t arg0, // i64
		uint32_t arg1 // u32
		) // -> i64

{
	int64_t rv;
	uint32_t var0;	// u32
	int64_t var1;	// i64
	var0 = arg1 & 0x3f;	// _0 = BinOp(a1 BIT_AND 0x3f u32)
	var1 = (int64_t )var0;	// _1 = Cast(_0 as i64)
	rv = arg0 << var1;
	// ^ Call( retval = "unchecked_shl"::<i64,>( a0, _1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_sub
int64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_sub0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64

{
	int64_t rv;
	__builtin_sub_overflow(arg0, arg1, &rv);
	// ^ Call( retval = "overflowing_sub"::<i64,>( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::from_parts
int64_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g10from_parts0g(
		uint32_t arg0, // u32
		int32_t arg1 // i32
		) // -> i64

{
	int64_t rv;
	int64_t var0;	// i64
	int64_t var1;	// i64
	int64_t var2;	// i64
	var0 = (int64_t )arg0;	// _0 = Cast(a0 as i64)
	var2 = (int64_t )arg1;	// _2 = Cast(a1 as i64)
	var1 = var2 << 32;	// _1 = BinOp(_2 BIT_SHL +32 i32)
	rv = var0 | var1;	// retval = BinOp(_0 BIT_OR _1)
	return rv;
	// ^ Return
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::high
int32_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g4high0g(
		int64_t arg0 // i64
		) // -> i32

{
	int32_t rv;
	int64_t var0;	// i64
	var0 = arg0 >> 32;	// _0 = BinOp(a0 BIT_SHR +32 i32)
	rv = (int32_t )var0;	// retval = Cast(_0 as i32)
	return rv;
	// ^ Return
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::high_as_low
uint32_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g11high_as_low0g(
		int32_t arg0 // i32
		) // -> u32

{
	uint32_t rv;
	rv = (uint32_t )arg0;	// retval = Cast(a0 as u32)
	return rv;
	// ^ Return
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::low
uint32_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g3low0g(
		int64_t arg0 // i64
		) // -> u32

{
	uint32_t rv;
	rv = (uint32_t )arg0;	// retval = Cast(a0 as u32)
	return rv;
	// ^ Return
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::low_as_high
int32_t  ZRQCh2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g11low_as_high0g(
		uint32_t arg0 // u32
		) // -> i32

{
	int32_t rv;
	rv = (int32_t )arg0;	// retval = Cast(a0 as i32)
	return rv;
	// ^ Return
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::mul::Mulo>::mulo<'#omitted,>
int64_t  ZRQCh3cR25compiler_builtins0_0_0_Hb3int3mul4Mulo0g4mulo0g(
		int64_t arg0, // i64
		int64_t arg1, // i64
		int32_t *arg2 // &'#omitted mut i32
		) // -> i64

{
	int64_t rv;
	int64_t var0;	// i64
	int64_t var1;	// i64
	int64_t var2;	// i64
	int64_t var3;	// i64
	int64_t var4;	// i64
	int64_t var5;	// i64
	RUST_BOOL var6;	// bool
	int64_t var7;	// i64
	int64_t var8;	// i64
	int64_t var9;	// i64
	int64_t var10;	// i64
	int64_t *var11;	// &'#omitted i64
	int64_t var12;	// i64
	int64_t *var13;	// &'#omitted i64
	(*arg2) = 0;	// a2* = Constant(+0 i32)
	__builtin_mul_overflow(arg0, arg1, &var0);
	// ^ Call( _0 = "overflowing_mul"::<i64,>( a0, a1, ), bb1, bb2)
	var6 = arg0 == INT64_MIN;	// _6 = BinOp(a0 EQ -9223372036854775808 i64)
	if(var6) goto bb3; else goto bb4;
	// ^ If( _6 : 3, 4)
bb2: _Unwind_Resume(); // Diverge
bb3:
	var6 = arg1 != 0ll;	// _6 = BinOp(a1 NE +0 i64)
	if(var6) goto bb17; else goto bb15;
	// ^ If( _6 : 17, 15)
bb4:
	var6 = arg1 == INT64_MIN;	// _6 = BinOp(a1 EQ -9223372036854775808 i64)
	if(var6) goto bb5; else goto bb6;
	// ^ If( _6 : 5, 6)
bb5:
	var6 = arg0 != 0ll;	// _6 = BinOp(a0 NE +0 i64)
	if(var6) goto bb16; else goto bb15;
	// ^ If( _6 : 16, 15)
bb6:
	var1 = arg0 >> 0x3f;	// _1 = BinOp(a0 BIT_SHR 0x3f u32)
	var9 = arg0 ^ var1;	// _9 = BinOp(a0 BIT_XOR _1)
	var2 = var9 - var1;	// _2 = BinOp(_9 SUB _1)
	var3 = arg1 >> 0x3f;	// _3 = BinOp(a1 BIT_SHR 0x3f u32)
	var10 = arg1 ^ var3;	// _10 = BinOp(a1 BIT_XOR _3)
	var4 = var10 - var3;	// _4 = BinOp(_10 SUB _3)
	var5 = 2ll;	// _5 = Constant(+2 i64)
	var6 = var2 < 2ll;	// _6 = BinOp(_2 LT +2 i64)
	if(var6) goto bb15; else goto bb7;
	// ^ If( _6 : 15, 7)
bb7:
	var6 = var4 < var5;	// _6 = BinOp(_4 LT _5)
	if(var6) goto bb15; else goto bb8;
	// ^ If( _6 : 15, 8)
bb8:
	var6 = var1 == var3;	// _6 = BinOp(_1 EQ _3)
	if(var6) goto bb9; else goto bb11;
	// ^ If( _6 : 9, 11)
bb9:
	var11 = & var2;	// _11 = Borrow(Shared, _2)
	var7 = ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g( INT64_MAX, var4 );
	// ^ Call( _7 = <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div( +9223372036854775807 i64, _4, ), bb10, bb2)
	var6 = (*var11) > var7;	// _6 = BinOp(_11* GT _7)
	goto bb13;
	// ^ Goto(13)
bb11:
	var13 = & var2;	// _13 = Borrow(Shared, _2)
	var12 = -var4;	// _12 = UniOp(_4 NEG)
	var8 = ZRQCh2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g( INT64_MIN, var12 );
	// ^ Call( _8 = <i64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div( -9223372036854775808 i64, _12, ), bb12, bb2)
	var6 = (*var13) > var8;	// _6 = BinOp(_13* GT _8)
	// ^ Goto(13)
bb13:
	if(var6) goto bb14; else goto bb15;
	// ^ If( _6 : 14, 15)
bb14:
	(*arg2) = 1;	// a2* = Constant(+1 i32)
	// ^ Goto(15)
bb15:
	rv = var0;	// retval = Use(_0)
	// ^ drop(a2)
	return rv;
	// ^ Return
bb16:
	var6 = arg0 != 1ll;	// _6 = BinOp(a0 NE +1 i64)
	goto bb13;
	// ^ Goto(13)
bb17:
	var6 = arg1 != 1ll;	// _6 = BinOp(a1 NE +1 i64)
	goto bb13;
	// ^ Goto(13)
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Div>::div
int64_t  ZRQCh3cR25compiler_builtins0_0_0_Hb3int4sdiv3Div0g3div0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64

{
	int64_t rv;
	int64_t var0;	// i64
	int64_t var1;	// i64
	int64_t var2;	// i64
	int64_t var3;	// i64
	int64_t var4;	// i64
	uint64_t var5;	// u64
	int64_t var6;	// i64
	uint64_t var7;	// u64
	int64_t var8;	// i64
	uint64_t var9;	// u64
	int64_t var10;	// i64
	int64_t var11;	// i64
	var0 = arg0 >> 0x3f;	// _0 = BinOp(a0 BIT_SHR 0x3f u32)
	var1 = arg1 >> 0x3f;	// _1 = BinOp(a1 BIT_SHR 0x3f u32)
	var3 = arg0 ^ var0;	// _3 = BinOp(a0 BIT_XOR _0)
	__builtin_sub_overflow(var3, var0, &var6);
	// ^ Call( _6 = "overflowing_sub"::<i64,>( _3, _0, ), bb1, bb4)
	var4 = arg1 ^ var1;	// _4 = BinOp(a1 BIT_XOR _1)
	__builtin_sub_overflow(var4, var1, &var8);
	// ^ Call( _8 = "overflowing_sub"::<i64,>( _4, _1, ), bb2, bb4)
	var2 = var0 ^ var1;	// _2 = BinOp(_0 BIT_XOR _1)
	var5 = (uint64_t )var6;	// _5 = Cast(_6 as u64)
	var7 = (uint64_t )var8;	// _7 = Cast(_8 as u64)
	var9 = ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g( var5, var7 );
	// ^ Call( _9 = <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div( _5, _7, ), bb3, bb4)
	var10 = (int64_t )var9;	// _10 = Cast(_9 as i64)
	var11 = var10 ^ var2;	// _11 = BinOp(_10 BIT_XOR _2)
	rv = var11 - var2;	// retval = BinOp(_11 SUB _2)
	return rv;
	// ^ Return
bb4: _Unwind_Resume(); // Diverge
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Divmod>::divmod<'#omitted,::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmoddi4_1/*S*/,>
int64_t  ZRQCh3cR25compiler_builtins0_0_0_Hb3int4sdiv6Divmod0g6divmod1gG3c_A_B_CH20closure__divmoddi4_10g(
		int64_t arg0, // i64
		int64_t arg1, // i64
		int64_t *arg2, // &'#omitted mut i64
		struct s_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmoddi4_10g arg3 // ::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmoddi4_1/*S*/
		) // -> i64

{
	int64_t rv;
	int64_t var0;	// i64
	int64_t var1;	// i64
	var0 = ZRQCh3cR25compiler_builtins0_0_0_Hb3int4sdiv3Div0g3div0g( arg0, arg1 );
	// ^ Call( _0 = <i64 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Div>::div( a0, a1, ), bb1, bb3)
	__builtin_mul_overflow(var0, arg1, &var1);
	// ^ Call( _1 = "overflowing_mul"::<i64,>( _0, a1, ), bb2, bb3)
	(*arg2) = arg0 - var1;	// a2* = BinOp(a0 SUB _1)
	rv = var0;	// retval = Use(_0)
	// ^ drop(a2)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Mod>::mod_
int64_t  ZRQCh3cR25compiler_builtins0_0_0_Hb3int4sdiv3Mod0g4mod_0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64

{
	int64_t rv;
	int64_t var0;	// i64
	int64_t var1;	// i64
	int64_t var2;	// i64
	int64_t var3;	// i64
	uint64_t var4;	// u64
	int64_t var5;	// i64
	uint64_t var6;	// u64
	int64_t var7;	// i64
	uint64_t var8;	// u64
	int64_t var9;	// i64
	int64_t var10;	// i64
	var0 = arg1 >> 0x3f;	// _0 = BinOp(a1 BIT_SHR 0x3f u32)
	var2 = arg1 ^ var0;	// _2 = BinOp(a1 BIT_XOR _0)
	__builtin_sub_overflow(var2, var0, &var7);
	// ^ Call( _7 = "overflowing_sub"::<i64,>( _2, _0, ), bb1, bb4)
	var1 = arg0 >> 0x3f;	// _1 = BinOp(a0 BIT_SHR 0x3f u32)
	var3 = arg0 ^ var1;	// _3 = BinOp(a0 BIT_XOR _1)
	__builtin_sub_overflow(var3, var1, &var5);
	// ^ Call( _5 = "overflowing_sub"::<i64,>( _3, _1, ), bb2, bb4)
	var4 = (uint64_t )var5;	// _4 = Cast(_5 as u64)
	var6 = (uint64_t )var7;	// _6 = Cast(_7 as u64)
	var8 = ZRQCg2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_rem0g( var4, var6 );
	// ^ Call( _8 = <u64 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_rem( _4, _6, ), bb3, bb4)
	var9 = (int64_t )var8;	// _9 = Cast(_8 as i64)
	var10 = var9 ^ var1;	// _10 = BinOp(_9 BIT_XOR _1)
	rv = var10 - var1;	// retval = BinOp(_10 SUB _1)
	return rv;
	// ^ Return
bb4: _Unwind_Resume(); // Diverge
}
// <i64 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Ashr>::ashr
int64_t  ZRQCh3cR25compiler_builtins0_0_0_Hb3int5shift4Ashr0g4ashr0g(
		int64_t arg0, // i64
		uint32_t arg1 // u32
		) // -> i64

{
	int64_t rv;
	uint32_t var0;	// u32
	RUST_BOOL var1;	// bool
	uint32_t var2;	// u32
	int64_t var3;	// i64
	int32_t var4;	// i32
	uint32_t var5;	// u32
	int32_t var6;	// i32
	int64_t var7;	// i64
	int32_t var8;	// i32
	uint32_t var9;	// u32
	int64_t var10;	// i64
	int64_t var11;	// i64
	int64_t var12;	// i64
	uint32_t var13;	// u32
	int32_t var14;	// i32
	int64_t var15;	// i64
	int32_t var16;	// i32
	uint32_t var17;	// u32
	uint32_t var18;	// u32
	uint32_t var19;	// u32
	uint32_t var20;	// u32
	uint32_t var21;	// u32
	int64_t var22;	// i64
	int32_t var23;	// i32
	int64_t var24;	// i64
	int64_t var25;	// i64
	int64_t var26;	// i64
	uint32_t var27;	// u32
	int32_t var28;	// i32
	var0 = 0x20;	// _0 = Constant(0x20 u32)
	var2 = arg1 & 0x20;	// _2 = BinOp(a1 BIT_AND 0x20 u32)
	var1 = var2 != 0x0;	// _1 = BinOp(_2 NE 0x0 u32)
	if(var1) goto bb1; else goto bb2;
	// ^ If( _1 : 1, 2)
bb1:
	var3 = arg0 >> 32;	// _3 = BinOp(a0 BIT_SHR +32 i32)
	var4 = (int32_t )var3;	// _4 = Cast(_3 as i32)
	var5 = arg1 - var0;	// _5 = BinOp(a1 SUB _0)
	var6 = var4 >> var5;	// _6 = BinOp(_4 BIT_SHR _5)
	var13 = (uint32_t )var6;	// _13 = Cast(_6 as u32)
	var7 = arg0 >> 32;	// _7 = BinOp(a0 BIT_SHR +32 i32)
	var8 = (int32_t )var7;	// _8 = Cast(_7 as i32)
	var9 = var0 - 0x1;	// _9 = BinOp(_0 SUB 0x1 u32)
	var14 = var8 >> var9;	// _14 = BinOp(_8 BIT_SHR _9)
	var10 = (int64_t )var13;	// _10 = Cast(_13 as i64)
	var12 = (int64_t )var14;	// _12 = Cast(_14 as i64)
	var11 = var12 << 32;	// _11 = BinOp(_12 BIT_SHL +32 i32)
	rv = var10 | var11;	// retval = BinOp(_10 BIT_OR _11)
	return rv;
	// ^ Return
bb2:
	var1 = arg1 == 0x0;	// _1 = BinOp(a1 EQ 0x0 u32)
	if(var1) goto bb3; else goto bb4;
	// ^ If( _1 : 3, 4)
bb3:
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
bb4:
	var15 = arg0 >> 32;	// _15 = BinOp(a0 BIT_SHR +32 i32)
	var16 = (int32_t )var15;	// _16 = Cast(_15 as i32)
	var17 = (uint32_t )var16;	// _17 = Cast(_16 as u32)
	var18 = var0 - arg1;	// _18 = BinOp(_0 SUB a1)
	var20 = var17 << var18;	// _20 = BinOp(_17 BIT_SHL _18)
	var19 = (uint32_t )arg0;	// _19 = Cast(a0 as u32)
	var21 = var19 >> arg1;	// _21 = BinOp(_19 BIT_SHR a1)
	var27 = var20 | var21;	// _27 = BinOp(_20 BIT_OR _21)
	var22 = arg0 >> 32;	// _22 = BinOp(a0 BIT_SHR +32 i32)
	var23 = (int32_t )var22;	// _23 = Cast(_22 as i32)
	var28 = var23 >> arg1;	// _28 = BinOp(_23 BIT_SHR a1)
	var24 = (int64_t )var27;	// _24 = Cast(_27 as i64)
	var26 = (int64_t )var28;	// _26 = Cast(_28 as i64)
	var25 = var26 << 32;	// _25 = BinOp(_26 BIT_SHL +32 i32)
	rv = var24 | var25;	// retval = BinOp(_24 BIT_OR _25)
	return rv;
	// ^ Return
}
// <i64 as ::"core-0_0_0"::cmp::PartialEq<i64,>>::eq<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCh2cE9core0_0_03cmp9PartialEq1gCh2eq0g(
		int64_t *arg0, // &'#omitted i64
		int64_t *arg1 // &'#omitted i64
		) // -> bool

{
	RUST_BOOL rv;
	rv = (*arg0) == (*arg1);	// retval = BinOp(a0* EQ a1*)
	return rv;
	// ^ Return
}
// <i64 as ::"core-0_0_0"::cmp::PartialEq<i64,>>::ne<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCh2cE9core0_0_03cmp9PartialEq1gCh2ne0g(
		int64_t *arg0, // &'#omitted i64
		int64_t *arg1 // &'#omitted i64
		) // -> bool

{
	RUST_BOOL rv;
	rv = (*arg0) != (*arg1);	// retval = BinOp(a0* NE a1*)
	return rv;
	// ^ Return
}
// <i64 as ::"core-0_0_0"::cmp::PartialOrd<i64,>>::ge<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCh2cE9core0_0_03cmp10PartialOrd1gCh2ge0g(
		int64_t *arg0, // &'#omitted i64
		int64_t *arg1 // &'#omitted i64
		) // -> bool

{
	RUST_BOOL rv;
	rv = (*arg0) >= (*arg1);	// retval = BinOp(a0* GE a1*)
	return rv;
	// ^ Return
}
// <i64 as ::"core-0_0_0"::cmp::PartialOrd<i64,>>::gt<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCh2cE9core0_0_03cmp10PartialOrd1gCh2gt0g(
		int64_t *arg0, // &'#omitted i64
		int64_t *arg1 // &'#omitted i64
		) // -> bool

{
	RUST_BOOL rv;
	rv = (*arg0) > (*arg1);	// retval = BinOp(a0* GT a1*)
	return rv;
	// ^ Return
}
// <i64 as ::"core-0_0_0"::cmp::PartialOrd<i64,>>::lt<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCh2cE9core0_0_03cmp10PartialOrd1gCh2lt0g(
		int64_t *arg0, // &'#omitted i64
		int64_t *arg1 // &'#omitted i64
		) // -> bool

{
	RUST_BOOL rv;
	rv = (*arg0) < (*arg1);	// retval = BinOp(a0* LT a1*)
	return rv;
	// ^ Return
}
// <i64 as ::"core-0_0_0"::ops::arith::Add<i64,>>::add
static int64_t  ZRQCh3cE9core0_0_03ops5arith3Add1gCh3add0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64

{
	int64_t rv;
	rv = arg0 + arg1;	// retval = BinOp(a0 ADD a1)
	return rv;
	// ^ Return
}
// <i64 as ::"core-0_0_0"::ops::arith::AddAssign<i64,>>::add_assign<'#omitted,>
static void  ZRQCh3cE9core0_0_03ops5arith9AddAssign1gCh10add_assign0g(
		int64_t *arg0, // &'#omitted mut i64
		int64_t arg1 // i64
		) // -> ()

{
	tUNIT rv;
	(*arg0) = (*arg0) + arg1;	// a0* = BinOp(a0* ADD a1)
	/* ZST assign */
	// ^ drop(a0)
	return ;
	// ^ Return
}
// <i64 as ::"core-0_0_0"::ops::arith::Neg>::neg
static int64_t  ZRQCh3cE9core0_0_03ops5arith3Neg0g3neg0g(
		int64_t arg0 // i64
		) // -> i64

{
	int64_t rv;
	rv = -arg0;	// retval = UniOp(a0 NEG)
	return rv;
	// ^ Return
}
// <i64 as ::"core-0_0_0"::ops::arith::Sub<i64,>>::sub
static int64_t  ZRQCh3cE9core0_0_03ops5arith3Sub1gCh3sub0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64

{
	int64_t rv;
	rv = arg0 - arg1;	// retval = BinOp(a0 SUB a1)
	return rv;
	// ^ Return
}
// <i64 as ::"core-0_0_0"::ops::bit::BitAnd<i64,>>::bitand
static int64_t  ZRQCh3cE9core0_0_03ops3bit6BitAnd1gCh6bitand0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64

{
	int64_t rv;
	rv = arg0 & arg1;	// retval = BinOp(a0 BIT_AND a1)
	return rv;
	// ^ Return
}
// <i64 as ::"core-0_0_0"::ops::bit::BitXor<i64,>>::bitxor
static int64_t  ZRQCh3cE9core0_0_03ops3bit6BitXor1gCh6bitxor0g(
		int64_t arg0, // i64
		int64_t arg1 // i64
		) // -> i64

{
	int64_t rv;
	rv = arg0 ^ arg1;	// retval = BinOp(a0 BIT_XOR a1)
	return rv;
	// ^ Return
}
// <i64 as ::"core-0_0_0"::ops::bit::Shr<u32,>>::shr
static int64_t  ZRQCh3cE9core0_0_03ops3bit3Shr1gCe3shr0g(
		int64_t arg0, // i64
		uint32_t arg1 // u32
		) // -> i64

{
	int64_t rv;
	rv = arg0 >> arg1;	// retval = BinOp(a0 BIT_SHR a1)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<usize,>>::cast
uintptr_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCu4cast0g(
		uint128_t arg0 // u128
		) // -> usize

{
	uintptr_t rv;
	rv = arg0.lo;	// retval = Cast(a0 as usize)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<isize,>>::cast
intptr_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCv4cast0g(
		uint128_t arg0 // u128
		) // -> isize

{
	intptr_t rv;
	rv = arg0.lo;	// retval = Cast(a0 as isize)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u32,>>::cast
uint32_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCe4cast0g(
		uint128_t arg0 // u128
		) // -> u32

{
	uint32_t rv;
	rv = arg0.lo;	// retval = Cast(a0 as u32)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i32,>>::cast
int32_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCf4cast0g(
		uint128_t arg0 // u128
		) // -> i32

{
	int32_t rv;
	rv = arg0.lo;	// retval = Cast(a0 as i32)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u64,>>::cast
uint64_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCg4cast0g(
		uint128_t arg0 // u128
		) // -> u64

{
	uint64_t rv;
	rv = arg0.lo;	// retval = Cast(a0 as u64)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i64,>>::cast
int64_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCh4cast0g(
		uint128_t arg0 // u128
		) // -> i64

{
	int64_t rv;
	rv = arg0.lo;	// retval = Cast(a0 as i64)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u128,>>::cast
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCi4cast0g(
		uint128_t arg0 // u128
		) // -> u128

{
	uint128_t rv;
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i128,>>::cast
int128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCj4cast0g(
		uint128_t arg0 // u128
		) // -> i128

{
	int128_t rv;
	rv.lo = arg0.lo; rv.hi = arg0.hi;	// retval = Cast(a0 as i128)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128

{
	uint128_t rv;
	struct e_ZRG2cE9core0_0_06option6Option1gCi var0;	// ::"core-0_0_0"::option::Option<u128,>/*E*/
	var0 = ZRICi11checked_div0g( arg0, arg1 );
	// ^ Call( _0 = <u128 /*- */>::checked_div( a0, a1, ), bb1, bb3)
	rv = ZRG2cR25compiler_builtins0_0_0_Hb3int6unwrap1gCi( var0 );
	// ^ Call( retval = ::"compiler_builtins-0_0_0_Hb"::int::unwrap<u128,>( _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_rem
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_rem0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128

{
	uint128_t rv;
	struct e_ZRG2cE9core0_0_06option6Option1gCi var0;	// ::"core-0_0_0"::option::Option<u128,>/*E*/
	var0 = ZRICi11checked_rem0g( arg0, arg1 );
	// ^ Call( _0 = <u128 /*- */>::checked_rem( a0, a1, ), bb1, bb3)
	rv = ZRG2cR25compiler_builtins0_0_0_Hb3int6unwrap1gCi( var0 );
	// ^ Call( retval = ::"compiler_builtins-0_0_0_Hb"::int::unwrap<u128,>( _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::extract_sign
TUP_2_ZRTCw_ZRTCi  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g12extract_sign0g(
		uint128_t arg0 // u128
		) // -> (bool, u128, )

{
	TUP_2_ZRTCw_ZRTCi rv;
	;
	rv._0 = false;
	rv._1 = arg0;	// retval = Tuple(false, a0)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::from_bool
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g9from_bool0g(
		RUST_BOOL arg0 // bool
		) // -> u128

{
	uint128_t rv;
	rv.lo = arg0; rv.hi = arg0 < 0 ? -1 : 0;	// retval = Cast(a0 as u128)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::from_unsigned
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g13from_unsigned0g(
		uint128_t arg0 // u128
		) // -> u128

{
	uint128_t rv;
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::leading_zeros
uint32_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g13leading_zeros0g(
		uint128_t arg0 // u128
		) // -> u32

{
	uint32_t rv;
	uint128_t var0;	// u128
	var0 = (intrinsic_ctlz_u128(arg0));	// ^ Call( _0 = "ctlz"::<u128,>( a0, ), bb1, bb2)
	rv = var0.lo;	// retval = Cast(_0 as u32)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::max_value
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g9max_value0g(void) // -> u128

{
	uint128_t rv;
	uint128_t var0;	// u128
	var0 = make128_raw(0ull, 0ull);	// _0 = Constant(0x0 u128)
	rv.lo = ~var0.lo; rv.hi = ~var0.hi;	// retval = UniOp(_0 INV)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::min_value
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g9min_value0g(void) // -> u128

{
	uint128_t rv;
	rv = make128_raw(0ull, 0ull);	// retval = Constant(0x0 u128)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::overflowing_add
TUP_2_ZRTCi_ZRTCw  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g15overflowing_add0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> (u128, bool, )

{
	TUP_2_ZRTCi_ZRTCw rv;
	TUP_2_ZRTCi_ZRTCw var0;	// (u128, bool, )
	var0._1 = add128_o(arg0, arg1, &var0._0);
	// ^ Call( _0 = "add_with_overflow"::<u128,>( a0, a1, ), bb1, bb2)
	;
	rv._0 = var0._0;
	rv._1 = var0._1;	// retval = Tuple(_0.0, _0.1)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::unsigned
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g8unsigned0g(
		uint128_t arg0 // u128
		) // -> u128

{
	uint128_t rv;
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_add
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_add0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128

{
	uint128_t rv;
	add128_o(arg0, arg1, &rv);
	// ^ Call( retval = "overflowing_add"::<u128,>( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_mul
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_mul0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128

{
	uint128_t rv;
	mul128_o(arg0, arg1, &rv);
	// ^ Call( retval = "overflowing_mul"::<u128,>( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_shl
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_shl0g(
		uint128_t arg0, // u128
		uint32_t arg1 // u32
		) // -> u128

{
	uint128_t rv;
	uint32_t var0;	// u32
	uint128_t var1;	// u128
	var0 = arg1 & 0x7f;	// _0 = BinOp(a1 BIT_AND 0x7f u32)
	var1.lo = var0; var1.hi = var0 < 0 ? -1 : 0;	// _1 = Cast(_0 as u128)
	rv = shl128(arg0, var1.lo);
	// ^ Call( retval = "unchecked_shl"::<u128,>( a0, _1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_sub
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_sub0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128

{
	uint128_t rv;
	sub128_o(arg0, arg1, &rv);
	// ^ Call( retval = "overflowing_sub"::<u128,>( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::from_parts
uint128_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g10from_parts0g(
		uint64_t arg0, // u64
		uint64_t arg1 // u64
		) // -> u128

{
	uint128_t rv;
	uint128_t var0;	// u128
	uint128_t var1;	// u128
	uint128_t var2;	// u128
	var0.lo = arg0; var0.hi = arg0 < 0 ? -1 : 0;	// _0 = Cast(a0 as u128)
	var2.lo = arg1; var2.hi = arg1 < 0 ? -1 : 0;	// _2 = Cast(a1 as u128)
	var1 = shl128(var2, 64);	// _1 = BinOp(_2 BIT_SHL +64 i32)
	rv = or128(var0, var1);	// retval = BinOp(_0 BIT_OR _1)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::high
uint64_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g4high0g(
		uint128_t arg0 // u128
		) // -> u64

{
	uint64_t rv;
	uint128_t var0;	// u128
	var0 = shr128(arg0, 64);	// _0 = BinOp(a0 BIT_SHR +64 i32)
	rv = var0.lo;	// retval = Cast(_0 as u64)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::high_as_low
uint64_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g11high_as_low0g(
		uint64_t arg0 // u64
		) // -> u64

{
	uint64_t rv;
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::low
uint64_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g3low0g(
		uint128_t arg0 // u128
		) // -> u64

{
	uint64_t rv;
	rv = arg0.lo;	// retval = Cast(a0 as u64)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::low_as_high
uint64_t  ZRQCi2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g11low_as_high0g(
		uint64_t arg0 // u64
		) // -> u64

{
	uint64_t rv;
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::AddSub>::add
uint128_t  ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub6AddSub0g3add0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128

{
	uint128_t rv;
	rv = ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub7UAddSub0g4uadd0g( arg0, arg1 );
	// ^ Call( retval = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::UAddSub>::uadd( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::AddSub>::sub
uint128_t  ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub6AddSub0g3sub0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128

{
	uint128_t rv;
	rv = ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub7UAddSub0g4usub0g( arg0, arg1 );
	// ^ Call( retval = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::UAddSub>::usub( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::Addo>::addo<'#omitted,>
uint128_t  ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub4Addo0g4addo0g(
		uint128_t arg0, // u128
		uint128_t arg1, // u128
		int32_t *arg2 // &'#omitted mut i32
		) // -> u128

{
	uint128_t rv;
	uint128_t var0;	// u128
	RUST_BOOL var1;	// bool
	(*arg2) = 0;	// a2* = Constant(+0 i32)
	var0 = ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub7UAddSub0g4uadd0g( arg0, arg1 );
	// ^ Call( _0 = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::UAddSub>::uadd( a0, a1, ), bb1, bb2)
	var1 = 0 >= cmp128(make128_raw(0ull, 0ull), arg1);	// _1 = BinOp(a1 GE 0x0 u128)
	if(var1) goto bb3; else goto bb4;
	// ^ If( _1 : 3, 4)
bb2: _Unwind_Resume(); // Diverge
bb3:
	var1 = 0 < cmp128(arg0, var0);	// _1 = BinOp(_0 LT a0)
	goto bb5;
	// ^ Goto(5)
bb4:
	var1 = 0 >= cmp128(arg0, var0);	// _1 = BinOp(_0 GE a0)
	// ^ Goto(5)
bb5:
	if(var1) goto bb6; else goto bb7;
	// ^ If( _1 : 6, 7)
bb6:
	(*arg2) = 1;	// a2* = Constant(+1 i32)
	// ^ Goto(7)
bb7:
	rv = var0;	// retval = Use(_0)
	// ^ drop(a2)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::Subo>::subo<'#omitted,>
uint128_t  ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub4Subo0g4subo0g(
		uint128_t arg0, // u128
		uint128_t arg1, // u128
		int32_t *arg2 // &'#omitted mut i32
		) // -> u128

{
	uint128_t rv;
	uint128_t var0;	// u128
	RUST_BOOL var1;	// bool
	(*arg2) = 0;	// a2* = Constant(+0 i32)
	var0 = ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub7UAddSub0g4usub0g( arg0, arg1 );
	// ^ Call( _0 = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::UAddSub>::usub( a0, a1, ), bb1, bb2)
	var1 = 0 >= cmp128(make128_raw(0ull, 0ull), arg1);	// _1 = BinOp(a1 GE 0x0 u128)
	if(var1) goto bb3; else goto bb4;
	// ^ If( _1 : 3, 4)
bb2: _Unwind_Resume(); // Diverge
bb3:
	var1 = 0 > cmp128(arg0, var0);	// _1 = BinOp(_0 GT a0)
	goto bb5;
	// ^ Goto(5)
bb4:
	var1 = 0 <= cmp128(arg0, var0);	// _1 = BinOp(_0 LE a0)
	// ^ Goto(5)
bb5:
	if(var1) goto bb6; else goto bb7;
	// ^ If( _1 : 6, 7)
bb6:
	(*arg2) = 1;	// a2* = Constant(+1 i32)
	// ^ Goto(7)
bb7:
	rv = var0;	// retval = Use(_0)
	// ^ drop(a2)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::UAddSub>::uadd
uint128_t  ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub7UAddSub0g4uadd0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128

{
	uint128_t rv;
	uint64_t var0;	// u64
	uint64_t var1;	// u64
	RUST_BOOL var2;	// bool
	uint64_t var3;	// u64
	TUP_2_ZRTCg_ZRTCw var4;	// (u64, bool, )
	uint64_t var5;	// u64
	uint64_t var6;	// u64
	uint128_t var7;	// u128
	uint128_t var8;	// u128
	uint64_t var9;	// u64
	uint64_t var10;	// u64
	uint128_t var11;	// u128
	uint128_t var12;	// u128
	uint128_t var13;	// u128
	uint64_t var14;	// u64
	var5 = arg0.lo;	// _5 = Cast(a0 as u64)
	var6 = arg1.lo;	// _6 = Cast(a1 as u64)
	var4._1 = __builtin_add_overflow(var5, var6, &var4._0);
	// ^ Call( _4 = "add_with_overflow"::<u64,>( _5, _6, ), bb1, bb3)
	var2 = var4._1;	// _2 = Use(_4.1)
	var0 = var4._0;	// _0 = Use(_4.0)
	var7 = shr128(arg0, 64);	// _7 = BinOp(a0 BIT_SHR +64 i32)
	var9 = var7.lo;	// _9 = Cast(_7 as u64)
	var8 = shr128(arg1, 64);	// _8 = BinOp(a1 BIT_SHR +64 i32)
	var10 = var8.lo;	// _10 = Cast(_8 as u64)
	__builtin_add_overflow(var9, var10, &var1);
	// ^ Call( _1 = "overflowing_add"::<u64,>( _9, _10, ), bb2, bb3)
	if(var2) goto bb4; else goto bb5;
	// ^ If( _2 : 4, 5)
bb3: _Unwind_Resume(); // Diverge
bb4:
	var3 = 0x1ull;	// _3 = Constant(0x1 u64)
	goto bb6;
	// ^ Goto(6)
bb5:
	var3 = 0x0ull;	// _3 = Constant(0x0 u64)
	// ^ Goto(6)
bb6:
	__builtin_add_overflow(var1, var3, &var14);
	// ^ Call( _14 = "overflowing_add"::<u64,>( _1, _3, ), bb7, bb3)
	var11.lo = var0; var11.hi = var0 < 0 ? -1 : 0;	// _11 = Cast(_0 as u128)
	var13.lo = var14; var13.hi = var14 < 0 ? -1 : 0;	// _13 = Cast(_14 as u128)
	var12 = shl128(var13, 64);	// _12 = BinOp(_13 BIT_SHL +64 i32)
	rv = or128(var11, var12);	// retval = BinOp(_11 BIT_OR _12)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::UAddSub>::uadd_one
uint128_t  ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub7UAddSub0g8uadd_one0g(
		uint128_t arg0 // u128
		) // -> u128

{
	uint128_t rv;
	uint64_t var0;	// u64
	uint64_t var1;	// u64
	TUP_2_ZRTCg_ZRTCw var2;	// (u64, bool, )
	uint64_t var3;	// u64
	uint128_t var4;	// u128
	uint64_t var5;	// u64
	uint128_t var6;	// u128
	uint128_t var7;	// u128
	uint128_t var8;	// u128
	uint64_t var9;	// u64
	var3 = arg0.lo;	// _3 = Cast(a0 as u64)
	var2._1 = __builtin_add_overflow(var3, 0x1ull, &var2._0);
	// ^ Call( _2 = "add_with_overflow"::<u64,>( _3, 0x1 u64, ), bb1, bb2)
	var0 = var2._0;	// _0 = Use(_2.0)
	if(var2._1) goto bb3; else goto bb4;
	// ^ If( _2.1 : 3, 4)
bb2: _Unwind_Resume(); // Diverge
bb3:
	var1 = 0x1ull;	// _1 = Constant(0x1 u64)
	goto bb5;
	// ^ Goto(5)
bb4:
	var1 = 0x0ull;	// _1 = Constant(0x0 u64)
	// ^ Goto(5)
bb5:
	var4 = shr128(arg0, 64);	// _4 = BinOp(a0 BIT_SHR +64 i32)
	var5 = var4.lo;	// _5 = Cast(_4 as u64)
	__builtin_add_overflow(var5, var1, &var9);
	// ^ Call( _9 = "overflowing_add"::<u64,>( _5, _1, ), bb6, bb2)
	var6.lo = var0; var6.hi = var0 < 0 ? -1 : 0;	// _6 = Cast(_0 as u128)
	var8.lo = var9; var8.hi = var9 < 0 ? -1 : 0;	// _8 = Cast(_9 as u128)
	var7 = shl128(var8, 64);	// _7 = BinOp(_8 BIT_SHL +64 i32)
	rv = or128(var6, var7);	// retval = BinOp(_6 BIT_OR _7)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::UAddSub>::usub
uint128_t  ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub7UAddSub0g4usub0g(
		uint128_t arg0, // u128
		uint128_t arg1 // u128
		) // -> u128

{
	uint128_t rv;
	uint128_t var0;	// u128
	uint128_t var1;	// u128
	var1.lo = ~arg1.lo; var1.hi = ~arg1.hi;	// _1 = UniOp(a1 INV)
	var0 = ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub7UAddSub0g8uadd_one0g( var1 );
	// ^ Call( _0 = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::UAddSub>::uadd_one( _1, ), bb1, bb3)
	rv = ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub7UAddSub0g4uadd0g( arg0, var0 );
	// ^ Call( retval = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::UAddSub>::uadd( a0, _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::mul::UMulo>::mulo<'#omitted,>
uint128_t  ZRQCi3cR25compiler_builtins0_0_0_Hb3int3mul5UMulo0g4mulo0g(
		uint128_t arg0, // u128
		uint128_t arg1, // u128
		int32_t *arg2 // &'#omitted mut i32
		) // -> u128

{
	uint128_t rv;
	uint128_t var0;	// u128
	RUST_BOOL var1;	// bool
	uint128_t var2;	// u128
	uint128_t var3;	// u128
	uint128_t var4;	// u128
	uint128_t *var5;	// &'#omitted u128
	(*arg2) = 0;	// a2* = Constant(+0 i32)
	mul128_o(arg0, arg1, &var0);
	// ^ Call( _0 = "overflowing_mul"::<u128,>( a0, a1, ), bb1, bb3)
	var5 = & arg0;	// _5 = Borrow(Shared, a0)
	var4 = make128_raw(0ull, 0ull);	// _4 = Constant(0x0 u128)
	var3.lo = ~var4.lo; var3.hi = ~var4.hi;	// _3 = UniOp(_4 INV)
	var2 = ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g( var3, arg1 );
	// ^ Call( _2 = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div( _3, a1, ), bb2, bb3)
	var1 = 0 > cmp128(var2, (*var5));	// _1 = BinOp(_5* GT _2)
	if(var1) goto bb4; else goto bb5;
	// ^ If( _1 : 4, 5)
bb3: _Unwind_Resume(); // Diverge
bb4:
	(*arg2) = 1;	// a2* = Constant(+1 i32)
	// ^ Goto(5)
bb5:
	rv = var0;	// retval = Use(_0)
	// ^ drop(a2)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Ashl>::ashl
uint128_t  ZRQCi3cR25compiler_builtins0_0_0_Hb3int5shift4Ashl0g4ashl0g(
		uint128_t arg0, // u128
		uint32_t arg1 // u32
		) // -> u128

{
	uint128_t rv;
	uint32_t var0;	// u32
	RUST_BOOL var1;	// bool
	uint32_t var2;	// u32
	uint64_t var3;	// u64
	uint32_t var4;	// u32
	uint128_t var5;	// u128
	uint128_t var6;	// u128
	uint64_t var7;	// u64
	uint64_t var8;	// u64
	uint128_t var9;	// u128
	uint64_t var10;	// u64
	uint64_t var11;	// u64
	uint32_t var12;	// u32
	uint64_t var13;	// u64
	uint64_t var14;	// u64
	uint128_t var15;	// u128
	uint128_t var16;	// u128
	uint128_t var17;	// u128
	uint64_t var18;	// u64
	uint64_t var19;	// u64
	var0 = 0x40;	// _0 = Constant(0x40 u32)
	var2 = arg1 & 0x40;	// _2 = BinOp(a1 BIT_AND 0x40 u32)
	var1 = var2 != 0x0;	// _1 = BinOp(_2 NE 0x0 u32)
	if(var1) goto bb1; else goto bb2;
	// ^ If( _1 : 1, 2)
bb1:
	var3 = arg0.lo;	// _3 = Cast(a0 as u64)
	var4 = arg1 - var0;	// _4 = BinOp(a1 SUB _0)
	var7 = var3 << var4;	// _7 = BinOp(_3 BIT_SHL _4)
	var6.lo = var7; var6.hi = var7 < 0 ? -1 : 0;	// _6 = Cast(_7 as u128)
	var5 = shl128(var6, 64);	// _5 = BinOp(_6 BIT_SHL +64 i32)
	rv = or128(make128_raw(0ull, 0ull), var5);	// retval = BinOp(0x0 u128 BIT_OR _5)
	return rv;
	// ^ Return
bb2:
	var1 = arg1 == 0x0;	// _1 = BinOp(a1 EQ 0x0 u32)
	if(var1) goto bb3; else goto bb4;
	// ^ If( _1 : 3, 4)
bb3:
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
bb4:
	var8 = arg0.lo;	// _8 = Cast(a0 as u64)
	var18 = var8 << arg1;	// _18 = BinOp(_8 BIT_SHL a1)
	var9 = shr128(arg0, 64);	// _9 = BinOp(a0 BIT_SHR +64 i32)
	var10 = var9.lo;	// _10 = Cast(_9 as u64)
	var13 = var10 << arg1;	// _13 = BinOp(_10 BIT_SHL a1)
	var11 = arg0.lo;	// _11 = Cast(a0 as u64)
	var12 = var0 - arg1;	// _12 = BinOp(_0 SUB a1)
	var14 = var11 >> var12;	// _14 = BinOp(_11 BIT_SHR _12)
	var19 = var13 | var14;	// _19 = BinOp(_13 BIT_OR _14)
	var15.lo = var18; var15.hi = var18 < 0 ? -1 : 0;	// _15 = Cast(_18 as u128)
	var17.lo = var19; var17.hi = var19 < 0 ? -1 : 0;	// _17 = Cast(_19 as u128)
	var16 = shl128(var17, 64);	// _16 = BinOp(_17 BIT_SHL +64 i32)
	rv = or128(var15, var16);	// retval = BinOp(_15 BIT_OR _16)
	return rv;
	// ^ Return
}
// <u128 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Lshr>::lshr
uint128_t  ZRQCi3cR25compiler_builtins0_0_0_Hb3int5shift4Lshr0g4lshr0g(
		uint128_t arg0, // u128
		uint32_t arg1 // u32
		) // -> u128

{
	uint128_t rv;
	uint32_t var0;	// u32
	RUST_BOOL var1;	// bool
	uint32_t var2;	// u32
	uint128_t var3;	// u128
	uint64_t var4;	// u64
	uint32_t var5;	// u32
	uint128_t var6;	// u128
	uint64_t var7;	// u64
	uint128_t var8;	// u128
	uint64_t var9;	// u64
	uint32_t var10;	// u32
	uint64_t var11;	// u64
	uint64_t var12;	// u64
	uint64_t var13;	// u64
	uint128_t var14;	// u128
	uint64_t var15;	// u64
	uint128_t var16;	// u128
	uint128_t var17;	// u128
	uint128_t var18;	// u128
	uint64_t var19;	// u64
	uint64_t var20;	// u64
	var0 = 0x40;	// _0 = Constant(0x40 u32)
	var2 = arg1 & 0x40;	// _2 = BinOp(a1 BIT_AND 0x40 u32)
	var1 = var2 != 0x0;	// _1 = BinOp(_2 NE 0x0 u32)
	if(var1) goto bb1; else goto bb2;
	// ^ If( _1 : 1, 2)
bb1:
	var3 = shr128(arg0, 64);	// _3 = BinOp(a0 BIT_SHR +64 i32)
	var4 = var3.lo;	// _4 = Cast(_3 as u64)
	var5 = arg1 - var0;	// _5 = BinOp(a1 SUB _0)
	var7 = var4 >> var5;	// _7 = BinOp(_4 BIT_SHR _5)
	var6.lo = var7; var6.hi = var7 < 0 ? -1 : 0;	// _6 = Cast(_7 as u128)
	rv = or128(var6, make128_raw(0ull, 0ull));	// retval = BinOp(_6 BIT_OR 0x0 u128)
	return rv;
	// ^ Return
bb2:
	var1 = arg1 == 0x0;	// _1 = BinOp(a1 EQ 0x0 u32)
	if(var1) goto bb3; else goto bb4;
	// ^ If( _1 : 3, 4)
bb3:
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
bb4:
	var8 = shr128(arg0, 64);	// _8 = BinOp(a0 BIT_SHR +64 i32)
	var9 = var8.lo;	// _9 = Cast(_8 as u64)
	var10 = var0 - arg1;	// _10 = BinOp(_0 SUB a1)
	var12 = var9 << var10;	// _12 = BinOp(_9 BIT_SHL _10)
	var11 = arg0.lo;	// _11 = Cast(a0 as u64)
	var13 = var11 >> arg1;	// _13 = BinOp(_11 BIT_SHR a1)
	var19 = var12 | var13;	// _19 = BinOp(_12 BIT_OR _13)
	var14 = shr128(arg0, 64);	// _14 = BinOp(a0 BIT_SHR +64 i32)
	var15 = var14.lo;	// _15 = Cast(_14 as u64)
	var20 = var15 >> arg1;	// _20 = BinOp(_15 BIT_SHR a1)
	var16.lo = var19; var16.hi = var19 < 0 ? -1 : 0;	// _16 = Cast(_19 as u128)
	var18.lo = var20; var18.hi = var20 < 0 ? -1 : 0;	// _18 = Cast(_20 as u128)
	var17 = shl128(var18, 64);	// _17 = BinOp(_18 BIT_SHL +64 i32)
	rv = or128(var16, var17);	// retval = BinOp(_16 BIT_OR _17)
	return rv;
	// ^ Return
}
// <u128 as ::"core-0_0_0"::cmp::PartialOrd<u128,>>::ge<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCi2cE9core0_0_03cmp10PartialOrd1gCi2ge0g(
		uint128_t *arg0, // &'#omitted u128
		uint128_t *arg1 // &'#omitted u128
		) // -> bool

{
	RUST_BOOL rv;
	rv = 0 >= cmp128((*arg1), (*arg0));	// retval = BinOp(a0* GE a1*)
	return rv;
	// ^ Return
}
// <u128 as ::"core-0_0_0"::cmp::PartialOrd<u128,>>::gt<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCi2cE9core0_0_03cmp10PartialOrd1gCi2gt0g(
		uint128_t *arg0, // &'#omitted u128
		uint128_t *arg1 // &'#omitted u128
		) // -> bool

{
	RUST_BOOL rv;
	rv = 0 > cmp128((*arg1), (*arg0));	// retval = BinOp(a0* GT a1*)
	return rv;
	// ^ Return
}
// <u128 as ::"core-0_0_0"::cmp::PartialOrd<u128,>>::le<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCi2cE9core0_0_03cmp10PartialOrd1gCi2le0g(
		uint128_t *arg0, // &'#omitted u128
		uint128_t *arg1 // &'#omitted u128
		) // -> bool

{
	RUST_BOOL rv;
	rv = 0 <= cmp128((*arg1), (*arg0));	// retval = BinOp(a0* LE a1*)
	return rv;
	// ^ Return
}
// <u128 as ::"core-0_0_0"::cmp::PartialOrd<u128,>>::lt<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCi2cE9core0_0_03cmp10PartialOrd1gCi2lt0g(
		uint128_t *arg0, // &'#omitted u128
		uint128_t *arg1 // &'#omitted u128
		) // -> bool

{
	RUST_BOOL rv;
	rv = 0 < cmp128((*arg1), (*arg0));	// retval = BinOp(a0* LT a1*)
	return rv;
	// ^ Return
}
// <u128 as ::"core-0_0_0"::ops::bit::Not>::not
static uint128_t  ZRQCi3cE9core0_0_03ops3bit3Not0g3not0g(
		uint128_t arg0 // u128
		) // -> u128

{
	uint128_t rv;
	rv.lo = ~arg0.lo; rv.hi = ~arg0.hi;	// retval = UniOp(a0 INV)
	return rv;
	// ^ Return
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<usize,>>::cast
uintptr_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCu4cast0g(
		int128_t arg0 // i128
		) // -> usize

{
	uintptr_t rv;
	rv = arg0.lo;	// retval = Cast(a0 as usize)
	return rv;
	// ^ Return
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<isize,>>::cast
intptr_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCv4cast0g(
		int128_t arg0 // i128
		) // -> isize

{
	intptr_t rv;
	rv = arg0.lo;	// retval = Cast(a0 as isize)
	return rv;
	// ^ Return
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u32,>>::cast
uint32_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCe4cast0g(
		int128_t arg0 // i128
		) // -> u32

{
	uint32_t rv;
	rv = arg0.lo;	// retval = Cast(a0 as u32)
	return rv;
	// ^ Return
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i32,>>::cast
int32_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCf4cast0g(
		int128_t arg0 // i128
		) // -> i32

{
	int32_t rv;
	rv = arg0.lo;	// retval = Cast(a0 as i32)
	return rv;
	// ^ Return
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u64,>>::cast
uint64_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCg4cast0g(
		int128_t arg0 // i128
		) // -> u64

{
	uint64_t rv;
	rv = arg0.lo;	// retval = Cast(a0 as u64)
	return rv;
	// ^ Return
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i64,>>::cast
int64_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCh4cast0g(
		int128_t arg0 // i128
		) // -> i64

{
	int64_t rv;
	rv = arg0.lo;	// retval = Cast(a0 as i64)
	return rv;
	// ^ Return
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<u128,>>::cast
uint128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCi4cast0g(
		int128_t arg0 // i128
		) // -> u128

{
	uint128_t rv;
	rv.lo = arg0.lo; rv.hi = arg0.hi;	// retval = Cast(a0 as u128)
	return rv;
	// ^ Return
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::CastInto<i128,>>::cast
int128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8CastInto1gCj4cast0g(
		int128_t arg0 // i128
		) // -> i128

{
	int128_t rv;
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div
int128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128

{
	int128_t rv;
	struct e_ZRG2cE9core0_0_06option6Option1gCj var0;	// ::"core-0_0_0"::option::Option<i128,>/*E*/
	var0 = ZRICj11checked_div0g( arg0, arg1 );
	// ^ Call( _0 = <i128 /*- */>::checked_div( a0, a1, ), bb1, bb3)
	rv = ZRG2cR25compiler_builtins0_0_0_Hb3int6unwrap1gCj( var0 );
	// ^ Call( retval = ::"compiler_builtins-0_0_0_Hb"::int::unwrap<i128,>( _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_rem
int128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_rem0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128

{
	int128_t rv;
	struct e_ZRG2cE9core0_0_06option6Option1gCj var0;	// ::"core-0_0_0"::option::Option<i128,>/*E*/
	var0 = ZRICj11checked_rem0g( arg0, arg1 );
	// ^ Call( _0 = <i128 /*- */>::checked_rem( a0, a1, ), bb1, bb3)
	rv = ZRG2cR25compiler_builtins0_0_0_Hb3int6unwrap1gCj( var0 );
	// ^ Call( retval = ::"compiler_builtins-0_0_0_Hb"::int::unwrap<i128,>( _0, ), bb2, bb3)
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::extract_sign
TUP_2_ZRTCw_ZRTCi  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g12extract_sign0g(
		int128_t arg0 // i128
		) // -> (bool, u128, )

{
	TUP_2_ZRTCw_ZRTCi rv;
	RUST_BOOL var0;	// bool
	uint128_t var1;	// u128
	uint128_t var2;	// u128
	uint128_t var3;	// u128
	uint128_t var4;	// u128
	var0 = 0 < cmp128s(make128s_raw(0ull, 0ull), arg0);	// _0 = BinOp(a0 LT +0 i128)
	if(var0) goto bb1; else goto bb3;
	// ^ If( _0 : 1, 3)
bb1:
	var1.lo = arg0.lo; var1.hi = arg0.hi;	// _1 = Cast(a0 as u128)
	var4.lo = ~var1.lo; var4.hi = ~var1.hi;	// _4 = UniOp(_1 INV)
	add128_o(var4, make128_raw(0ull, 1ull), &var3);
	// ^ Call( _3 = "overflowing_add"::<u128,>( _4, 0x1 u128, ), bb2, bb4)
	;
	rv._0 = true;
	rv._1 = var3;	// retval = Tuple(true, _3)
	return rv;
	// ^ Return
bb3:
	var2.lo = arg0.lo; var2.hi = arg0.hi;	// _2 = Cast(a0 as u128)
	;
	rv._0 = false;
	rv._1 = var2;	// retval = Tuple(false, _2)
	return rv;
	// ^ Return
bb4: _Unwind_Resume(); // Diverge
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::from_bool
int128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g9from_bool0g(
		RUST_BOOL arg0 // bool
		) // -> i128

{
	int128_t rv;
	rv.lo = arg0; rv.hi = arg0 < 0 ? -1 : 0;	// retval = Cast(a0 as i128)
	return rv;
	// ^ Return
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::from_unsigned
int128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g13from_unsigned0g(
		uint128_t arg0 // u128
		) // -> i128

{
	int128_t rv;
	rv.lo = arg0.lo; rv.hi = arg0.hi;	// retval = Cast(a0 as i128)
	return rv;
	// ^ Return
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::leading_zeros
uint32_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g13leading_zeros0g(
		int128_t arg0 // i128
		) // -> u32

{
	uint32_t rv;
	uint128_t var0;	// u128
	uint128_t var1;	// u128
	var1.lo = arg0.lo; var1.hi = arg0.hi;	// _1 = Cast(a0 as u128)
	var0 = (intrinsic_ctlz_u128(var1));	// ^ Call( _0 = "ctlz"::<u128,>( _1, ), bb1, bb2)
	rv = var0.lo;	// retval = Cast(_0 as u32)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::max_value
int128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g9max_value0g(void) // -> i128

{
	int128_t rv;
	rv = make128s_raw(9223372036854775807ull, 18446744073709551615ull);	// retval = Constant(+170141183460469231731687303715884105727 i128)
	return rv;
	// ^ Return
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::min_value
int128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g9min_value0g(void) // -> i128

{
	int128_t rv;
	rv = make128s_raw(9223372036854775808ull, 0ull);	// retval = Constant(--170141183460469231731687303715884105728 i128)
	return rv;
	// ^ Return
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::overflowing_add
TUP_2_ZRTCj_ZRTCw  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g15overflowing_add0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> (i128, bool, )

{
	TUP_2_ZRTCj_ZRTCw rv;
	TUP_2_ZRTCj_ZRTCw var0;	// (i128, bool, )
	var0._1 = add128s_o(arg0, arg1, &var0._0);
	// ^ Call( _0 = "add_with_overflow"::<i128,>( a0, a1, ), bb1, bb2)
	;
	rv._0 = var0._0;
	rv._1 = var0._1;	// retval = Tuple(_0.0, _0.1)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::unsigned
uint128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g8unsigned0g(
		int128_t arg0 // i128
		) // -> u128

{
	uint128_t rv;
	rv.lo = arg0.lo; rv.hi = arg0.hi;	// retval = Cast(a0 as u128)
	return rv;
	// ^ Return
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_add
int128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_add0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128

{
	int128_t rv;
	add128s_o(arg0, arg1, &rv);
	// ^ Call( retval = "overflowing_add"::<i128,>( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_mul
int128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_mul0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128

{
	int128_t rv;
	mul128s_o(arg0, arg1, &rv);
	// ^ Call( retval = "overflowing_mul"::<i128,>( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_shl
int128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_shl0g(
		int128_t arg0, // i128
		uint32_t arg1 // u32
		) // -> i128

{
	int128_t rv;
	uint32_t var0;	// u32
	int128_t var1;	// i128
	var0 = arg1 & 0x7f;	// _0 = BinOp(a1 BIT_AND 0x7f u32)
	var1.lo = var0; var1.hi = var0 < 0 ? -1 : 0;	// _1 = Cast(_0 as i128)
	rv = shl128s(arg0, var1.lo);
	// ^ Call( retval = "unchecked_shl"::<i128,>( a0, _1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::wrapping_sub
int128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g12wrapping_sub0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128

{
	int128_t rv;
	sub128s_o(arg0, arg1, &rv);
	// ^ Call( retval = "overflowing_sub"::<i128,>( a0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::from_parts
int128_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g10from_parts0g(
		uint64_t arg0, // u64
		int64_t arg1 // i64
		) // -> i128

{
	int128_t rv;
	int128_t var0;	// i128
	int128_t var1;	// i128
	int128_t var2;	// i128
	var0.lo = arg0; var0.hi = arg0 < 0 ? -1 : 0;	// _0 = Cast(a0 as i128)
	var2.lo = arg1; var2.hi = arg1 < 0 ? -1 : 0;	// _2 = Cast(a1 as i128)
	var1 = shl128s(var2, 64);	// _1 = BinOp(_2 BIT_SHL +64 i32)
	rv = or128s(var0, var1);	// retval = BinOp(_0 BIT_OR _1)
	return rv;
	// ^ Return
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::high
int64_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g4high0g(
		int128_t arg0 // i128
		) // -> i64

{
	int64_t rv;
	int128_t var0;	// i128
	var0 = shr128s(arg0, 64);	// _0 = BinOp(a0 BIT_SHR +64 i32)
	rv = var0.lo;	// retval = Cast(_0 as i64)
	return rv;
	// ^ Return
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::high_as_low
uint64_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g11high_as_low0g(
		int64_t arg0 // i64
		) // -> u64

{
	uint64_t rv;
	rv = (uint64_t )arg0;	// retval = Cast(a0 as u64)
	return rv;
	// ^ Return
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::low
uint64_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g3low0g(
		int128_t arg0 // i128
		) // -> u64

{
	uint64_t rv;
	rv = arg0.lo;	// retval = Cast(a0 as u64)
	return rv;
	// ^ Return
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::LargeInt>::low_as_high
int64_t  ZRQCj2cR25compiler_builtins0_0_0_Hb3int8LargeInt0g11low_as_high0g(
		uint64_t arg0 // u64
		) // -> i64

{
	int64_t rv;
	rv = (int64_t )arg0;	// retval = Cast(a0 as i64)
	return rv;
	// ^ Return
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::AddSub>::add
int128_t  ZRQCj3cR25compiler_builtins0_0_0_Hb3int6addsub6AddSub0g3add0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128

{
	int128_t rv;
	uint128_t var0;	// u128
	uint128_t var1;	// u128
	uint128_t var2;	// u128
	var0.lo = arg0.lo; var0.hi = arg0.hi;	// _0 = Cast(a0 as u128)
	var1.lo = arg1.lo; var1.hi = arg1.hi;	// _1 = Cast(a1 as u128)
	var2 = ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub7UAddSub0g4uadd0g( var0, var1 );
	// ^ Call( _2 = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::UAddSub>::uadd( _0, _1, ), bb1, bb2)
	rv.lo = var2.lo; rv.hi = var2.hi;	// retval = Cast(_2 as i128)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::AddSub>::sub
int128_t  ZRQCj3cR25compiler_builtins0_0_0_Hb3int6addsub6AddSub0g3sub0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128

{
	int128_t rv;
	uint128_t var0;	// u128
	uint128_t var1;	// u128
	uint128_t var2;	// u128
	var0.lo = arg0.lo; var0.hi = arg0.hi;	// _0 = Cast(a0 as u128)
	var1.lo = arg1.lo; var1.hi = arg1.hi;	// _1 = Cast(a1 as u128)
	var2 = ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub7UAddSub0g4usub0g( var0, var1 );
	// ^ Call( _2 = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::UAddSub>::usub( _0, _1, ), bb1, bb2)
	rv.lo = var2.lo; rv.hi = var2.hi;	// retval = Cast(_2 as i128)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::Addo>::addo<'#omitted,>
int128_t  ZRQCj3cR25compiler_builtins0_0_0_Hb3int6addsub4Addo0g4addo0g(
		int128_t arg0, // i128
		int128_t arg1, // i128
		int32_t *arg2 // &'#omitted mut i32
		) // -> i128

{
	int128_t rv;
	int128_t var0;	// i128
	RUST_BOOL var1;	// bool
	uint128_t var2;	// u128
	uint128_t var3;	// u128
	uint128_t var4;	// u128
	(*arg2) = 0;	// a2* = Constant(+0 i32)
	var2.lo = arg0.lo; var2.hi = arg0.hi;	// _2 = Cast(a0 as u128)
	var3.lo = arg1.lo; var3.hi = arg1.hi;	// _3 = Cast(a1 as u128)
	var4 = ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub7UAddSub0g4uadd0g( var2, var3 );
	// ^ Call( _4 = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::UAddSub>::uadd( _2, _3, ), bb1, bb2)
	var0.lo = var4.lo; var0.hi = var4.hi;	// _0 = Cast(_4 as i128)
	var1 = 0 >= cmp128s(make128s_raw(0ull, 0ull), arg1);	// _1 = BinOp(a1 GE +0 i128)
	if(var1) goto bb3; else goto bb4;
	// ^ If( _1 : 3, 4)
bb2: _Unwind_Resume(); // Diverge
bb3:
	var1 = 0 < cmp128s(arg0, var0);	// _1 = BinOp(_0 LT a0)
	goto bb5;
	// ^ Goto(5)
bb4:
	var1 = 0 >= cmp128s(arg0, var0);	// _1 = BinOp(_0 GE a0)
	// ^ Goto(5)
bb5:
	if(var1) goto bb6; else goto bb7;
	// ^ If( _1 : 6, 7)
bb6:
	(*arg2) = 1;	// a2* = Constant(+1 i32)
	// ^ Goto(7)
bb7:
	rv = var0;	// retval = Use(_0)
	// ^ drop(a2)
	return rv;
	// ^ Return
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::Subo>::subo<'#omitted,>
int128_t  ZRQCj3cR25compiler_builtins0_0_0_Hb3int6addsub4Subo0g4subo0g(
		int128_t arg0, // i128
		int128_t arg1, // i128
		int32_t *arg2 // &'#omitted mut i32
		) // -> i128

{
	int128_t rv;
	int128_t var0;	// i128
	RUST_BOOL var1;	// bool
	uint128_t var2;	// u128
	uint128_t var3;	// u128
	uint128_t var4;	// u128
	(*arg2) = 0;	// a2* = Constant(+0 i32)
	var2.lo = arg0.lo; var2.hi = arg0.hi;	// _2 = Cast(a0 as u128)
	var3.lo = arg1.lo; var3.hi = arg1.hi;	// _3 = Cast(a1 as u128)
	var4 = ZRQCi3cR25compiler_builtins0_0_0_Hb3int6addsub7UAddSub0g4usub0g( var2, var3 );
	// ^ Call( _4 = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::addsub::UAddSub>::usub( _2, _3, ), bb1, bb2)
	var0.lo = var4.lo; var0.hi = var4.hi;	// _0 = Cast(_4 as i128)
	var1 = 0 >= cmp128s(make128s_raw(0ull, 0ull), arg1);	// _1 = BinOp(a1 GE +0 i128)
	if(var1) goto bb3; else goto bb4;
	// ^ If( _1 : 3, 4)
bb2: _Unwind_Resume(); // Diverge
bb3:
	var1 = 0 > cmp128s(arg0, var0);	// _1 = BinOp(_0 GT a0)
	goto bb5;
	// ^ Goto(5)
bb4:
	var1 = 0 <= cmp128s(arg0, var0);	// _1 = BinOp(_0 LE a0)
	// ^ Goto(5)
bb5:
	if(var1) goto bb6; else goto bb7;
	// ^ If( _1 : 6, 7)
bb6:
	(*arg2) = 1;	// a2* = Constant(+1 i32)
	// ^ Goto(7)
bb7:
	rv = var0;	// retval = Use(_0)
	// ^ drop(a2)
	return rv;
	// ^ Return
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::mul::Mul>::mul
int128_t  ZRQCj3cR25compiler_builtins0_0_0_Hb3int3mul3Mul0g_C0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128

{
	int128_t rv;
	uint32_t var0;	// u32
	uint64_t var1;	// u64
	uint64_t var2;	// u64
	uint64_t var3;	// u64
	int64_t var4;	// i64
	uint64_t *var5;	// &'#omitted mut u64
	uint64_t *var6;	// &'#omitted mut u64
	uint64_t *var7;	// &'#omitted mut u64
	uint64_t *var8;	// &'#omitted mut u64
	uint64_t *var9;	// &'#omitted mut u64
	uint64_t *var10;	// &'#omitted mut u64
	int64_t *var11;	// &'#omitted mut i64
	int64_t *var12;	// &'#omitted mut i64
	uint64_t var13;	// u64
	uint64_t var14;	// u64
	uint64_t var15;	// u64
	uint64_t var16;	// u64
	uint64_t var17;	// u64
	uint64_t var18;	// u64
	uint64_t var19;	// u64
	uint64_t var20;	// u64
	uint64_t var21;	// u64
	uint64_t var22;	// u64
	uint64_t var23;	// u64
	uint64_t var24;	// u64
	uint64_t var25;	// u64
	uint64_t var26;	// u64
	uint64_t var27;	// u64
	uint64_t var28;	// u64
	uint64_t var29;	// u64
	uint64_t var30;	// u64
	uint64_t var31;	// u64
	uint64_t var32;	// u64
	int64_t var33;	// i64
	uint64_t var34;	// u64
	uint64_t var35;	// u64
	uint64_t var36;	// u64
	uint64_t var37;	// u64
	uint64_t var38;	// u64
	int64_t var39;	// i64
	int128_t var40;	// i128
	uint64_t var41;	// u64
	int64_t var42;	// i64
	int64_t var43;	// i64
	int64_t var44;	// i64
	uint64_t var45;	// u64
	int128_t var46;	// i128
	int64_t var47;	// i64
	int64_t var48;	// i64
	int64_t var49;	// i64
	int64_t var50;	// i64
	int128_t var51;	// i128
	int128_t var52;	// i128
	int128_t var53;	// i128
	var0 = 0x20;	// _0 = Constant(0x20 u32)
	var1 = 0xffffffffull;	// _1 = Constant(0xffffffff u64)
	var13 = arg0.lo;	// _13 = Cast(a0 as u64)
	var15 = var13 & 0xffffffffull;	// _15 = BinOp(_13 BIT_AND 0xffffffff u64)
	var14 = arg1.lo;	// _14 = Cast(a1 as u64)
	var16 = var14 & 0xffffffffull;	// _16 = BinOp(_14 BIT_AND 0xffffffff u64)
	__builtin_mul_overflow(var15, var16, &var2);
	// ^ Call( _2 = "overflowing_mul"::<u64,>( _15, _16, ), bb1, bb9)
	var3 = var2 >> var0;	// _3 = BinOp(_2 BIT_SHR _0)
	var5 = & var2;	// _5 = Borrow(Unique, _2)
	(*var5) = (*var5) & var1;	// _5* = BinOp(_5* BIT_AND _1)
	// ^ drop(_5)
	var6 = & var3;	// _6 = Borrow(Unique, _3)
	var17 = arg0.lo;	// _17 = Cast(a0 as u64)
	var19 = var17 >> var0;	// _19 = BinOp(_17 BIT_SHR _0)
	var18 = arg1.lo;	// _18 = Cast(a1 as u64)
	var20 = var18 & var1;	// _20 = BinOp(_18 BIT_AND _1)
	__builtin_mul_overflow(var19, var20, &var21);
	// ^ Call( _21 = "overflowing_mul"::<u64,>( _19, _20, ), bb2, bb9)
	(*var6) = (*var6) + var21;	// _6* = BinOp(_6* ADD _21)
	// ^ drop(_6)
	var7 = & var2;	// _7 = Borrow(Unique, _2)
	var22 = var3 & var1;	// _22 = BinOp(_3 BIT_AND _1)
	var23 = var22 << var0;	// _23 = BinOp(_22 BIT_SHL _0)
	(*var7) = (*var7) + var23;	// _7* = BinOp(_7* ADD _23)
	// ^ drop(_7)
	var24 = var3 >> var0;	// _24 = BinOp(_3 BIT_SHR _0)
	var4 = (int64_t )var24;	// _4 = Cast(_24 as i64)
	var3 = var2 >> var0;	// _3 = BinOp(_2 BIT_SHR _0)
	var8 = & var2;	// _8 = Borrow(Unique, _2)
	(*var8) = (*var8) & var1;	// _8* = BinOp(_8* BIT_AND _1)
	// ^ drop(_8)
	var9 = & var3;	// _9 = Borrow(Unique, _3)
	var25 = arg1.lo;	// _25 = Cast(a1 as u64)
	var27 = var25 >> var0;	// _27 = BinOp(_25 BIT_SHR _0)
	var26 = arg0.lo;	// _26 = Cast(a0 as u64)
	var28 = var26 & var1;	// _28 = BinOp(_26 BIT_AND _1)
	__builtin_mul_overflow(var27, var28, &var29);
	// ^ Call( _29 = "overflowing_mul"::<u64,>( _27, _28, ), bb3, bb9)
	(*var9) = (*var9) + var29;	// _9* = BinOp(_9* ADD _29)
	// ^ drop(_9)
	var10 = & var2;	// _10 = Borrow(Unique, _2)
	var30 = var3 & var1;	// _30 = BinOp(_3 BIT_AND _1)
	var31 = var30 << var0;	// _31 = BinOp(_30 BIT_SHL _0)
	(*var10) = (*var10) + var31;	// _10* = BinOp(_10* ADD _31)
	// ^ drop(_10)
	var11 = & var4;	// _11 = Borrow(Unique, _4)
	var32 = var3 >> var0;	// _32 = BinOp(_3 BIT_SHR _0)
	var33 = (int64_t )var32;	// _33 = Cast(_32 as i64)
	(*var11) = (*var11) + var33;	// _11* = BinOp(_11* ADD _33)
	// ^ drop(_11)
	var12 = & var4;	// _12 = Borrow(Unique, _4)
	var34 = arg0.lo;	// _34 = Cast(a0 as u64)
	var36 = var34 >> var0;	// _36 = BinOp(_34 BIT_SHR _0)
	var35 = arg1.lo;	// _35 = Cast(a1 as u64)
	var37 = var35 >> var0;	// _37 = BinOp(_35 BIT_SHR _0)
	__builtin_mul_overflow(var36, var37, &var38);
	// ^ Call( _38 = "overflowing_mul"::<u64,>( _36, _37, ), bb4, bb9)
	var39 = (int64_t )var38;	// _39 = Cast(_38 as i64)
	(*var12) = (*var12) + var39;	// _12* = BinOp(_12* ADD _39)
	// ^ drop(_12)
	var40 = shr128s(arg0, 64);	// _40 = BinOp(a0 BIT_SHR +64 i32)
	var42 = var40.lo;	// _42 = Cast(_40 as i64)
	var41 = arg1.lo;	// _41 = Cast(a1 as u64)
	var43 = (int64_t )var41;	// _43 = Cast(_41 as i64)
	__builtin_mul_overflow(var42, var43, &var44);
	// ^ Call( _44 = "overflowing_mul"::<i64,>( _42, _43, ), bb5, bb9)
	__builtin_add_overflow(var4, var44, &var49);
	// ^ Call( _49 = "overflowing_add"::<i64,>( _4, _44, ), bb6, bb9)
	var45 = arg0.lo;	// _45 = Cast(a0 as u64)
	var47 = (int64_t )var45;	// _47 = Cast(_45 as i64)
	var46 = shr128s(arg1, 64);	// _46 = BinOp(a1 BIT_SHR +64 i32)
	var48 = var46.lo;	// _48 = Cast(_46 as i64)
	__builtin_mul_overflow(var47, var48, &var50);
	// ^ Call( _50 = "overflowing_mul"::<i64,>( _47, _48, ), bb7, bb9)
	__builtin_add_overflow(var49, var50, &var4);
	// ^ Call( _4 = "overflowing_add"::<i64,>( _49, _50, ), bb8, bb9)
	var51.lo = var2; var51.hi = var2 < 0 ? -1 : 0;	// _51 = Cast(_2 as i128)
	var53.lo = var4; var53.hi = var4 < 0 ? -1 : 0;	// _53 = Cast(_4 as i128)
	var52 = shl128s(var53, 64);	// _52 = BinOp(_53 BIT_SHL +64 i32)
	rv = or128s(var51, var52);	// retval = BinOp(_51 BIT_OR _52)
	return rv;
	// ^ Return
bb9: _Unwind_Resume(); // Diverge
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::mul::Mulo>::mulo<'#omitted,>
int128_t  ZRQCj3cR25compiler_builtins0_0_0_Hb3int3mul4Mulo0g4mulo0g(
		int128_t arg0, // i128
		int128_t arg1, // i128
		int32_t *arg2 // &'#omitted mut i32
		) // -> i128

{
	int128_t rv;
	int128_t var0;	// i128
	int128_t var1;	// i128
	int128_t var2;	// i128
	int128_t var3;	// i128
	int128_t var4;	// i128
	int128_t var5;	// i128
	RUST_BOOL var6;	// bool
	int128_t var7;	// i128
	int128_t var8;	// i128
	int128_t var9;	// i128
	int128_t var10;	// i128
	int128_t *var11;	// &'#omitted i128
	int128_t var12;	// i128
	int128_t *var13;	// &'#omitted i128
	(*arg2) = 0;	// a2* = Constant(+0 i32)
	mul128s_o(arg0, arg1, &var0);
	// ^ Call( _0 = "overflowing_mul"::<i128,>( a0, a1, ), bb1, bb2)
	var6 = 0 == cmp128s(make128s_raw(9223372036854775808ull, 0ull), arg0);	// _6 = BinOp(a0 EQ --170141183460469231731687303715884105728 i128)
	if(var6) goto bb3; else goto bb4;
	// ^ If( _6 : 3, 4)
bb2: _Unwind_Resume(); // Diverge
bb3:
	var6 = 0 != cmp128s(make128s_raw(0ull, 0ull), arg1);	// _6 = BinOp(a1 NE +0 i128)
	if(var6) goto bb17; else goto bb15;
	// ^ If( _6 : 17, 15)
bb4:
	var6 = 0 == cmp128s(make128s_raw(9223372036854775808ull, 0ull), arg1);	// _6 = BinOp(a1 EQ --170141183460469231731687303715884105728 i128)
	if(var6) goto bb5; else goto bb6;
	// ^ If( _6 : 5, 6)
bb5:
	var6 = 0 != cmp128s(make128s_raw(0ull, 0ull), arg0);	// _6 = BinOp(a0 NE +0 i128)
	if(var6) goto bb16; else goto bb15;
	// ^ If( _6 : 16, 15)
bb6:
	var1 = shr128s(arg0, 0x7f);	// _1 = BinOp(a0 BIT_SHR 0x7f u32)
	var9 = xor128s(arg0, var1);	// _9 = BinOp(a0 BIT_XOR _1)
	var2 = sub128s(var9, var1);	// _2 = BinOp(_9 SUB _1)
	var3 = shr128s(arg1, 0x7f);	// _3 = BinOp(a1 BIT_SHR 0x7f u32)
	var10 = xor128s(arg1, var3);	// _10 = BinOp(a1 BIT_XOR _3)
	var4 = sub128s(var10, var3);	// _4 = BinOp(_10 SUB _3)
	var5 = make128s_raw(0ull, 2ull);	// _5 = Constant(+2 i128)
	var6 = 0 < cmp128s(make128s_raw(0ull, 2ull), var2);	// _6 = BinOp(_2 LT +2 i128)
	if(var6) goto bb15; else goto bb7;
	// ^ If( _6 : 15, 7)
bb7:
	var6 = 0 < cmp128s(var5, var4);	// _6 = BinOp(_4 LT _5)
	if(var6) goto bb15; else goto bb8;
	// ^ If( _6 : 15, 8)
bb8:
	var6 = 0 == cmp128s(var3, var1);	// _6 = BinOp(_1 EQ _3)
	if(var6) goto bb9; else goto bb11;
	// ^ If( _6 : 9, 11)
bb9:
	var11 = & var2;	// _11 = Borrow(Shared, _2)
	var7 = ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g( make128s_raw(9223372036854775807ull, 18446744073709551615ull), var4 );
	// ^ Call( _7 = <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div( +170141183460469231731687303715884105727 i128, _4, ), bb10, bb2)
	var6 = 0 > cmp128s(var7, (*var11));	// _6 = BinOp(_11* GT _7)
	goto bb13;
	// ^ Goto(13)
bb11:
	var13 = & var2;	// _13 = Borrow(Shared, _2)
	var12 = neg128s(var4);	// _12 = UniOp(_4 NEG)
	var8 = ZRQCj2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g( make128s_raw(9223372036854775808ull, 0ull), var12 );
	// ^ Call( _8 = <i128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div( --170141183460469231731687303715884105728 i128, _12, ), bb12, bb2)
	var6 = 0 > cmp128s(var8, (*var13));	// _6 = BinOp(_13* GT _8)
	// ^ Goto(13)
bb13:
	if(var6) goto bb14; else goto bb15;
	// ^ If( _6 : 14, 15)
bb14:
	(*arg2) = 1;	// a2* = Constant(+1 i32)
	// ^ Goto(15)
bb15:
	rv = var0;	// retval = Use(_0)
	// ^ drop(a2)
	return rv;
	// ^ Return
bb16:
	var6 = 0 != cmp128s(make128s_raw(0ull, 1ull), arg0);	// _6 = BinOp(a0 NE +1 i128)
	goto bb13;
	// ^ Goto(13)
bb17:
	var6 = 0 != cmp128s(make128s_raw(0ull, 1ull), arg1);	// _6 = BinOp(a1 NE +1 i128)
	goto bb13;
	// ^ Goto(13)
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Div>::div
int128_t  ZRQCj3cR25compiler_builtins0_0_0_Hb3int4sdiv3Div0g3div0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128

{
	int128_t rv;
	int128_t var0;	// i128
	int128_t var1;	// i128
	int128_t var2;	// i128
	int128_t var3;	// i128
	int128_t var4;	// i128
	uint128_t var5;	// u128
	int128_t var6;	// i128
	uint128_t var7;	// u128
	int128_t var8;	// i128
	uint128_t var9;	// u128
	int128_t var10;	// i128
	int128_t var11;	// i128
	var0 = shr128s(arg0, 0x7f);	// _0 = BinOp(a0 BIT_SHR 0x7f u32)
	var1 = shr128s(arg1, 0x7f);	// _1 = BinOp(a1 BIT_SHR 0x7f u32)
	var3 = xor128s(arg0, var0);	// _3 = BinOp(a0 BIT_XOR _0)
	sub128s_o(var3, var0, &var6);
	// ^ Call( _6 = "overflowing_sub"::<i128,>( _3, _0, ), bb1, bb4)
	var4 = xor128s(arg1, var1);	// _4 = BinOp(a1 BIT_XOR _1)
	sub128s_o(var4, var1, &var8);
	// ^ Call( _8 = "overflowing_sub"::<i128,>( _4, _1, ), bb2, bb4)
	var2 = xor128s(var0, var1);	// _2 = BinOp(_0 BIT_XOR _1)
	var5.lo = var6.lo; var5.hi = var6.hi;	// _5 = Cast(_6 as u128)
	var7.lo = var8.lo; var7.hi = var8.hi;	// _7 = Cast(_8 as u128)
	var9 = ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g( var5, var7 );
	// ^ Call( _9 = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div( _5, _7, ), bb3, bb4)
	var10.lo = var9.lo; var10.hi = var9.hi;	// _10 = Cast(_9 as i128)
	var11 = xor128s(var10, var2);	// _11 = BinOp(_10 BIT_XOR _2)
	rv = sub128s(var11, var2);	// retval = BinOp(_11 SUB _2)
	return rv;
	// ^ Return
bb4: _Unwind_Resume(); // Diverge
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Mod>::mod_
int128_t  ZRQCj3cR25compiler_builtins0_0_0_Hb3int4sdiv3Mod0g4mod_0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128

{
	int128_t rv;
	int128_t var0;	// i128
	int128_t var1;	// i128
	int128_t var2;	// i128
	int128_t var3;	// i128
	uint128_t var4;	// u128
	int128_t var5;	// i128
	uint128_t var6;	// u128
	int128_t var7;	// i128
	uint128_t var8;	// u128
	int128_t var9;	// i128
	int128_t var10;	// i128
	var0 = shr128s(arg1, 0x7f);	// _0 = BinOp(a1 BIT_SHR 0x7f u32)
	var2 = xor128s(arg1, var0);	// _2 = BinOp(a1 BIT_XOR _0)
	sub128s_o(var2, var0, &var7);
	// ^ Call( _7 = "overflowing_sub"::<i128,>( _2, _0, ), bb1, bb4)
	var1 = shr128s(arg0, 0x7f);	// _1 = BinOp(a0 BIT_SHR 0x7f u32)
	var3 = xor128s(arg0, var1);	// _3 = BinOp(a0 BIT_XOR _1)
	sub128s_o(var3, var1, &var5);
	// ^ Call( _5 = "overflowing_sub"::<i128,>( _3, _1, ), bb2, bb4)
	var4.lo = var5.lo; var4.hi = var5.hi;	// _4 = Cast(_5 as u128)
	var6.lo = var7.lo; var6.hi = var7.hi;	// _6 = Cast(_7 as u128)
	var8 = ZRQCi2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_rem0g( var4, var6 );
	// ^ Call( _8 = <u128 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_rem( _4, _6, ), bb3, bb4)
	var9.lo = var8.lo; var9.hi = var8.hi;	// _9 = Cast(_8 as i128)
	var10 = xor128s(var9, var1);	// _10 = BinOp(_9 BIT_XOR _1)
	rv = sub128s(var10, var1);	// retval = BinOp(_10 SUB _1)
	return rv;
	// ^ Return
bb4: _Unwind_Resume(); // Diverge
}
// <i128 as ::"compiler_builtins-0_0_0_Hb"::int::shift::Ashr>::ashr
int128_t  ZRQCj3cR25compiler_builtins0_0_0_Hb3int5shift4Ashr0g4ashr0g(
		int128_t arg0, // i128
		uint32_t arg1 // u32
		) // -> i128

{
	int128_t rv;
	uint32_t var0;	// u32
	RUST_BOOL var1;	// bool
	uint32_t var2;	// u32
	int128_t var3;	// i128
	int64_t var4;	// i64
	uint32_t var5;	// u32
	int64_t var6;	// i64
	int128_t var7;	// i128
	int64_t var8;	// i64
	uint32_t var9;	// u32
	int128_t var10;	// i128
	int128_t var11;	// i128
	int128_t var12;	// i128
	uint64_t var13;	// u64
	int64_t var14;	// i64
	int128_t var15;	// i128
	int64_t var16;	// i64
	uint64_t var17;	// u64
	uint32_t var18;	// u32
	uint64_t var19;	// u64
	uint64_t var20;	// u64
	uint64_t var21;	// u64
	int128_t var22;	// i128
	int64_t var23;	// i64
	int128_t var24;	// i128
	int128_t var25;	// i128
	int128_t var26;	// i128
	uint64_t var27;	// u64
	int64_t var28;	// i64
	var0 = 0x40;	// _0 = Constant(0x40 u32)
	var2 = arg1 & 0x40;	// _2 = BinOp(a1 BIT_AND 0x40 u32)
	var1 = var2 != 0x0;	// _1 = BinOp(_2 NE 0x0 u32)
	if(var1) goto bb1; else goto bb2;
	// ^ If( _1 : 1, 2)
bb1:
	var3 = shr128s(arg0, 64);	// _3 = BinOp(a0 BIT_SHR +64 i32)
	var4 = var3.lo;	// _4 = Cast(_3 as i64)
	var5 = arg1 - var0;	// _5 = BinOp(a1 SUB _0)
	var6 = var4 >> var5;	// _6 = BinOp(_4 BIT_SHR _5)
	var13 = (uint64_t )var6;	// _13 = Cast(_6 as u64)
	var7 = shr128s(arg0, 64);	// _7 = BinOp(a0 BIT_SHR +64 i32)
	var8 = var7.lo;	// _8 = Cast(_7 as i64)
	var9 = var0 - 0x1;	// _9 = BinOp(_0 SUB 0x1 u32)
	var14 = var8 >> var9;	// _14 = BinOp(_8 BIT_SHR _9)
	var10.lo = var13; var10.hi = var13 < 0 ? -1 : 0;	// _10 = Cast(_13 as i128)
	var12.lo = var14; var12.hi = var14 < 0 ? -1 : 0;	// _12 = Cast(_14 as i128)
	var11 = shl128s(var12, 64);	// _11 = BinOp(_12 BIT_SHL +64 i32)
	rv = or128s(var10, var11);	// retval = BinOp(_10 BIT_OR _11)
	return rv;
	// ^ Return
bb2:
	var1 = arg1 == 0x0;	// _1 = BinOp(a1 EQ 0x0 u32)
	if(var1) goto bb3; else goto bb4;
	// ^ If( _1 : 3, 4)
bb3:
	rv = arg0;	// retval = Use(a0)
	return rv;
	// ^ Return
bb4:
	var15 = shr128s(arg0, 64);	// _15 = BinOp(a0 BIT_SHR +64 i32)
	var16 = var15.lo;	// _16 = Cast(_15 as i64)
	var17 = (uint64_t )var16;	// _17 = Cast(_16 as u64)
	var18 = var0 - arg1;	// _18 = BinOp(_0 SUB a1)
	var20 = var17 << var18;	// _20 = BinOp(_17 BIT_SHL _18)
	var19 = arg0.lo;	// _19 = Cast(a0 as u64)
	var21 = var19 >> arg1;	// _21 = BinOp(_19 BIT_SHR a1)
	var27 = var20 | var21;	// _27 = BinOp(_20 BIT_OR _21)
	var22 = shr128s(arg0, 64);	// _22 = BinOp(a0 BIT_SHR +64 i32)
	var23 = var22.lo;	// _23 = Cast(_22 as i64)
	var28 = var23 >> arg1;	// _28 = BinOp(_23 BIT_SHR a1)
	var24.lo = var27; var24.hi = var27 < 0 ? -1 : 0;	// _24 = Cast(_27 as i128)
	var26.lo = var28; var26.hi = var28 < 0 ? -1 : 0;	// _26 = Cast(_28 as i128)
	var25 = shl128s(var26, 64);	// _25 = BinOp(_26 BIT_SHL +64 i32)
	rv = or128s(var24, var25);	// retval = BinOp(_24 BIT_OR _25)
	return rv;
	// ^ Return
}
// <i128 as ::"core-0_0_0"::cmp::PartialEq<i128,>>::eq<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCj2cE9core0_0_03cmp9PartialEq1gCj2eq0g(
		int128_t *arg0, // &'#omitted i128
		int128_t *arg1 // &'#omitted i128
		) // -> bool

{
	RUST_BOOL rv;
	rv = 0 == cmp128s((*arg1), (*arg0));	// retval = BinOp(a0* EQ a1*)
	return rv;
	// ^ Return
}
// <i128 as ::"core-0_0_0"::cmp::PartialEq<i128,>>::ne<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCj2cE9core0_0_03cmp9PartialEq1gCj2ne0g(
		int128_t *arg0, // &'#omitted i128
		int128_t *arg1 // &'#omitted i128
		) // -> bool

{
	RUST_BOOL rv;
	rv = 0 != cmp128s((*arg1), (*arg0));	// retval = BinOp(a0* NE a1*)
	return rv;
	// ^ Return
}
// <i128 as ::"core-0_0_0"::cmp::PartialOrd<i128,>>::ge<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCj2cE9core0_0_03cmp10PartialOrd1gCj2ge0g(
		int128_t *arg0, // &'#omitted i128
		int128_t *arg1 // &'#omitted i128
		) // -> bool

{
	RUST_BOOL rv;
	rv = 0 >= cmp128s((*arg1), (*arg0));	// retval = BinOp(a0* GE a1*)
	return rv;
	// ^ Return
}
// <i128 as ::"core-0_0_0"::cmp::PartialOrd<i128,>>::gt<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCj2cE9core0_0_03cmp10PartialOrd1gCj2gt0g(
		int128_t *arg0, // &'#omitted i128
		int128_t *arg1 // &'#omitted i128
		) // -> bool

{
	RUST_BOOL rv;
	rv = 0 > cmp128s((*arg1), (*arg0));	// retval = BinOp(a0* GT a1*)
	return rv;
	// ^ Return
}
// <i128 as ::"core-0_0_0"::cmp::PartialOrd<i128,>>::le<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCj2cE9core0_0_03cmp10PartialOrd1gCj2le0g(
		int128_t *arg0, // &'#omitted i128
		int128_t *arg1 // &'#omitted i128
		) // -> bool

{
	RUST_BOOL rv;
	rv = 0 <= cmp128s((*arg1), (*arg0));	// retval = BinOp(a0* LE a1*)
	return rv;
	// ^ Return
}
// <i128 as ::"core-0_0_0"::cmp::PartialOrd<i128,>>::lt<'#omitted,'#omitted,>
static RUST_BOOL  ZRQCj2cE9core0_0_03cmp10PartialOrd1gCj2lt0g(
		int128_t *arg0, // &'#omitted i128
		int128_t *arg1 // &'#omitted i128
		) // -> bool

{
	RUST_BOOL rv;
	rv = 0 < cmp128s((*arg1), (*arg0));	// retval = BinOp(a0* LT a1*)
	return rv;
	// ^ Return
}
// <i128 as ::"core-0_0_0"::ops::arith::Add<i128,>>::add
static int128_t  ZRQCj3cE9core0_0_03ops5arith3Add1gCj3add0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128

{
	int128_t rv;
	rv = add128s(arg0, arg1);	// retval = BinOp(a0 ADD a1)
	return rv;
	// ^ Return
}
// <i128 as ::"core-0_0_0"::ops::arith::Neg>::neg
static int128_t  ZRQCj3cE9core0_0_03ops5arith3Neg0g3neg0g(
		int128_t arg0 // i128
		) // -> i128

{
	int128_t rv;
	rv = neg128s(arg0);	// retval = UniOp(a0 NEG)
	return rv;
	// ^ Return
}
// <i128 as ::"core-0_0_0"::ops::arith::Sub<i128,>>::sub
static int128_t  ZRQCj3cE9core0_0_03ops5arith3Sub1gCj3sub0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128

{
	int128_t rv;
	rv = sub128s(arg0, arg1);	// retval = BinOp(a0 SUB a1)
	return rv;
	// ^ Return
}
// <i128 as ::"core-0_0_0"::ops::bit::BitXor<i128,>>::bitxor
static int128_t  ZRQCj3cE9core0_0_03ops3bit6BitXor1gCj6bitxor0g(
		int128_t arg0, // i128
		int128_t arg1 // i128
		) // -> i128

{
	int128_t rv;
	rv = xor128s(arg0, arg1);	// retval = BinOp(a0 BIT_XOR a1)
	return rv;
	// ^ Return
}
// <i128 as ::"core-0_0_0"::ops::bit::Shr<u32,>>::shr
static int128_t  ZRQCj3cE9core0_0_03ops3bit3Shr1gCe3shr0g(
		int128_t arg0, // i128
		uint32_t arg1 // u32
		) // -> i128

{
	int128_t rv;
	rv = shr128s(arg0, arg1);	// retval = BinOp(a0 BIT_SHR a1)
	return rv;
	// ^ Return
}
// <f32 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::from_parts
float  ZRQCn2cR25compiler_builtins0_0_0_Hb5float5Float0g10from_parts0g(
		RUST_BOOL arg0, // bool
		uint32_t arg1, // u32
		uint32_t arg2 // u32
		) // -> f32

{
	float rv;
	uint32_t var0;	// u32
	uint32_t var1;	// u32
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	uint32_t var4;	// u32
	uint32_t var5;	// u32
	uint32_t var6;	// u32
	var2 = (uint32_t )arg0;	// _2 = Cast(a0 as u32)
	var1 = var2 << 0x1f;	// _1 = BinOp(_2 BIT_SHL 0x1f u32)
	var4 = arg1 << 0x17;	// _4 = BinOp(a1 BIT_SHL 0x17 u32)
	var3 = var4 & 0x7f800000;	// _3 = BinOp(_4 BIT_AND 0x7f800000 u32)
	var0 = var1 | var3;	// _0 = BinOp(_1 BIT_OR _3)
	var5 = arg2 & 0x7fffff;	// _5 = BinOp(a2 BIT_AND 0x7fffff u32)
	var6 = var0 | var5;	// _6 = BinOp(_0 BIT_OR _5)
	memcpy( &rv, &var6, sizeof(uint32_t ));
	// ^ Call( retval = "transmute"::<u32,f32,>( _6, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <f32 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::from_repr
float  ZRQCn2cR25compiler_builtins0_0_0_Hb5float5Float0g9from_repr0g(
		uint32_t arg0 // u32
		) // -> f32

{
	float rv;
	memcpy( &rv, &arg0, sizeof(uint32_t ));
	// ^ Call( retval = "transmute"::<u32,f32,>( a0, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <f32 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::normalize
TUP_2_ZRTCf_ZRTCe  ZRQCn2cR25compiler_builtins0_0_0_Hb5float5Float0g9normalize0g(
		uint32_t arg0 // u32
		) // -> (i32, u32, )

{
	TUP_2_ZRTCf_ZRTCe rv;
	uint32_t var0;	// u32
	uint32_t var1;	// u32
	uint32_t var2;	// u32
	uint32_t var3;	// u32
	int32_t var4;	// i32
	int32_t var5;	// i32
	var2 = (arg0 != 0 ? __builtin_clz(arg0) : sizeof(uint32_t )*8);
	// ^ Call( _2 = "ctlz"::<u32,>( a0, ), bb1, bb5)
	var3 = (0x800000 != 0 ? __builtin_clz(0x800000) : sizeof(uint32_t )*8);
	// ^ Call( _3 = "ctlz"::<u32,>( 0x800000 u32, ), bb2, bb5)
	__builtin_sub_overflow(var2, var3, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u32,>( _2, _3, ), bb3, bb5)
	var5 = (int32_t )var0;	// _5 = Cast(_0 as i32)
	__builtin_sub_overflow(1, var5, &var4);
	// ^ Call( _4 = "overflowing_sub"::<i32,>( +1 i32, _5, ), bb4, bb5)
	var1 = arg0 << var0;	// _1 = BinOp(a0 BIT_SHL _0)
	;
	rv._0 = var4;
	rv._1 = var1;	// retval = Tuple(_4, _1)
	return rv;
	// ^ Return
bb5: _Unwind_Resume(); // Diverge
}
// <f32 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::repr
uint32_t  ZRQCn2cR25compiler_builtins0_0_0_Hb5float5Float0g4repr0g(
		float arg0 // f32
		) // -> u32

{
	uint32_t rv;
	memcpy( &rv, &arg0, sizeof(float ));
	// ^ Call( retval = "transmute"::<f32,u32,>( a0, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <f32 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::signed_repr
int32_t  ZRQCn2cR25compiler_builtins0_0_0_Hb5float5Float0g11signed_repr0g(
		float arg0 // f32
		) // -> i32

{
	int32_t rv;
	memcpy( &rv, &arg0, sizeof(float ));
	// ^ Call( retval = "transmute"::<f32,i32,>( a0, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <f32 as ::"compiler_builtins-0_0_0_Hb"::float::pow::Pow>::pow
float  ZRQCn3cR25compiler_builtins0_0_0_Hb5float3pow3Pow0g_C0g(
		float arg0, // f32
		int32_t arg1 // i32
		) // -> f32

{
	float rv;
	float var0;	// f32
	RUST_BOOL var1;	// bool
	float var2;	// f32
	RUST_BOOL var3;	// bool
	int32_t var4;	// i32
	float *var5;	// &'#omitted mut f32
	float *var6;	// &'#omitted mut f32
	var0 = arg0;	// _0 = Use(a0)
	var1 = arg1 < 0;	// _1 = BinOp(a1 LT +0 i32)
	var2 = 1.0000000000e+00f;	// _2 = Constant(0x1p+0 f32)
	// ^ Goto(1)
bb1:
	var4 = arg1 & 1;	// _4 = BinOp(a1 BIT_AND +1 i32)
	var3 = var4 != 0;	// _3 = BinOp(_4 NE +0 i32)
	if(var3) goto bb2; else goto bb3;
	// ^ If( _3 : 2, 3)
bb2:
	var5 = & var2;	// _5 = Borrow(Unique, _2)
	(*var5) = (*var5) * var0;	// _5* = BinOp(_5* MUL _0)
	// ^ drop(_5)
	// ^ Goto(3)
bb3:
	arg1 = ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g( arg1, 2 );
	// ^ Call( a1 = <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div( a1, +2 i32, ), bb4, bb5)
	var3 = arg1 == 0;	// _3 = BinOp(a1 EQ +0 i32)
	if(var3) goto bb6; else goto bb7;
	// ^ If( _3 : 6, 7)
bb5: _Unwind_Resume(); // Diverge
bb6:
	var3 = var1;	// _3 = Use(_1)
	if(var1) goto bb8; else goto bb9;
	// ^ If( _1 : 8, 9)
bb7:
	var6 = & var0;	// _6 = Borrow(Unique, _0)
	(*var6) = (*var6) * var0;	// _6* = BinOp(_6* MUL _0)
	// ^ drop(_6)
	goto bb1;
	// ^ Goto(1)
bb8:
	rv = 1.0000000000e+00f / var2;	// retval = BinOp(0x1p+0 f32 DIV _2)
	return rv;
	// ^ Return
bb9:
	rv = var2;	// retval = Use(_2)
	return rv;
	// ^ Return
}
// <f32 as ::"core-0_0_0"::ops::arith::Div<f32,>>::div
static float  ZRQCn3cE9core0_0_03ops5arith3Div1gCn3div0g(
		float arg0, // f32
		float arg1 // f32
		) // -> f32

{
	float rv;
	rv = arg0 / arg1;	// retval = BinOp(a0 DIV a1)
	return rv;
	// ^ Return
}
// <f32 as ::"core-0_0_0"::ops::arith::MulAssign<f32,>>::mul_assign<'#omitted,>
static void  ZRQCn3cE9core0_0_03ops5arith9MulAssign1gCn10mul_assign0g(
		float *arg0, // &'#omitted mut f32
		float arg1 // f32
		) // -> ()

{
	tUNIT rv;
	(*arg0) = (*arg0) * arg1;	// a0* = BinOp(a0* MUL a1)
	/* ZST assign */
	// ^ drop(a0)
	return ;
	// ^ Return
}
// <f64 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::from_parts
double  ZRQCo2cR25compiler_builtins0_0_0_Hb5float5Float0g10from_parts0g(
		RUST_BOOL arg0, // bool
		uint64_t arg1, // u64
		uint64_t arg2 // u64
		) // -> f64

{
	double rv;
	uint64_t var0;	// u64
	uint64_t var1;	// u64
	uint64_t var2;	// u64
	uint64_t var3;	// u64
	uint64_t var4;	// u64
	uint64_t var5;	// u64
	uint64_t var6;	// u64
	var2 = (uint64_t )arg0;	// _2 = Cast(a0 as u64)
	var1 = var2 << 0x3f;	// _1 = BinOp(_2 BIT_SHL 0x3f u32)
	var4 = arg1 << 0x34;	// _4 = BinOp(a1 BIT_SHL 0x34 u32)
	var3 = var4 & 0x7ff0000000000000ull;	// _3 = BinOp(_4 BIT_AND 0x7ff0000000000000 u64)
	var0 = var1 | var3;	// _0 = BinOp(_1 BIT_OR _3)
	var5 = arg2 & 0xfffffffffffffull;	// _5 = BinOp(a2 BIT_AND 0xfffffffffffff u64)
	var6 = var0 | var5;	// _6 = BinOp(_0 BIT_OR _5)
	memcpy( &rv, &var6, sizeof(uint64_t ));
	// ^ Call( retval = "transmute"::<u64,f64,>( _6, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <f64 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::from_repr
double  ZRQCo2cR25compiler_builtins0_0_0_Hb5float5Float0g9from_repr0g(
		uint64_t arg0 // u64
		) // -> f64

{
	double rv;
	memcpy( &rv, &arg0, sizeof(uint64_t ));
	// ^ Call( retval = "transmute"::<u64,f64,>( a0, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <f64 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::normalize
TUP_2_ZRTCf_ZRTCg  ZRQCo2cR25compiler_builtins0_0_0_Hb5float5Float0g9normalize0g(
		uint64_t arg0 // u64
		) // -> (i32, u64, )

{
	TUP_2_ZRTCf_ZRTCg rv;
	uint32_t var0;	// u32
	uint64_t var1;	// u64
	uint64_t var2;	// u64
	uint64_t var3;	// u64
	uint64_t var4;	// u64
	uint32_t var5;	// u32
	uint32_t var6;	// u32
	int32_t var7;	// i32
	int32_t var8;	// i32
	var3 = (arg0 != 0 ? __builtin_clz64(arg0) : sizeof(uint64_t )*8);
	// ^ Call( _3 = "ctlz"::<u64,>( a0, ), bb1, bb5)
	var5 = (uint32_t )var3;	// _5 = Cast(_3 as u32)
	var4 = (0x10000000000000ull != 0 ? __builtin_clz64(0x10000000000000ull) : sizeof(uint64_t )*8);
	// ^ Call( _4 = "ctlz"::<u64,>( 0x10000000000000 u64, ), bb2, bb5)
	var6 = (uint32_t )var4;	// _6 = Cast(_4 as u32)
	__builtin_sub_overflow(var5, var6, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u32,>( _5, _6, ), bb3, bb5)
	var8 = (int32_t )var0;	// _8 = Cast(_0 as i32)
	__builtin_sub_overflow(1, var8, &var7);
	// ^ Call( _7 = "overflowing_sub"::<i32,>( +1 i32, _8, ), bb4, bb5)
	var1 = (uint64_t )var0;	// _1 = Cast(_0 as u64)
	var2 = arg0 << var1;	// _2 = BinOp(a0 BIT_SHL _1)
	;
	rv._0 = var7;
	rv._1 = var2;	// retval = Tuple(_7, _2)
	return rv;
	// ^ Return
bb5: _Unwind_Resume(); // Diverge
}
// <f64 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::repr
uint64_t  ZRQCo2cR25compiler_builtins0_0_0_Hb5float5Float0g4repr0g(
		double arg0 // f64
		) // -> u64

{
	uint64_t rv;
	memcpy( &rv, &arg0, sizeof(double ));
	// ^ Call( retval = "transmute"::<f64,u64,>( a0, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <f64 as ::"compiler_builtins-0_0_0_Hb"::float::Float>::signed_repr
int64_t  ZRQCo2cR25compiler_builtins0_0_0_Hb5float5Float0g11signed_repr0g(
		double arg0 // f64
		) // -> i64

{
	int64_t rv;
	memcpy( &rv, &arg0, sizeof(double ));
	// ^ Call( retval = "transmute"::<f64,i64,>( a0, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <f64 as ::"compiler_builtins-0_0_0_Hb"::float::pow::Pow>::pow
double  ZRQCo3cR25compiler_builtins0_0_0_Hb5float3pow3Pow0g_C0g(
		double arg0, // f64
		int32_t arg1 // i32
		) // -> f64

{
	double rv;
	double var0;	// f64
	RUST_BOOL var1;	// bool
	double var2;	// f64
	RUST_BOOL var3;	// bool
	int32_t var4;	// i32
	double *var5;	// &'#omitted mut f64
	double *var6;	// &'#omitted mut f64
	var0 = arg0;	// _0 = Use(a0)
	var1 = arg1 < 0;	// _1 = BinOp(a1 LT +0 i32)
	var2 = 1.000000000000000000e+00;	// _2 = Constant(0x1p+0 f64)
	// ^ Goto(1)
bb1:
	var4 = arg1 & 1;	// _4 = BinOp(a1 BIT_AND +1 i32)
	var3 = var4 != 0;	// _3 = BinOp(_4 NE +0 i32)
	if(var3) goto bb2; else goto bb3;
	// ^ If( _3 : 2, 3)
bb2:
	var5 = & var2;	// _5 = Borrow(Unique, _2)
	(*var5) = (*var5) * var0;	// _5* = BinOp(_5* MUL _0)
	// ^ drop(_5)
	// ^ Goto(3)
bb3:
	arg1 = ZRQCf2cR25compiler_builtins0_0_0_Hb3int3Int0g12aborting_div0g( arg1, 2 );
	// ^ Call( a1 = <i32 as ::"compiler_builtins-0_0_0_Hb"::int::Int>::aborting_div( a1, +2 i32, ), bb4, bb5)
	var3 = arg1 == 0;	// _3 = BinOp(a1 EQ +0 i32)
	if(var3) goto bb6; else goto bb7;
	// ^ If( _3 : 6, 7)
bb5: _Unwind_Resume(); // Diverge
bb6:
	var3 = var1;	// _3 = Use(_1)
	if(var1) goto bb8; else goto bb9;
	// ^ If( _1 : 8, 9)
bb7:
	var6 = & var0;	// _6 = Borrow(Unique, _0)
	(*var6) = (*var6) * var0;	// _6* = BinOp(_6* MUL _0)
	// ^ drop(_6)
	goto bb1;
	// ^ Goto(1)
bb8:
	rv = 1.000000000000000000e+00 / var2;	// retval = BinOp(0x1p+0 f64 DIV _2)
	return rv;
	// ^ Return
bb9:
	rv = var2;	// retval = Use(_2)
	return rv;
	// ^ Return
}
// <f64 as ::"core-0_0_0"::ops::arith::Div<f64,>>::div
static double  ZRQCo3cE9core0_0_03ops5arith3Div1gCo3div0g(
		double arg0, // f64
		double arg1 // f64
		) // -> f64

{
	double rv;
	rv = arg0 / arg1;	// retval = BinOp(a0 DIV a1)
	return rv;
	// ^ Return
}
// <f64 as ::"core-0_0_0"::ops::arith::MulAssign<f64,>>::mul_assign<'#omitted,>
static void  ZRQCo3cE9core0_0_03ops5arith9MulAssign1gCo10mul_assign0g(
		double *arg0, // &'#omitted mut f64
		double arg1 // f64
		) // -> ()

{
	tUNIT rv;
	(*arg0) = (*arg0) * arg1;	// a0* = BinOp(a0* MUL a1)
	/* ZST assign */
	// ^ drop(a0)
	return ;
	// ^ Return
}
// <::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/ as ::"core-0_0_0"::clone::Clone>::clone<'#omitted,>
struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g  ZRQG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g2cE9core0_0_05clone5Clone0g_F0g(
		struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g *arg0 // &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
		) // -> ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/

{
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g rv;
	switch((*arg0).TAG) {
	case 0: goto bb1;break;
	case 1: goto bb2;break;
	case 2: goto bb3;break;
	case 3: goto bb4;break;
	default: abort();
	}
	// ^ Switch( a0* : 0 => bb1, 1 => bb2, 2 => bb3, 3 => bb4, )
bb1:
	rv.TAG = 0;	// retval = Variant(::"compiler_builtins-0_0_0_Hb"::float::cmp::Result #0, {})
	return rv;
	// ^ Return
bb2:
	rv.TAG = 1;	// retval = Variant(::"compiler_builtins-0_0_0_Hb"::float::cmp::Result #1, {})
	return rv;
	// ^ Return
bb3:
	rv.TAG = 2;	// retval = Variant(::"compiler_builtins-0_0_0_Hb"::float::cmp::Result #2, {})
	return rv;
	// ^ Return
bb4:
	rv.TAG = 3;	// retval = Variant(::"compiler_builtins-0_0_0_Hb"::float::cmp::Result #3, {})
	return rv;
	// ^ Return
}
// <::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/ as ::"core-0_0_0"::clone::Clone>::clone_from<'#omitted,'#omitted,>
static void  ZRQG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g2cE9core0_0_05clone5Clone0g10clone_from0g(
		struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g *arg0, // &'#omitted mut ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
		struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g *arg1 // &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/
		) // -> ()

{
	tUNIT rv;
	(*arg0) = ZRQG3cR25compiler_builtins0_0_0_Hb5float3cmp6Result0g2cE9core0_0_05clone5Clone0g_F0g( arg1 );
	// ^ Call( a0* = <::"compiler_builtins-0_0_0_Hb"::float::cmp::Result/*E*/ as ::"core-0_0_0"::clone::Clone>::clone<'#omitted,>( a1, ), bb1, bb2)
	/* ZST assign */
	// ^ drop(a0)
	return ;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>
RUST_BOOL  ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g(
		struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *arg0, // &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
		struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *arg1 // &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
		) // -> bool

{
	RUST_BOOL rv;
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var0;	// &'M0 ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *var1;	// &'M0 ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
	var0 = arg0;	// _0 = Use(a0)
	var1 = arg1;	// _1 = Use(a1)
	if((*var0).TAG == 0) {goto bb1;} else {goto bb2;}
	// ^ Switch( _0* : 0 => bb1, 1 => bb2, )
bb1:
	if((*var1).TAG == 0) {goto bb4;} else {goto bb3;}
	// ^ Switch( _1* : 0 => bb4, 1 => bb3, )
bb2:
	if((*var1).TAG == 0) {goto bb3;} else {goto bb4;}
	// ^ Switch( _1* : 0 => bb3, 1 => bb4, )
bb3:
	rv = false;	// retval = Constant(false)
	return rv;
	// ^ Return
bb4:
	rv = true;	// retval = Constant(true)
	return rv;
	// ^ Return
}
// <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::ne<'#omitted,'#omitted,>
static RUST_BOOL  ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2ne0g(
		struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *arg0, // &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
		struct e_ZRG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g *arg1 // &'#omitted ::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/
		) // -> bool

{
	RUST_BOOL rv;
	RUST_BOOL var0;	// bool
	var0 = ZRQG3cR25compiler_builtins0_0_0_Hb5float4conv4Sign0g2cE9core0_0_03cmp9PartialEq1gG3c_A_B_C_D0g2eq0g( arg0, arg1 );
	// ^ Call( _0 = <::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"compiler_builtins-0_0_0_Hb"::float::conv::Sign/*E*/,>>::eq<'#omitted,'#omitted,>( a0, a1, ), bb1, bb2)
	rv = !var0;	// retval = UniOp(_0 INV)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmoddi4_1/*S*/ as ::"core-0_0_0"::ops::function::Fn<(i64, i64, ),>>::call<'#omitted,>
int64_t  ZRQG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmoddi4_10g3cE9core0_0_03ops8function2Fn1gT2ChCh4call0g(
		struct s_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmoddi4_10g *arg0, // &'#omitted ::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmoddi4_1/*S*/
		TUP_2_ZRTCh_ZRTCh arg1 // (i64, i64, )
		) // -> i64

{
	int64_t rv;
	rv = ZRQCh3cR25compiler_builtins0_0_0_Hb3int4sdiv3Div0g3div0g( arg1._0, arg1._1 );
	// ^ Call( retval = <i64 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Div>::div( a1.0, a1.1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmoddi4_1/*S*/ as ::"core-0_0_0"::ops::function::FnMut<(i64, i64, ),>>::call_mut<'#omitted,>
int64_t  ZRQG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmoddi4_10g3cE9core0_0_03ops8function5FnMut1gT2ChCh8call_mut0g(
		struct s_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmoddi4_10g *arg0, // &'#omitted mut ::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmoddi4_1/*S*/
		TUP_2_ZRTCh_ZRTCh arg1 // (i64, i64, )
		) // -> i64

{
	int64_t rv;
	rv = ZRQCh3cR25compiler_builtins0_0_0_Hb3int4sdiv3Div0g3div0g( arg1._0, arg1._1 );
	// ^ Call( retval = <i64 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Div>::div( a1.0, a1.1, ), bb1, bb2)
	// ^ drop(a0)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmoddi4_1/*S*/ as ::"core-0_0_0"::ops::function::FnOnce<(i64, i64, ),>>::call_once
int64_t  ZRQG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmoddi4_10g3cE9core0_0_03ops8function6FnOnce1gT2ChCh9call_once0g(
		struct s_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmoddi4_10g arg0, // ::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmoddi4_1/*S*/
		TUP_2_ZRTCh_ZRTCh arg1 // (i64, i64, )
		) // -> i64

{
	int64_t rv;
	rv = ZRQCh3cR25compiler_builtins0_0_0_Hb3int4sdiv3Div0g3div0g( arg1._0, arg1._1 );
	// ^ Call( retval = <i64 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Div>::div( a1.0, a1.1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmodsi4_0/*S*/ as ::"core-0_0_0"::ops::function::Fn<(i32, i32, ),>>::call<'#omitted,>
int32_t  ZRQG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmodsi4_00g3cE9core0_0_03ops8function2Fn1gT2CfCf4call0g(
		struct s_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmodsi4_00g *arg0, // &'#omitted ::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmodsi4_0/*S*/
		TUP_2_ZRTCf_ZRTCf arg1 // (i32, i32, )
		) // -> i32

{
	int32_t rv;
	rv = ZRQCf3cR25compiler_builtins0_0_0_Hb3int4sdiv3Div0g3div0g( arg1._0, arg1._1 );
	// ^ Call( retval = <i32 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Div>::div( a1.0, a1.1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmodsi4_0/*S*/ as ::"core-0_0_0"::ops::function::FnMut<(i32, i32, ),>>::call_mut<'#omitted,>
int32_t  ZRQG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmodsi4_00g3cE9core0_0_03ops8function5FnMut1gT2CfCf8call_mut0g(
		struct s_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmodsi4_00g *arg0, // &'#omitted mut ::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmodsi4_0/*S*/
		TUP_2_ZRTCf_ZRTCf arg1 // (i32, i32, )
		) // -> i32

{
	int32_t rv;
	rv = ZRQCf3cR25compiler_builtins0_0_0_Hb3int4sdiv3Div0g3div0g( arg1._0, arg1._1 );
	// ^ Call( retval = <i32 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Div>::div( a1.0, a1.1, ), bb1, bb2)
	// ^ drop(a0)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmodsi4_0/*S*/ as ::"core-0_0_0"::ops::function::FnOnce<(i32, i32, ),>>::call_once
int32_t  ZRQG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmodsi4_00g3cE9core0_0_03ops8function6FnOnce1gT2CfCf9call_once0g(
		struct s_ZRG3cR25compiler_builtins0_0_0_Hb3int4sdivH20closure__divmodsi4_00g arg0, // ::"compiler_builtins-0_0_0_Hb"::int::sdiv::closure#__divmodsi4_0/*S*/
		TUP_2_ZRTCf_ZRTCf arg1 // (i32, i32, )
		) // -> i32

{
	int32_t rv;
	rv = ZRQCf3cR25compiler_builtins0_0_0_Hb3int4sdiv3Div0g3div0g( arg1._0, arg1._1 );
	// ^ Call( retval = <i32 as ::"compiler_builtins-0_0_0_Hb"::int::sdiv::Div>::div( a1.0, a1.1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
