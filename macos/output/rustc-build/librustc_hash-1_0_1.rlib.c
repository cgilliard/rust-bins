/*
 * AUTOGENERATED by mrustc
 */
#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#include <assert.h>
#include <stdatomic.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <setjmp.h>
typedef uint32_t RUST_CHAR;
typedef uint8_t RUST_BOOL;
typedef struct { void* PTR; size_t META; } SLICE_PTR;
typedef struct { void* PTR; void* META; } TRAITOBJ_PTR;
typedef struct { void (*drop)(void*); size_t size; size_t align; } VTABLE_HDR;
typedef struct { char _d; } tUNIT;
typedef char tBANG;
typedef struct { char _d; } tTYPEID;
static inline size_t ALIGN_TO(size_t s, size_t a) { return (s + a-1) / a * a; }

extern void _Unwind_Resume(void) __attribute__((noreturn));
#define ALIGNOF(t) __alignof__(t)
extern __thread jmp_buf*    mrustc_panic_target;
extern __thread void* mrustc_panic_value;
static inline uint64_t __builtin_clz64(uint64_t v) {
	return ( (v >> 32) != 0 ? __builtin_clz(v>>32) : 32 + __builtin_clz(v));
}
static inline uint64_t __builtin_ctz64(uint64_t v) {
	return ((v&0xFFFFFFFF) == 0 ? __builtin_ctz(v>>32) + 32 : __builtin_ctz(v));
}
static inline uint8_t __mrustc_atomicloop8(volatile uint8_t* slot, uint8_t param, int ordering, uint8_t (*cb)(uint8_t, uint8_t)) { int ordering_load = (ordering == memory_order_release || ordering == memory_order_acq_rel ? memory_order_relaxed : ordering); for(;;) { uint8_t v = atomic_load_explicit((_Atomic uint8_t*)slot, ordering_load); if( atomic_compare_exchange_strong_explicit((_Atomic uint8_t*)slot, &v, cb(v, param), ordering, ordering_load) ) return v; }}
static inline uint16_t __mrustc_atomicloop16(volatile uint16_t* slot, uint16_t param, int ordering, uint16_t (*cb)(uint16_t, uint16_t)) { int ordering_load = (ordering == memory_order_release || ordering == memory_order_acq_rel ? memory_order_relaxed : ordering); for(;;) { uint16_t v = atomic_load_explicit((_Atomic uint16_t*)slot, ordering_load); if( atomic_compare_exchange_strong_explicit((_Atomic uint16_t*)slot, &v, cb(v, param), ordering, ordering_load) ) return v; }}
static inline uint32_t __mrustc_atomicloop32(volatile uint32_t* slot, uint32_t param, int ordering, uint32_t (*cb)(uint32_t, uint32_t)) { int ordering_load = (ordering == memory_order_release || ordering == memory_order_acq_rel ? memory_order_relaxed : ordering); for(;;) { uint32_t v = atomic_load_explicit((_Atomic uint32_t*)slot, ordering_load); if( atomic_compare_exchange_strong_explicit((_Atomic uint32_t*)slot, &v, cb(v, param), ordering, ordering_load) ) return v; }}
static inline uint64_t __mrustc_atomicloop64(volatile uint64_t* slot, uint64_t param, int ordering, uint64_t (*cb)(uint64_t, uint64_t)) { int ordering_load = (ordering == memory_order_release || ordering == memory_order_acq_rel ? memory_order_relaxed : ordering); for(;;) { uint64_t v = atomic_load_explicit((_Atomic uint64_t*)slot, ordering_load); if( atomic_compare_exchange_strong_explicit((_Atomic uint64_t*)slot, &v, cb(v, param), ordering, ordering_load) ) return v; }}
typedef unsigned __int128 uint128_t;
typedef signed __int128 int128_t;
static inline uint128_t __builtin_bswap128(uint128_t v) {
	uint64_t lo = __builtin_bswap64((uint64_t)v);
	uint64_t hi = __builtin_bswap64((uint64_t)(v>>64));
	return ((uint128_t)lo << 64) | (uint128_t)hi;
}
static inline uint128_t intrinsic_ctlz_u128(uint128_t v) {
	return (v == 0 ? 128 : (v >> 64 != 0 ? __builtin_clz64(v>>64) : 64 + __builtin_clz64(v)));
}
static inline uint128_t intrinsic_cttz_u128(uint128_t v) {
	return (v == 0 ? 128 : ((v&0xFFFFFFFFFFFFFFFF) == 0 ? __builtin_ctz64(v>>64) + 64 : __builtin_ctz64(v)));
}

static inline int slice_cmp(SLICE_PTR l, SLICE_PTR r) {
	int rv = memcmp(l.PTR, r.PTR, l.META < r.META ? l.META : r.META);
	if(rv != 0) return rv;
	if(l.META < r.META) return -1;
	if(l.META > r.META) return 1;
	return 0;
}
static inline SLICE_PTR make_sliceptr(void* ptr, size_t s) { SLICE_PTR rv = { ptr, s }; return rv; }
static inline TRAITOBJ_PTR make_traitobjptr(void* ptr, void* vt) { TRAITOBJ_PTR rv = { ptr, vt }; return rv; }

static inline size_t mrustc_max(size_t a, size_t b) { return a < b ? b : a; }
static inline void noop_drop(tUNIT *p) { }

static inline size_t mrustc_string_search_linear(SLICE_PTR val, size_t count, SLICE_PTR* options) {
	for(size_t i = 0; i < count; i ++) {
		int cmp = slice_cmp(val, options[i]);
		if(cmp < 0) break;
		if(cmp == 0) return i;
	}
	return SIZE_MAX;
}
static const uint8_t __mrustc_revmap[16] = { 0, 8, 4,12, 2,10, 6,14,  1, 9, 5,13, 3, 7,15};
static inline uint8_t __mrustc_bitrev8(uint8_t v) { if(v==0||v==0xFF) return v; return __mrustc_revmap[v>>4]|(__mrustc_revmap[v&15]<<4); }
static inline uint16_t __mrustc_bitrev16(uint16_t v) { if(v==0) return 0; return ((uint16_t)__mrustc_bitrev8(v>>8))|((uint16_t)__mrustc_bitrev8(v)<<8); }
static inline uint32_t __mrustc_bitrev32(uint32_t v) { if(v==0) return 0; return ((uint32_t)__mrustc_bitrev16(v>>16))|((uint32_t)__mrustc_bitrev16(v)<<16); }
static inline uint64_t __mrustc_bitrev64(uint64_t v) { if(v==0) return 0; return ((uint64_t)__mrustc_bitrev32(v>>32))|((uint64_t)__mrustc_bitrev32(v)<<32); }
static inline uint128_t __mrustc_bitrev128(uint128_t v) { if(v==0) return 0; uint128_t rv = ((uint128_t)__mrustc_bitrev64(v>>64))|((uint128_t)__mrustc_bitrev64(v)<<64); return rv; }
static inline uint8_t __mrustc_op_umax8(uint8_t a, uint8_t b) { return (a > b ? a : b); }
static inline uint8_t __mrustc_op_umin8(uint8_t a, uint8_t b) { return (a < b ? a : b); }
static inline uint8_t __mrustc_op_imax8(uint8_t a, uint8_t b) { return ((int8_t)a > (int8_t)b ? a : b); }
static inline uint8_t __mrustc_op_imin8(uint8_t a, uint8_t b) { return ((int8_t)a < (int8_t)b ? a : b); }
static inline uint8_t __mrustc_op_and_not8(uint8_t a, uint8_t b) { return ~(a & b); }
static inline uint16_t __mrustc_op_umax16(uint16_t a, uint16_t b) { return (a > b ? a : b); }
static inline uint16_t __mrustc_op_umin16(uint16_t a, uint16_t b) { return (a < b ? a : b); }
static inline uint16_t __mrustc_op_imax16(uint16_t a, uint16_t b) { return ((int16_t)a > (int16_t)b ? a : b); }
static inline uint16_t __mrustc_op_imin16(uint16_t a, uint16_t b) { return ((int16_t)a < (int16_t)b ? a : b); }
static inline uint16_t __mrustc_op_and_not16(uint16_t a, uint16_t b) { return ~(a & b); }
static inline uint32_t __mrustc_op_umax32(uint32_t a, uint32_t b) { return (a > b ? a : b); }
static inline uint32_t __mrustc_op_umin32(uint32_t a, uint32_t b) { return (a < b ? a : b); }
static inline uint32_t __mrustc_op_imax32(uint32_t a, uint32_t b) { return ((int32_t)a > (int32_t)b ? a : b); }
static inline uint32_t __mrustc_op_imin32(uint32_t a, uint32_t b) { return ((int32_t)a < (int32_t)b ? a : b); }
static inline uint32_t __mrustc_op_and_not32(uint32_t a, uint32_t b) { return ~(a & b); }
static inline uint64_t __mrustc_op_umax64(uint64_t a, uint64_t b) { return (a > b ? a : b); }
static inline uint64_t __mrustc_op_umin64(uint64_t a, uint64_t b) { return (a < b ? a : b); }
static inline uint64_t __mrustc_op_imax64(uint64_t a, uint64_t b) { return ((int64_t)a > (int64_t)b ? a : b); }
static inline uint64_t __mrustc_op_imin64(uint64_t a, uint64_t b) { return ((int64_t)a < (int64_t)b ? a : b); }
static inline uint64_t __mrustc_op_and_not64(uint64_t a, uint64_t b) { return ~(a & b); }
// struct ::"rustc_hash-1_0_1"::FxHasher
struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g  {
	/*@0*/uintptr_t _0; // usize
} ;
typedef char sizeof_assert_ZRG1cK15rustc_hash1_0_18FxHasher0g[ (sizeof(struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g) == 8) ? 1 : -1 ];
typedef char alignof_assert_ZRG1cK15rustc_hash1_0_18FxHasher0g[ (ALIGNOF(struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g) == 8) ? 1 : -1 ];
// struct ::"core-0_0_0"::ops::range::RangeFrom<usize,>
struct s_ZRG3cE9core0_0_03ops5range9RangeFrom1gCu  {
	/*@0*/uintptr_t _0; // usize
} ;
typedef char sizeof_assert_ZRG3cE9core0_0_03ops5range9RangeFrom1gCu[ (sizeof(struct s_ZRG3cE9core0_0_03ops5range9RangeFrom1gCu) == 8) ? 1 : -1 ];
typedef char alignof_assert_ZRG3cE9core0_0_03ops5range9RangeFrom1gCu[ (ALIGNOF(struct s_ZRG3cE9core0_0_03ops5range9RangeFrom1gCu) == 8) ? 1 : -1 ];
// struct ::"core-0_0_0"::ops::range::Range<usize,>
struct s_ZRG3cE9core0_0_03ops5range5Range1gCu  {
	/*@0*/uintptr_t _0; // usize
	/*@8*/uintptr_t _1; // usize
} ;
typedef char sizeof_assert_ZRG3cE9core0_0_03ops5range5Range1gCu[ (sizeof(struct s_ZRG3cE9core0_0_03ops5range5Range1gCu) == 16) ? 1 : -1 ];
typedef char alignof_assert_ZRG3cE9core0_0_03ops5range5Range1gCu[ (ALIGNOF(struct s_ZRG3cE9core0_0_03ops5range5Range1gCu) == 8) ? 1 : -1 ];
typedef struct t_ZRTA16Ca  { uint8_t  DATA[16]; } t_ZRTA16Ca ; // [u8; 16]
struct s_ZRG1cK15rustc_hash1_0_1H16closureI_write_00g;
 // (&'#omitted [u8], )
typedef struct TUP_1_ZRTBsSCa  {
	/*@0*/SLICE_PTR _0; // &'#omitted [u8]
} TUP_1_ZRTBsSCa ;
typedef char sizeof_assert_TUP_1_ZRTBsSCa [ (sizeof(TUP_1_ZRTBsSCa ) == 16) ? 1 : -1 ];
// struct ::"rustc_hash-1_0_1"::closure#I_write_0<'#omitted,>
struct s_ZRG1cK15rustc_hash1_0_1H16closureI_write_00g  {
	char _d;
} __attribute__((__aligned__(1),)) ;
typedef char alignof_assert_ZRG1cK15rustc_hash1_0_1H16closureI_write_00g[ (ALIGNOF(struct s_ZRG1cK15rustc_hash1_0_1H16closureI_write_00g) == 1) ? 1 : -1 ];
struct s_ZRG2cE9core0_0_05panic9PanicInfo0g;
// struct ::"core-0_0_0"::option::Option#Some<&'#local0 [::"core-0_0_0"::fmt::rt::v1::Argument/*S*/],>
struct s_ZRG2cE9core0_0_06optionG10OptionSome1gBsSG4c_A3fmt2rt2v18Argument0g  {
	/*@0*/SLICE_PTR _0; // &'#local0 [::"core-0_0_0"::fmt::rt::v1::Argument/*S*/]
} ;
typedef char sizeof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gBsSG4c_A3fmt2rt2v18Argument0g[ (sizeof(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gBsSG4c_A3fmt2rt2v18Argument0g) == 16) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gBsSG4c_A3fmt2rt2v18Argument0g[ (ALIGNOF(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gBsSG4c_A3fmt2rt2v18Argument0g) == 8) ? 1 : -1 ];
// enum ::"core-0_0_0"::option::Option<&'#local0 [::"core-0_0_0"::fmt::rt::v1::Argument/*S*/],>
struct e_ZRG2cE9core0_0_06option6Option1gBsSG4c_A3fmt2rt2v18Argument0g {
	struct {
		struct s_ZRG2cE9core0_0_06optionG10OptionSome1gBsSG4c_A3fmt2rt2v18Argument0g var_1;
	} DATA;
};
typedef char sizeof_assert_ZRG2cE9core0_0_06option6Option1gBsSG4c_A3fmt2rt2v18Argument0g[ (sizeof(struct e_ZRG2cE9core0_0_06option6Option1gBsSG4c_A3fmt2rt2v18Argument0g) == 16) ? 1 : -1 ];
// struct ::"core-0_0_0"::fmt::Arguments<'#local0,>
struct s_ZRG2cE9core0_0_03fmt9Arguments0g  {
	/*@0*/SLICE_PTR _0; // &'#local0 [&'#local0 str]
	/*@16*/struct e_ZRG2cE9core0_0_06option6Option1gBsSG4c_A3fmt2rt2v18Argument0g _1; // ::"core-0_0_0"::option::Option<&'#local0 [::"core-0_0_0"::fmt::rt::v1::Argument/*S*/],>/*E*/
	/*@32*/SLICE_PTR _2; // &'#local0 [::"core-0_0_0"::fmt::ArgumentV1<'#local0,>/*S*/]
} ;
typedef char sizeof_assert_ZRG2cE9core0_0_03fmt9Arguments0g[ (sizeof(struct s_ZRG2cE9core0_0_03fmt9Arguments0g) == 48) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_03fmt9Arguments0g[ (ALIGNOF(struct s_ZRG2cE9core0_0_03fmt9Arguments0g) == 8) ? 1 : -1 ];
typedef struct t_ZRTfQBsCy2cE9core0_0_03fmt7Display0g_B0g  { char _unused; } t_ZRTfQBsCy2cE9core0_0_03fmt7Display0g_B0g ;
struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g;
struct s_ZRG2cE9core0_0_03fmt9Formatter0g;
typedef struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g  (*t_ZRTF2BsBsCyBuG2cE9core0_0_03fmt9Formatter0gG2c_A6result6Result2gT0G2c_A_B5Error0g )( SLICE_PTR *, struct s_ZRG2cE9core0_0_03fmt9Formatter0g * ); // for<'elided#0,'elided#1,> extern "Rust" fn(&'static &'static str, &'static mut ::"core-0_0_0"::fmt::Formatter<'static,>/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/
struct s_ZRG2cE9core0_0_03fmt4Void0g;
typedef struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g  (*t_ZRTF2BsG2cE9core0_0_03fmt4Void0gBuG2c_A_B9Formatter0gG2c_A6result6Result2gT0G2c_A_B5Error0g )( struct s_ZRG2cE9core0_0_03fmt4Void0g *, struct s_ZRG2cE9core0_0_03fmt9Formatter0g * ); // for<'elided#0,'elided#1,> extern "Rust" fn(&'H0 ::"core-0_0_0"::fmt::Void/*S*/, &'H1 mut ::"core-0_0_0"::fmt::Formatter<'H1,>/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/
// struct ::"core-0_0_0"::fmt::ArgumentV1<'static,>
struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g  {
	/*@0*/struct s_ZRG2cE9core0_0_03fmt4Void0g *_0; // &'static ::"core-0_0_0"::fmt::Void/*S*/
	/*@8*/t_ZRTF2BsG2cE9core0_0_03fmt4Void0gBuG2c_A_B9Formatter0gG2c_A6result6Result2gT0G2c_A_B5Error0g _1; // for<'elided#0,'elided#1,> extern "Rust" fn(&'H0 ::"core-0_0_0"::fmt::Void/*S*/, &'H1 mut ::"core-0_0_0"::fmt::Formatter<'H1,>/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/
} ;
typedef char sizeof_assert_ZRG2cE9core0_0_03fmt10ArgumentV10g[ (sizeof(struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g) == 16) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_03fmt10ArgumentV10g[ (ALIGNOF(struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g) == 8) ? 1 : -1 ];
typedef struct t_ZRTA1G2cE9core0_0_03fmt10ArgumentV10g  { struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g  DATA[1]; } t_ZRTA1G2cE9core0_0_03fmt10ArgumentV10g ; // [::"core-0_0_0"::fmt::ArgumentV1<'static,>/*S*/; 1]
// struct ::"core-0_0_0"::slice::FatPtr<u8,>
struct s_ZRG2cE9core0_0_05slice6FatPtr1gCa  {
	/*@0*/uint8_t *_0; // *const u8
	/*@8*/uintptr_t _1; // usize
} ;
typedef char sizeof_assert_ZRG2cE9core0_0_05slice6FatPtr1gCa[ (sizeof(struct s_ZRG2cE9core0_0_05slice6FatPtr1gCa) == 16) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_05slice6FatPtr1gCa[ (ALIGNOF(struct s_ZRG2cE9core0_0_05slice6FatPtr1gCa) == 8) ? 1 : -1 ];
union u_ZRG2cE9core0_0_05slice4Repr1gCa {
	SLICE_PTR var_0;
	SLICE_PTR var_1;
	struct s_ZRG2cE9core0_0_05slice6FatPtr1gCa var_2;
};
typedef char sizeof_assert_ZRG2cE9core0_0_05slice4Repr1gCa[ (sizeof(union u_ZRG2cE9core0_0_05slice4Repr1gCa) == 16) ? 1 : -1 ];
// struct ::"core-0_0_0"::result::Result#Ok<(),::"core-0_0_0"::fmt::Error/*S*/,>
struct s_ZRG2cE9core0_0_06resultG8ResultOk2gT0G2c_A3fmt5Error0g  {
	/*@0*/uint8_t _1; // u8
	/*@1*/// ZST; // ()
} __attribute__((__aligned__(1),)) ;
typedef char sizeof_assert_ZRG2cE9core0_0_06resultG8ResultOk2gT0G2c_A3fmt5Error0g[ (sizeof(struct s_ZRG2cE9core0_0_06resultG8ResultOk2gT0G2c_A3fmt5Error0g) == 1) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_06resultG8ResultOk2gT0G2c_A3fmt5Error0g[ (ALIGNOF(struct s_ZRG2cE9core0_0_06resultG8ResultOk2gT0G2c_A3fmt5Error0g) == 1) ? 1 : -1 ];
// struct ::"core-0_0_0"::fmt::Error
struct s_ZRG2cE9core0_0_03fmt5Error0g  {
	char _d;
} __attribute__((__aligned__(1),)) ;
typedef char alignof_assert_ZRG2cE9core0_0_03fmt5Error0g[ (ALIGNOF(struct s_ZRG2cE9core0_0_03fmt5Error0g) == 1) ? 1 : -1 ];
// struct ::"core-0_0_0"::result::Result#Err<(),::"core-0_0_0"::fmt::Error/*S*/,>
struct s_ZRG2cE9core0_0_06resultG9ResultErr2gT0G2c_A3fmt5Error0g  {
	/*@0*/uint8_t _1; // u8
	/*@1*/// ZST; // ::"core-0_0_0"::fmt::Error/*S*/
} __attribute__((__aligned__(1),)) ;
typedef char sizeof_assert_ZRG2cE9core0_0_06resultG9ResultErr2gT0G2c_A3fmt5Error0g[ (sizeof(struct s_ZRG2cE9core0_0_06resultG9ResultErr2gT0G2c_A3fmt5Error0g) == 1) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_06resultG9ResultErr2gT0G2c_A3fmt5Error0g[ (ALIGNOF(struct s_ZRG2cE9core0_0_06resultG9ResultErr2gT0G2c_A3fmt5Error0g) == 1) ? 1 : -1 ];
// enum ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>
struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g {
	union {
		struct s_ZRG2cE9core0_0_06resultG8ResultOk2gT0G2c_A3fmt5Error0g var_0;
		struct s_ZRG2cE9core0_0_06resultG9ResultErr2gT0G2c_A3fmt5Error0g var_1;
		uint8_t TAG;
	} DATA;
};
typedef char sizeof_assert_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g[ (sizeof(struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g) == 1) ? 1 : -1 ];
typedef struct TUP_3_ZRTBsCy_ZRTCe_ZRTCe  TUP_3_ZRTBsCy_ZRTCe_ZRTCe ;
typedef struct t_ZRTA2BsCy  { SLICE_PTR  DATA[2]; } t_ZRTA2BsCy ; // [&'static str; 2]
 // (&'static str, u32, u32, )
typedef struct TUP_3_ZRTBsCy_ZRTCe_ZRTCe  {
	/*@0*/uint32_t _1; // u32
	/*@4*/uint32_t _2; // u32
	/*@8*/SLICE_PTR _0; // &'#omitted str
} TUP_3_ZRTBsCy_ZRTCe_ZRTCe ;
typedef char sizeof_assert_TUP_3_ZRTBsCy_ZRTCe_ZRTCe [ (sizeof(TUP_3_ZRTBsCy_ZRTCe_ZRTCe ) == 24) ? 1 : -1 ];
// PROTO extern "Rust" <::"core-0_0_0"::fmt::ArgumentV1<'static,>/*S*/ /*- <'static,>*/>::new<'static,&'static str,>
static struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g  ZRIG2cE9core0_0_03fmt10ArgumentV10g3new1gBsCy(
		SLICE_PTR *arg0, // &'static &'static str
		t_ZRTF2BsBsCyBuG2cE9core0_0_03fmt9Formatter0gG2c_A6result6Result2gT0G2c_A_B5Error0g arg1 // for<'elided#0,'elided#1,> extern "Rust" fn(&'H0 &'static str, &'H1 mut ::"core-0_0_0"::fmt::Formatter<'H1,>/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/
		) // -> ::"core-0_0_0"::fmt::ArgumentV1<'static,>/*S*/
;
// PROTO extern "Rust" <::"rustc_hash-1_0_1"::closure#I_write_0<'#omitted,>/*S*/ /*- <'#omitted,>*/>::call_free
uint64_t  ZRIG1cK15rustc_hash1_0_1H16closureI_write_00g9call_free0g(
		SLICE_PTR arg0 // &'#omitted [u8]
		) // -> u64
;
// PROTO extern "Rust" <::"byteorder-1_2_3_H9"::LittleEndian/*E*/ as ::"byteorder-1_2_3_H9"::ByteOrder>::read_u16<'#omitted,>
static uint16_t  ZRQG1cJ17byteorder1_2_3_H912LittleEndian0g1c_A9ByteOrder0g8read_u160g(
		SLICE_PTR arg0 // &'#omitted [u8]
		) // -> u16
;
// PROTO extern "Rust" <::"byteorder-1_2_3_H9"::LittleEndian/*E*/ as ::"byteorder-1_2_3_H9"::ByteOrder>::read_u32<'#omitted,>
static uint32_t  ZRQG1cJ17byteorder1_2_3_H912LittleEndian0g1c_A9ByteOrder0g8read_u320g(
		SLICE_PTR arg0 // &'#omitted [u8]
		) // -> u32
;
// PROTO extern "Rust" <::"byteorder-1_2_3_H9"::LittleEndian/*E*/ as ::"byteorder-1_2_3_H9"::ByteOrder>::read_u64<'static,>
static uint64_t  ZRQG1cJ17byteorder1_2_3_H912LittleEndian0g1c_A9ByteOrder0g8read_u640g(
		SLICE_PTR arg0 // &'static [u8]
		) // -> u64
;
// PROTO extern "Rust" <::"core-0_0_0"::ops::range::Range<usize,>/*S*/ as ::"core-0_0_0"::slice::SliceIndex<[u8],>>::index<'#omitted,>
static SLICE_PTR  ZRQG3cE9core0_0_03ops5range5Range1gCu2c_A5slice10SliceIndex1gSCa5index0g(
		struct s_ZRG3cE9core0_0_03ops5range5Range1gCu arg0, // ::"core-0_0_0"::ops::range::Range<usize,>/*S*/
		SLICE_PTR arg1 // &'#omitted [u8]
		) // -> &'#omitted [u8]
;
// PROTO extern "Rust" <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::default::Default>::default
struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_07default7Default0g_D0g(void) // -> ::"rustc_hash-1_0_1"::FxHasher/*S*/
;
// PROTO extern "Rust" <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::finish<'#omitted,>
uint64_t  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g6finish0g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0 // &'#omitted ::"rustc_hash-1_0_1"::FxHasher/*S*/
		) // -> u64
;
// PROTO extern "Rust" <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write<'#omitted,'#omitted,>
void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g5write0g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		SLICE_PTR arg1 // &'#omitted [u8]
		) // -> ()
;
// PROTO extern "Rust" <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_i128<'#omitted,>
static void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g10write_i1280g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		int128_t arg1 // i128
		) // -> ()
;
// PROTO extern "Rust" <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_i16<'#omitted,>
static void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g9write_i160g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		int16_t arg1 // i16
		) // -> ()
;
// PROTO extern "Rust" <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_i32<'#omitted,>
static void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g9write_i320g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		int32_t arg1 // i32
		) // -> ()
;
// PROTO extern "Rust" <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_i64<'#omitted,>
static void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g9write_i640g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		int64_t arg1 // i64
		) // -> ()
;
// PROTO extern "Rust" <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_i8<'#omitted,>
static void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g8write_i80g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		int8_t arg1 // i8
		) // -> ()
;
// PROTO extern "Rust" <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_isize<'#omitted,>
static void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g11write_isize0g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		intptr_t arg1 // isize
		) // -> ()
;
// PROTO extern "Rust" <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_u128<'#omitted,>
static void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g10write_u1280g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		uint128_t arg1 // u128
		) // -> ()
;
// PROTO extern "Rust" <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_u16<'#omitted,>
void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g9write_u160g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		uint16_t arg1 // u16
		) // -> ()
;
// PROTO extern "Rust" <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_u32<'#omitted,>
void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g9write_u320g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		uint32_t arg1 // u32
		) // -> ()
;
// PROTO extern "Rust" <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_u64<'#omitted,>
void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g9write_u640g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		uint64_t arg1 // u64
		) // -> ()
;
// PROTO extern "Rust" <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_u8<'#omitted,>
void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g8write_u80g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		uint8_t arg1 // u8
		) // -> ()
;
// PROTO extern "Rust" <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_usize<'#omitted,>
void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g11write_usize0g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		uintptr_t arg1 // usize
		) // -> ()
;
// PROTO extern "Rust" <::"rustc_hash-1_0_1"::closure#I_write_0<'#omitted,>/*S*/ as ::"core-0_0_0"::ops::function::Fn<(&'#omitted [u8], ),>>::call<'#omitted,>
uint64_t  ZRQG1cK15rustc_hash1_0_1H16closureI_write_00g3cE9core0_0_03ops8function2Fn1gT1BsSCa4call0g(
		struct s_ZRG1cK15rustc_hash1_0_1H16closureI_write_00g *arg0, // &'#omitted ::"rustc_hash-1_0_1"::closure#I_write_0<'#omitted,>/*S*/
		TUP_1_ZRTBsSCa arg1 // (&'#omitted [u8], )
		) // -> u64
;
// PROTO extern "Rust" <::"rustc_hash-1_0_1"::closure#I_write_0<'#omitted,>/*S*/ as ::"core-0_0_0"::ops::function::FnMut<(&'#omitted [u8], ),>>::call_mut<'#omitted,>
uint64_t  ZRQG1cK15rustc_hash1_0_1H16closureI_write_00g3cE9core0_0_03ops8function5FnMut1gT1BsSCa8call_mut0g(
		struct s_ZRG1cK15rustc_hash1_0_1H16closureI_write_00g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::closure#I_write_0<'#omitted,>/*S*/
		TUP_1_ZRTBsSCa arg1 // (&'#omitted [u8], )
		) // -> u64
;
// PROTO extern "Rust" <::"rustc_hash-1_0_1"::closure#I_write_0<'#omitted,>/*S*/ as ::"core-0_0_0"::ops::function::FnOnce<(&'#omitted [u8], ),>>::call_once
uint64_t  ZRQG1cK15rustc_hash1_0_1H16closureI_write_00g3cE9core0_0_03ops8function6FnOnce1gT1BsSCa9call_once0g(
		struct s_ZRG1cK15rustc_hash1_0_1H16closureI_write_00g arg0, // ::"rustc_hash-1_0_1"::closure#I_write_0<'#omitted,>/*S*/
		TUP_1_ZRTBsSCa arg1 // (&'#omitted [u8], )
		) // -> u64
;
// PROTO extern "Rust" <&'static str as ::"core-0_0_0"::fmt::Display>::fmt<'static,'static,>
static struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g  ZRQBsCy2cE9core0_0_03fmt7Display0g_B0g(
		SLICE_PTR *arg0, // &'static &'static str
		struct s_ZRG2cE9core0_0_03fmt9Formatter0g *arg1 // &'static mut ::"core-0_0_0"::fmt::Formatter<'static,>/*S*/
		) // -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/
;
// EXTERN extern "Rust" ::"core-0_0_0"::slice::slice_index_len_fail
extern tBANG  ZRG2cE9core0_0_05slice20slice_index_len_fail0g(
		uintptr_t arg0, // usize
		uintptr_t arg1 // usize
		) // -> !
;
// EXTERN extern "Rust" ::"core-0_0_0"::slice::slice_index_order_fail
extern tBANG  ZRG2cE9core0_0_05slice22slice_index_order_fail0g(
		uintptr_t arg0, // usize
		uintptr_t arg1 // usize
		) // -> !
;
// EXTERN extern "Rust" ::"std-0_0_0"::panicking::begin_panic_fmt<'#local6,'static,>
extern tBANG  ZRG2cD8std0_0_09panicking15begin_panic_fmt0g(
		struct s_ZRG2cE9core0_0_03fmt9Arguments0g *arg0, // &'#local6 ::"core-0_0_0"::fmt::Arguments<'#local6,>/*S*/
		TUP_3_ZRTBsCy_ZRTCe_ZRTCe *arg1 // &'static (&'static str, u32, u32, )
		) // -> !
;
// EXTERN extern "Rust" <str as ::"core-0_0_0"::fmt::Display>::fmt<'static,'static,>
extern struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g  ZRQCy2cE9core0_0_03fmt7Display0g_B0g(
		SLICE_PTR arg0, // &'static str
		struct s_ZRG2cE9core0_0_03fmt9Formatter0g *arg1 // &'static mut ::"core-0_0_0"::fmt::Formatter<'static,>/*S*/
		) // -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/
;
extern union u_static_ZRG2cJ17byteorder1_2_3_H9C_399FRAGMENTS0g{ t_ZRTA2BsCy val; uintptr_t raw[4]; } ZRG2cJ17byteorder1_2_3_H9C_399FRAGMENTS0g;	// static ::"byteorder-1_2_3_H9"::#39::FRAGMENTS : [&'static str; 2]
extern union u_static_ZRG2cJ17byteorder1_2_3_H9C_419FRAGMENTS0g{ t_ZRTA2BsCy val; uintptr_t raw[4]; } ZRG2cJ17byteorder1_2_3_H9C_419FRAGMENTS0g;	// static ::"byteorder-1_2_3_H9"::#41::FRAGMENTS : [&'static str; 2]
extern union u_static_ZRG2cJ17byteorder1_2_3_H9C_439FRAGMENTS0g{ t_ZRTA2BsCy val; uintptr_t raw[4]; } ZRG2cJ17byteorder1_2_3_H9C_439FRAGMENTS0g;	// static ::"byteorder-1_2_3_H9"::#43::FRAGMENTS : [&'static str; 2]
extern union u_static_ZRG1cJ17byteorder1_2_3_H9F7const710g{ SLICE_PTR val; uintptr_t raw[2]; } ZRG1cJ17byteorder1_2_3_H9F7const710g;	// static ::"byteorder-1_2_3_H9"::const#71 : &'static str
extern union u_static_ZRG1cJ17byteorder1_2_3_H9F7const720g{ TUP_3_ZRTBsCy_ZRTCe_ZRTCe val; uintptr_t raw[3]; } ZRG1cJ17byteorder1_2_3_H9F7const720g;	// static ::"byteorder-1_2_3_H9"::const#72 : (&'static str, u32, u32, )
extern union u_static_ZRG1cJ17byteorder1_2_3_H9F7const760g{ SLICE_PTR val; uintptr_t raw[2]; } ZRG1cJ17byteorder1_2_3_H9F7const760g;	// static ::"byteorder-1_2_3_H9"::const#76 : &'static str
extern union u_static_ZRG1cJ17byteorder1_2_3_H9F7const770g{ TUP_3_ZRTBsCy_ZRTCe_ZRTCe val; uintptr_t raw[3]; } ZRG1cJ17byteorder1_2_3_H9F7const770g;	// static ::"byteorder-1_2_3_H9"::const#77 : (&'static str, u32, u32, )
extern union u_static_ZRG1cJ17byteorder1_2_3_H9F7const810g{ SLICE_PTR val; uintptr_t raw[2]; } ZRG1cJ17byteorder1_2_3_H9F7const810g;	// static ::"byteorder-1_2_3_H9"::const#81 : &'static str
extern union u_static_ZRG1cJ17byteorder1_2_3_H9F7const820g{ TUP_3_ZRTBsCy_ZRTCe_ZRTCe val; uintptr_t raw[3]; } ZRG1cJ17byteorder1_2_3_H9F7const820g;	// static ::"byteorder-1_2_3_H9"::const#82 : (&'static str, u32, u32, )
// <::"core-0_0_0"::fmt::ArgumentV1<'static,>/*S*/ /*- <'static,>*/>::new<'static,&'static str,>
static struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g  ZRIG2cE9core0_0_03fmt10ArgumentV10g3new1gBsCy(
		SLICE_PTR *arg0, // &'static &'static str
		t_ZRTF2BsBsCyBuG2cE9core0_0_03fmt9Formatter0gG2c_A6result6Result2gT0G2c_A_B5Error0g arg1 // for<'elided#0,'elided#1,> extern "Rust" fn(&'H0 &'static str, &'H1 mut ::"core-0_0_0"::fmt::Formatter<'H1,>/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/
		) // -> ::"core-0_0_0"::fmt::ArgumentV1<'static,>/*S*/

{
	struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g rv;
	t_ZRTF2BsG2cE9core0_0_03fmt4Void0gBuG2c_A_B9Formatter0gG2c_A6result6Result2gT0G2c_A_B5Error0g var0;	// for<'elided#0,'elided#1,> extern "Rust" fn(&'static ::"core-0_0_0"::fmt::Void/*S*/, &'static mut ::"core-0_0_0"::fmt::Formatter<'static,>/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/
	struct s_ZRG2cE9core0_0_03fmt4Void0g *var1;	// &'static ::"core-0_0_0"::fmt::Void/*S*/
	memcpy( &var0, &arg1, sizeof(t_ZRTF2BsBsCyBuG2cE9core0_0_03fmt9Formatter0gG2c_A6result6Result2gT0G2c_A_B5Error0g ));
	// ^ Call( _0 = "transmute"::<for<'elided#0,'elided#1,> extern "Rust" fn(&'static &'static str, &'static mut ::"core-0_0_0"::fmt::Formatter<'static,>/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/,for<'elided#0,'elided#1,> extern "Rust" fn(&'static ::"core-0_0_0"::fmt::Void/*S*/, &'static mut ::"core-0_0_0"::fmt::Formatter<'static,>/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/,>( a1, ), bb1, bb3)
	var1 = (void*)arg0;
	// ^ Call( _1 = "transmute"::<&'static &'static str,&'static ::"core-0_0_0"::fmt::Void/*S*/,>( a0, ), bb2, bb3)
	rv._0 = var1;
	rv._1 = var0;	// retval = Struct(::"core-0_0_0"::fmt::ArgumentV1<'static,>, {_1, _0})
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// <::"rustc_hash-1_0_1"::closure#I_write_0<'#omitted,>/*S*/ /*- <'#omitted,>*/>::call_free
uint64_t  ZRIG1cK15rustc_hash1_0_1H16closureI_write_00g9call_free0g(
		SLICE_PTR arg0 // &'#omitted [u8]
		) // -> u64

{
	uint64_t rv;
	rv = ZRQG1cJ17byteorder1_2_3_H912LittleEndian0g1c_A9ByteOrder0g8read_u640g( arg0 );
	// ^ Call( retval = <::"byteorder-1_2_3_H9"::LittleEndian/*E*/ as ::"byteorder-1_2_3_H9"::ByteOrder>::read_u64<'static,>( a0, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"byteorder-1_2_3_H9"::LittleEndian/*E*/ as ::"byteorder-1_2_3_H9"::ByteOrder>::read_u16<'#omitted,>
static uint16_t  ZRQG1cJ17byteorder1_2_3_H912LittleEndian0g1c_A9ByteOrder0g8read_u160g(
		SLICE_PTR arg0 // &'#omitted [u8]
		) // -> u16

{
	uint16_t rv;
	uint16_t var0;	// u16
	RUST_BOOL var1;	// bool
	uintptr_t var2;	// usize
	struct s_ZRG2cE9core0_0_03fmt9Arguments0g var3;	// ::"core-0_0_0"::fmt::Arguments<'#local0,>/*S*/
	t_ZRTfQBsCy2cE9core0_0_03fmt7Display0g_B0g var4 = {0};	// fn{<&'static str as ::"core-0_0_0"::fmt::Display>::fmt<'static,'static,>}
	t_ZRTF2BsBsCyBuG2cE9core0_0_03fmt9Formatter0gG2c_A6result6Result2gT0G2c_A_B5Error0g var5;	// for<'elided#0,'elided#1,> extern "Rust" fn(&'static &'static str, &'static mut ::"core-0_0_0"::fmt::Formatter<'static,>/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/
	struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g var6;	// ::"core-0_0_0"::fmt::ArgumentV1<'static,>/*S*/
	t_ZRTA1G2cE9core0_0_03fmt10ArgumentV10g var7;	// [::"core-0_0_0"::fmt::ArgumentV1<'static,>/*S*/; 1]
	t_ZRTA1G2cE9core0_0_03fmt10ArgumentV10g *var8;	// &'#local0 [::"core-0_0_0"::fmt::ArgumentV1<'static,>/*S*/; 1]
	struct s_ZRG2cE9core0_0_03fmt9Arguments0g *var9;	// &'#local1 ::"core-0_0_0"::fmt::Arguments<'#local0,>/*S*/
	tUNIT var10 = {0};	// ()
	uint8_t *var11;	// *const u8
	uint16_t *var12;	// &'#local4 mut u16
	uint16_t *var13;	// *mut u16
	uint8_t *var14;	// *mut u8
	tUNIT var15 = {0};	// ()
	SLICE_PTR var16;	// *const [u8]
	SLICE_PTR var17;	// *const [u8]
	struct e_ZRG2cE9core0_0_06option6Option1gBsSG4c_A3fmt2rt2v18Argument0g var18;	// ::"core-0_0_0"::option::Option<&'static [::"core-0_0_0"::fmt::rt::v1::Argument/*S*/],>/*E*/
	SLICE_PTR var19;	// &'static [&'static str]
	SLICE_PTR var20;	// &'#local0 [::"core-0_0_0"::fmt::ArgumentV1<'static,>/*S*/]
	var1 = true;	// _1 = Constant(true)
	var16 = arg0;	// _16 = Cast(a0 as *const [u8])
	var2 = var16.META;	// _2 = DstMeta(_16)
	var1 = 0x2ull <= var2;	// _1 = BinOp(0x2 usize LE _2)
	if(var1) goto bb1; else goto bb3;
	// ^ If( _1 : 1, 3)
bb1:
	var0 = 0x0;	// _0 = Constant(0x0 u16)
	var17 = arg0;	// _17 = Cast(a0 as *const [u8])
	var11 = (uint8_t *)var17.PTR;	// _11 = Cast(_17 as *const u8)
	var12 = & var0;	// _12 = Borrow(Unique, _0)
	var13 = (uint16_t *)var12;	// _13 = Cast(_12 as *mut u16)
	var14 = (uint8_t *)var13;	// _14 = Cast(_13 as *mut u8)
	memcpy( var14, var11, 0x2ull * sizeof(uint8_t ));
	// ^ Call( _15 = "copy_nonoverlapping"::<u8,>( _11, _14, 0x2 usize, ), bb2, bb5)
	rv = var0;	// retval = Use(_0)
	return rv;
	// ^ Return
bb3:
	var19 = make_sliceptr(&ZRG2cJ17byteorder1_2_3_H9C_399FRAGMENTS0g.val, 0x2ull);	// _19 = MakeDst(&::"byteorder-1_2_3_H9"::#39::FRAGMENTS, 0x2 usize)
	/* ZST assign */
	var5 = ZRQBsCy2cE9core0_0_03fmt7Display0g_B0g;	// _5 = Cast(_4 as for<'elided#0,'elided#1,> extern "Rust" fn(&'static &'static str, &'static mut ::"core-0_0_0"::fmt::Formatter<'static,>/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/)
	var6 = ZRIG2cE9core0_0_03fmt10ArgumentV10g3new1gBsCy( &ZRG1cJ17byteorder1_2_3_H9F7const710g.val, var5 );
	// ^ Call( _6 = <::"core-0_0_0"::fmt::ArgumentV1<'static,>/*S*/ /*- <'static,>*/>::new<'static,&'static str,>( &::"byteorder-1_2_3_H9"::const#71, _5, ), bb4, bb5)
	var7.DATA[0] = var6;	// _7 = Array(_6)
	var8 = & var7;	// _8 = Borrow(Shared, _7)
	var20 = make_sliceptr(var8, 0x1ull);	// _20 = MakeDst(_8, 0x1 usize)
	memset(&var18, 0, sizeof(struct e_ZRG2cE9core0_0_06option6Option1gBsSG4c_A3fmt2rt2v18Argument0g ));	// _18 = Variant(::"core-0_0_0"::option::Option<&'static [::"core-0_0_0"::fmt::rt::v1::Argument/*S*/],> #0, {})
	var3._0 = var19;
	var3._1 = var18;
	var3._2 = var20;	// _3 = Struct(::"core-0_0_0"::fmt::Arguments<'#local2,>, {_19, _18, _20})
	var9 = & var3;	// _9 = Borrow(Shared, _3)
	ZRG2cD8std0_0_09panicking15begin_panic_fmt0g( var9, &ZRG1cJ17byteorder1_2_3_H9F7const720g.val );
	// ^ Call( _10 = ::"std-0_0_0"::panicking::begin_panic_fmt<'#local6,'static,>( _9, &::"byteorder-1_2_3_H9"::const#72, ), bb5, bb5)
bb5: _Unwind_Resume(); // Diverge
}
// <::"byteorder-1_2_3_H9"::LittleEndian/*E*/ as ::"byteorder-1_2_3_H9"::ByteOrder>::read_u32<'#omitted,>
static uint32_t  ZRQG1cJ17byteorder1_2_3_H912LittleEndian0g1c_A9ByteOrder0g8read_u320g(
		SLICE_PTR arg0 // &'#omitted [u8]
		) // -> u32

{
	uint32_t rv;
	uint32_t var0;	// u32
	RUST_BOOL var1;	// bool
	uintptr_t var2;	// usize
	struct s_ZRG2cE9core0_0_03fmt9Arguments0g var3;	// ::"core-0_0_0"::fmt::Arguments<'#local0,>/*S*/
	t_ZRTfQBsCy2cE9core0_0_03fmt7Display0g_B0g var4 = {0};	// fn{<&'static str as ::"core-0_0_0"::fmt::Display>::fmt<'static,'static,>}
	t_ZRTF2BsBsCyBuG2cE9core0_0_03fmt9Formatter0gG2c_A6result6Result2gT0G2c_A_B5Error0g var5;	// for<'elided#0,'elided#1,> extern "Rust" fn(&'static &'static str, &'static mut ::"core-0_0_0"::fmt::Formatter<'static,>/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/
	struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g var6;	// ::"core-0_0_0"::fmt::ArgumentV1<'static,>/*S*/
	t_ZRTA1G2cE9core0_0_03fmt10ArgumentV10g var7;	// [::"core-0_0_0"::fmt::ArgumentV1<'static,>/*S*/; 1]
	t_ZRTA1G2cE9core0_0_03fmt10ArgumentV10g *var8;	// &'#local0 [::"core-0_0_0"::fmt::ArgumentV1<'static,>/*S*/; 1]
	struct s_ZRG2cE9core0_0_03fmt9Arguments0g *var9;	// &'#local1 ::"core-0_0_0"::fmt::Arguments<'#local0,>/*S*/
	tUNIT var10 = {0};	// ()
	uint8_t *var11;	// *const u8
	uint32_t *var12;	// &'#local4 mut u32
	uint32_t *var13;	// *mut u32
	uint8_t *var14;	// *mut u8
	tUNIT var15 = {0};	// ()
	SLICE_PTR var16;	// *const [u8]
	SLICE_PTR var17;	// *const [u8]
	struct e_ZRG2cE9core0_0_06option6Option1gBsSG4c_A3fmt2rt2v18Argument0g var18;	// ::"core-0_0_0"::option::Option<&'static [::"core-0_0_0"::fmt::rt::v1::Argument/*S*/],>/*E*/
	SLICE_PTR var19;	// &'static [&'static str]
	SLICE_PTR var20;	// &'#local0 [::"core-0_0_0"::fmt::ArgumentV1<'static,>/*S*/]
	var1 = true;	// _1 = Constant(true)
	var16 = arg0;	// _16 = Cast(a0 as *const [u8])
	var2 = var16.META;	// _2 = DstMeta(_16)
	var1 = 0x4ull <= var2;	// _1 = BinOp(0x4 usize LE _2)
	if(var1) goto bb1; else goto bb3;
	// ^ If( _1 : 1, 3)
bb1:
	var0 = 0x0;	// _0 = Constant(0x0 u32)
	var17 = arg0;	// _17 = Cast(a0 as *const [u8])
	var11 = (uint8_t *)var17.PTR;	// _11 = Cast(_17 as *const u8)
	var12 = & var0;	// _12 = Borrow(Unique, _0)
	var13 = (uint32_t *)var12;	// _13 = Cast(_12 as *mut u32)
	var14 = (uint8_t *)var13;	// _14 = Cast(_13 as *mut u8)
	memcpy( var14, var11, 0x4ull * sizeof(uint8_t ));
	// ^ Call( _15 = "copy_nonoverlapping"::<u8,>( _11, _14, 0x4 usize, ), bb2, bb5)
	rv = var0;	// retval = Use(_0)
	return rv;
	// ^ Return
bb3:
	var19 = make_sliceptr(&ZRG2cJ17byteorder1_2_3_H9C_419FRAGMENTS0g.val, 0x2ull);	// _19 = MakeDst(&::"byteorder-1_2_3_H9"::#41::FRAGMENTS, 0x2 usize)
	/* ZST assign */
	var5 = ZRQBsCy2cE9core0_0_03fmt7Display0g_B0g;	// _5 = Cast(_4 as for<'elided#0,'elided#1,> extern "Rust" fn(&'static &'static str, &'static mut ::"core-0_0_0"::fmt::Formatter<'static,>/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/)
	var6 = ZRIG2cE9core0_0_03fmt10ArgumentV10g3new1gBsCy( &ZRG1cJ17byteorder1_2_3_H9F7const760g.val, var5 );
	// ^ Call( _6 = <::"core-0_0_0"::fmt::ArgumentV1<'static,>/*S*/ /*- <'static,>*/>::new<'static,&'static str,>( &::"byteorder-1_2_3_H9"::const#76, _5, ), bb4, bb5)
	var7.DATA[0] = var6;	// _7 = Array(_6)
	var8 = & var7;	// _8 = Borrow(Shared, _7)
	var20 = make_sliceptr(var8, 0x1ull);	// _20 = MakeDst(_8, 0x1 usize)
	memset(&var18, 0, sizeof(struct e_ZRG2cE9core0_0_06option6Option1gBsSG4c_A3fmt2rt2v18Argument0g ));	// _18 = Variant(::"core-0_0_0"::option::Option<&'static [::"core-0_0_0"::fmt::rt::v1::Argument/*S*/],> #0, {})
	var3._0 = var19;
	var3._1 = var18;
	var3._2 = var20;	// _3 = Struct(::"core-0_0_0"::fmt::Arguments<'#local2,>, {_19, _18, _20})
	var9 = & var3;	// _9 = Borrow(Shared, _3)
	ZRG2cD8std0_0_09panicking15begin_panic_fmt0g( var9, &ZRG1cJ17byteorder1_2_3_H9F7const770g.val );
	// ^ Call( _10 = ::"std-0_0_0"::panicking::begin_panic_fmt<'#local6,'static,>( _9, &::"byteorder-1_2_3_H9"::const#77, ), bb5, bb5)
bb5: _Unwind_Resume(); // Diverge
}
// <::"byteorder-1_2_3_H9"::LittleEndian/*E*/ as ::"byteorder-1_2_3_H9"::ByteOrder>::read_u64<'static,>
static uint64_t  ZRQG1cJ17byteorder1_2_3_H912LittleEndian0g1c_A9ByteOrder0g8read_u640g(
		SLICE_PTR arg0 // &'static [u8]
		) // -> u64

{
	uint64_t rv;
	uint64_t var0;	// u64
	RUST_BOOL var1;	// bool
	uintptr_t var2;	// usize
	struct s_ZRG2cE9core0_0_03fmt9Arguments0g var3;	// ::"core-0_0_0"::fmt::Arguments<'#local0,>/*S*/
	t_ZRTfQBsCy2cE9core0_0_03fmt7Display0g_B0g var4 = {0};	// fn{<&'static str as ::"core-0_0_0"::fmt::Display>::fmt<'static,'static,>}
	t_ZRTF2BsBsCyBuG2cE9core0_0_03fmt9Formatter0gG2c_A6result6Result2gT0G2c_A_B5Error0g var5;	// for<'elided#0,'elided#1,> extern "Rust" fn(&'static &'static str, &'static mut ::"core-0_0_0"::fmt::Formatter<'static,>/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/
	struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g var6;	// ::"core-0_0_0"::fmt::ArgumentV1<'static,>/*S*/
	t_ZRTA1G2cE9core0_0_03fmt10ArgumentV10g var7;	// [::"core-0_0_0"::fmt::ArgumentV1<'static,>/*S*/; 1]
	t_ZRTA1G2cE9core0_0_03fmt10ArgumentV10g *var8;	// &'#local0 [::"core-0_0_0"::fmt::ArgumentV1<'static,>/*S*/; 1]
	struct s_ZRG2cE9core0_0_03fmt9Arguments0g *var9;	// &'#local1 ::"core-0_0_0"::fmt::Arguments<'#local0,>/*S*/
	tUNIT var10 = {0};	// ()
	uint8_t *var11;	// *const u8
	uint64_t *var12;	// &'#local4 mut u64
	uint64_t *var13;	// *mut u64
	uint8_t *var14;	// *mut u8
	tUNIT var15 = {0};	// ()
	SLICE_PTR var16;	// *const [u8]
	SLICE_PTR var17;	// *const [u8]
	struct e_ZRG2cE9core0_0_06option6Option1gBsSG4c_A3fmt2rt2v18Argument0g var18;	// ::"core-0_0_0"::option::Option<&'static [::"core-0_0_0"::fmt::rt::v1::Argument/*S*/],>/*E*/
	SLICE_PTR var19;	// &'static [&'static str]
	SLICE_PTR var20;	// &'#local0 [::"core-0_0_0"::fmt::ArgumentV1<'static,>/*S*/]
	var1 = true;	// _1 = Constant(true)
	var16 = arg0;	// _16 = Cast(a0 as *const [u8])
	var2 = var16.META;	// _2 = DstMeta(_16)
	var1 = 0x8ull <= var2;	// _1 = BinOp(0x8 usize LE _2)
	if(var1) goto bb1; else goto bb3;
	// ^ If( _1 : 1, 3)
bb1:
	var0 = 0x0ull;	// _0 = Constant(0x0 u64)
	var17 = arg0;	// _17 = Cast(a0 as *const [u8])
	var11 = (uint8_t *)var17.PTR;	// _11 = Cast(_17 as *const u8)
	var12 = & var0;	// _12 = Borrow(Unique, _0)
	var13 = (uint64_t *)var12;	// _13 = Cast(_12 as *mut u64)
	var14 = (uint8_t *)var13;	// _14 = Cast(_13 as *mut u8)
	memcpy( var14, var11, 0x8ull * sizeof(uint8_t ));
	// ^ Call( _15 = "copy_nonoverlapping"::<u8,>( _11, _14, 0x8 usize, ), bb2, bb5)
	rv = var0;	// retval = Use(_0)
	return rv;
	// ^ Return
bb3:
	var19 = make_sliceptr(&ZRG2cJ17byteorder1_2_3_H9C_439FRAGMENTS0g.val, 0x2ull);	// _19 = MakeDst(&::"byteorder-1_2_3_H9"::#43::FRAGMENTS, 0x2 usize)
	/* ZST assign */
	var5 = ZRQBsCy2cE9core0_0_03fmt7Display0g_B0g;	// _5 = Cast(_4 as for<'elided#0,'elided#1,> extern "Rust" fn(&'static &'static str, &'static mut ::"core-0_0_0"::fmt::Formatter<'static,>/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/)
	var6 = ZRIG2cE9core0_0_03fmt10ArgumentV10g3new1gBsCy( &ZRG1cJ17byteorder1_2_3_H9F7const810g.val, var5 );
	// ^ Call( _6 = <::"core-0_0_0"::fmt::ArgumentV1<'static,>/*S*/ /*- <'static,>*/>::new<'static,&'static str,>( &::"byteorder-1_2_3_H9"::const#81, _5, ), bb4, bb5)
	var7.DATA[0] = var6;	// _7 = Array(_6)
	var8 = & var7;	// _8 = Borrow(Shared, _7)
	var20 = make_sliceptr(var8, 0x1ull);	// _20 = MakeDst(_8, 0x1 usize)
	memset(&var18, 0, sizeof(struct e_ZRG2cE9core0_0_06option6Option1gBsSG4c_A3fmt2rt2v18Argument0g ));	// _18 = Variant(::"core-0_0_0"::option::Option<&'static [::"core-0_0_0"::fmt::rt::v1::Argument/*S*/],> #0, {})
	var3._0 = var19;
	var3._1 = var18;
	var3._2 = var20;	// _3 = Struct(::"core-0_0_0"::fmt::Arguments<'#local2,>, {_19, _18, _20})
	var9 = & var3;	// _9 = Borrow(Shared, _3)
	ZRG2cD8std0_0_09panicking15begin_panic_fmt0g( var9, &ZRG1cJ17byteorder1_2_3_H9F7const820g.val );
	// ^ Call( _10 = ::"std-0_0_0"::panicking::begin_panic_fmt<'#local6,'static,>( _9, &::"byteorder-1_2_3_H9"::const#82, ), bb5, bb5)
bb5: _Unwind_Resume(); // Diverge
}
// <::"core-0_0_0"::ops::range::Range<usize,>/*S*/ as ::"core-0_0_0"::slice::SliceIndex<[u8],>>::index<'#omitted,>
static SLICE_PTR  ZRQG3cE9core0_0_03ops5range5Range1gCu2c_A5slice10SliceIndex1gSCa5index0g(
		struct s_ZRG3cE9core0_0_03ops5range5Range1gCu arg0, // ::"core-0_0_0"::ops::range::Range<usize,>/*S*/
		SLICE_PTR arg1 // &'#omitted [u8]
		) // -> &'#omitted [u8]

{
	SLICE_PTR rv;
	RUST_BOOL var0;	// bool
	tBANG var1 = {0};	// !
	uintptr_t var2;	// usize
	tBANG var3 = {0};	// !
	SLICE_PTR var4;	// *const [u8]
	uintptr_t var5;	// usize
	SLICE_PTR var6;	// *const [u8]
	SLICE_PTR var7;	// *const [u8]
	uint8_t *var8;	// *const u8
	intptr_t var9;	// isize
	struct s_ZRG2cE9core0_0_05slice6FatPtr1gCa var10;	// ::"core-0_0_0"::slice::FatPtr<u8,>/*S*/
	union u_ZRG2cE9core0_0_05slice4Repr1gCa var11;	// ::"core-0_0_0"::slice::Repr<'static,u8,>/*U*/
	uint8_t *var12;	// *const u8
	uintptr_t var13;	// usize
	var0 = arg0._0 > arg0._1;	// _0 = BinOp(a0.0 GT a0.1)
	if(var0) goto bb1; else goto bb2;
	// ^ If( _0 : 1, 2)
bb1:
	ZRG2cE9core0_0_05slice22slice_index_order_fail0g( arg0._0, arg0._1 );
	goto bb6;
	// ^ Call( _1 = ::"core-0_0_0"::slice::slice_index_order_fail( a0.0, a0.1, ), bb6, bb6)
bb2:
	var4 = arg1;	// _4 = Cast(a1 as *const [u8])
	var2 = var4.META;	// _2 = DstMeta(_4)
	var0 = arg0._1 > var2;	// _0 = BinOp(a0.1 GT _2)
	if(var0) goto bb3; else goto bb4;
	// ^ If( _0 : 3, 4)
bb3:
	var6 = arg1;	// _6 = Cast(a1 as *const [u8])
	var5 = var6.META;	// _5 = DstMeta(_6)
	ZRG2cE9core0_0_05slice20slice_index_len_fail0g( arg0._1, var5 );
	goto bb6;
	// ^ Call( _3 = ::"core-0_0_0"::slice::slice_index_len_fail( a0.1, _5, ), bb6, bb6)
bb4:
	var7 = arg1;	// _7 = Cast(a1 as *const [u8])
	var8 = (uint8_t *)var7.PTR;	// _8 = Cast(_7 as *const u8)
	var9 = (intptr_t )arg0._0;	// _9 = Cast(a0.0 as isize)
	var12 = var8 + var9;
	// ^ Call( _12 = "offset"::<u8,>( _8, _9, ), bb5, bb6)
	var13 = arg0._1 - arg0._0;	// _13 = BinOp(a0.1 SUB a0.0)
	var10._0 = var12;
	var10._1 = var13;	// _10 = Struct(::"core-0_0_0"::slice::FatPtr<u8,>, {_12, _13})
	var11.var_2 = var10;	// _11 = UnionVariant(::"core-0_0_0"::slice::Repr<'static,u8,> #2, _10)
	rv = var11.var_0;	// retval = Use(_11#0)
	// ^ drop(_11)
	// ^ drop(a0)
	return rv;
	// ^ Return
bb6: _Unwind_Resume(); // Diverge
}
// <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::default::Default>::default
struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_07default7Default0g_D0g(void) // -> ::"rustc_hash-1_0_1"::FxHasher/*S*/

{
	struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g rv;
	rv._0 = 0x0ull;	// retval = Struct(::"rustc_hash-1_0_1"::FxHasher, {0x0 usize})
	return rv;
	// ^ Return
}
// <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::finish<'#omitted,>
uint64_t  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g6finish0g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0 // &'#omitted ::"rustc_hash-1_0_1"::FxHasher/*S*/
		) // -> u64

{
	uint64_t rv;
	rv = (uint64_t )arg0->_0;	// retval = Cast(a0*.0 as u64)
	return rv;
	// ^ Return
}
// <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write<'#omitted,'#omitted,>
void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g5write0g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		SLICE_PTR arg1 // &'#omitted [u8]
		) // -> ()

{
	tUNIT rv;
	struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g var0;	// ::"rustc_hash-1_0_1"::FxHasher/*S*/
	RUST_BOOL var1;	// bool
	uintptr_t var2;	// usize
	struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *var3;	// &'M0 mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
	uint64_t var4;	// u64
	struct s_ZRG3cE9core0_0_03ops5range9RangeFrom1gCu var5;	// ::"core-0_0_0"::ops::range::RangeFrom<usize,>/*S*/
	SLICE_PTR var6;	// &'M1 [u8]
	uintptr_t var7;	// usize
	struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *var8;	// &'M0 mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
	uint32_t var9;	// u32
	struct s_ZRG3cE9core0_0_03ops5range9RangeFrom1gCu var10;	// ::"core-0_0_0"::ops::range::RangeFrom<usize,>/*S*/
	SLICE_PTR var11;	// &'M1 [u8]
	uintptr_t var12;	// usize
	struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *var13;	// &'M0 mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
	uint16_t var14;	// u16
	struct s_ZRG3cE9core0_0_03ops5range9RangeFrom1gCu var15;	// ::"core-0_0_0"::ops::range::RangeFrom<usize,>/*S*/
	SLICE_PTR var16;	// &'M1 [u8]
	uintptr_t var17;	// usize
	struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *var18;	// &'M0 mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
	SLICE_PTR var19;	// *const [u8]
	uintptr_t var20;	// usize
	uintptr_t var21;	// usize
	uintptr_t var22;	// usize
	uintptr_t var23;	// usize
	uintptr_t var24;	// usize
	uintptr_t var25;	// usize
	SLICE_PTR var26;	// *const [u8]
	uintptr_t var27;	// usize
	uintptr_t var28;	// usize
	uintptr_t var29;	// usize
	uintptr_t var30;	// usize
	uintptr_t var31;	// usize
	uintptr_t var32;	// usize
	SLICE_PTR var33;	// *const [u8]
	uintptr_t var34;	// usize
	uintptr_t var35;	// usize
	uintptr_t var36;	// usize
	uintptr_t var37;	// usize
	uintptr_t var38;	// usize
	uintptr_t var39;	// usize
	uintptr_t var40;	// usize
	uintptr_t var41;	// usize
	uintptr_t var42;	// usize
	uintptr_t var43;	// usize
	uintptr_t var44;	// usize
	uintptr_t var45;	// usize
	SLICE_PTR var46;	// *const [u8]
	struct s_ZRG3cE9core0_0_03ops5range5Range1gCu var47;	// ::"core-0_0_0"::ops::range::Range<usize,>/*S*/
	uintptr_t var48;	// usize
	SLICE_PTR var49;	// *const [u8]
	SLICE_PTR var50;	// &'M1 [u8]
	struct s_ZRG3cE9core0_0_03ops5range5Range1gCu var51;	// ::"core-0_0_0"::ops::range::Range<usize,>/*S*/
	uintptr_t var52;	// usize
	SLICE_PTR var53;	// *const [u8]
	SLICE_PTR var54;	// &'M1 [u8]
	struct s_ZRG3cE9core0_0_03ops5range5Range1gCu var55;	// ::"core-0_0_0"::ops::range::Range<usize,>/*S*/
	uintptr_t var56;	// usize
	SLICE_PTR var57;	// *const [u8]
	SLICE_PTR var58;	// &'M1 [u8]
	var0._0 = arg0->_0;	// _0 = Struct(::"rustc_hash-1_0_1"::FxHasher, {a0*.0})
	var1 = true;	// _1 = Constant(true)
	// ^ Goto(1)
bb1:
	var19 = arg1;	// _19 = Cast(a1 as *const [u8])
	var2 = var19.META;	// _2 = DstMeta(_19)
	var1 = var2 >= 0x8ull;	// _1 = BinOp(_2 GE 0x8 usize)
	if(var1) goto bb2; else goto bb6;
	// ^ If( _1 : 2, 6)
bb2:
	var3 = & var0;	// _3 = Borrow(Unique, _0)
	var4 = ZRQG1cJ17byteorder1_2_3_H912LittleEndian0g1c_A9ByteOrder0g8read_u640g( arg1 );
	// ^ Call( _4 = <::"byteorder-1_2_3_H9"::LittleEndian/*E*/ as ::"byteorder-1_2_3_H9"::ByteOrder>::read_u64<'static,>( a1, ), bb3, bb20)
	var25 = (uintptr_t )var4;	// _25 = Cast(_4 as usize)
	var22 = var3->_0;	// _22 = Use(_3*.0)
	var20 = var22 << 0x5;	// _20 = BinOp(_22 BIT_SHL 0x5 u32)
	var21 = var22 >> 0x3b;	// _21 = BinOp(_22 BIT_SHR 0x3b u32)
	var23 = var20 | var21;	// _23 = BinOp(_20 BIT_OR _21)
	var24 = var23 ^ var25;	// _24 = BinOp(_23 BIT_XOR _25)
	__builtin_mul_overflow(var24, 0x517cc1b727220a95ull, &var3->_0);
	// ^ Call( _3*.0 = "overflowing_mul"::<usize,>( _24, 0x517cc1b727220a95 usize, ), bb4, bb20)
	// ^ drop(_3)
	var50 = arg1;	// _50 = Borrow(Shared, a1*)
	var5._0 = 0x8ull;	// _5 = Struct(::"core-0_0_0"::ops::range::RangeFrom<usize,>, {0x8 usize})
	var49 = var50;	// _49 = Cast(_50 as *const [u8])
	var48 = var49.META;	// _48 = DstMeta(_49)
	var47._0 = var5._0;
	var47._1 = var48;	// _47 = Struct(::"core-0_0_0"::ops::range::Range<usize,>, {_5.0, _48})
	var6 = ZRQG3cE9core0_0_03ops5range5Range1gCu2c_A5slice10SliceIndex1gSCa5index0g( var47, var50 );
	// ^ Call( _6 = <::"core-0_0_0"::ops::range::Range<usize,>/*S*/ as ::"core-0_0_0"::slice::SliceIndex<[u8],>>::index<'#omitted,>( _47, _50, ), bb5, bb20)
	// ^ drop(_5)
	arg1 = var6;	// a1 = Borrow(Shared, _6*)
	goto bb1;
	// ^ Goto(1)
bb6:
	var1 = true;	// _1 = Constant(true)
	var26 = arg1;	// _26 = Cast(a1 as *const [u8])
	var7 = var26.META;	// _7 = DstMeta(_26)
	var1 = var7 >= 0x4ull;	// _1 = BinOp(_7 GE 0x4 usize)
	if(var1) goto bb7; else goto bb11;
	// ^ If( _1 : 7, 11)
bb7:
	var8 = & var0;	// _8 = Borrow(Unique, _0)
	var9 = ZRQG1cJ17byteorder1_2_3_H912LittleEndian0g1c_A9ByteOrder0g8read_u320g( arg1 );
	// ^ Call( _9 = <::"byteorder-1_2_3_H9"::LittleEndian/*E*/ as ::"byteorder-1_2_3_H9"::ByteOrder>::read_u32<'M1,>( a1, ), bb8, bb20)
	var32 = (uintptr_t )var9;	// _32 = Cast(_9 as usize)
	var29 = var8->_0;	// _29 = Use(_8*.0)
	var27 = var29 << 0x5;	// _27 = BinOp(_29 BIT_SHL 0x5 u32)
	var28 = var29 >> 0x3b;	// _28 = BinOp(_29 BIT_SHR 0x3b u32)
	var30 = var27 | var28;	// _30 = BinOp(_27 BIT_OR _28)
	var31 = var30 ^ var32;	// _31 = BinOp(_30 BIT_XOR _32)
	__builtin_mul_overflow(var31, 0x517cc1b727220a95ull, &var8->_0);
	// ^ Call( _8*.0 = "overflowing_mul"::<usize,>( _31, 0x517cc1b727220a95 usize, ), bb9, bb20)
	// ^ drop(_8)
	var54 = arg1;	// _54 = Borrow(Shared, a1*)
	var10._0 = 0x4ull;	// _10 = Struct(::"core-0_0_0"::ops::range::RangeFrom<usize,>, {0x4 usize})
	var53 = var54;	// _53 = Cast(_54 as *const [u8])
	var52 = var53.META;	// _52 = DstMeta(_53)
	var51._0 = var10._0;
	var51._1 = var52;	// _51 = Struct(::"core-0_0_0"::ops::range::Range<usize,>, {_10.0, _52})
	var11 = ZRQG3cE9core0_0_03ops5range5Range1gCu2c_A5slice10SliceIndex1gSCa5index0g( var51, var54 );
	// ^ Call( _11 = <::"core-0_0_0"::ops::range::Range<usize,>/*S*/ as ::"core-0_0_0"::slice::SliceIndex<[u8],>>::index<'#omitted,>( _51, _54, ), bb10, bb20)
	// ^ drop(_10)
	arg1 = var11;	// a1 = Borrow(Shared, _11*)
	// ^ Goto(11)
bb11:
	var1 = true;	// _1 = Constant(true)
	var33 = arg1;	// _33 = Cast(a1 as *const [u8])
	var12 = var33.META;	// _12 = DstMeta(_33)
	var1 = var12 >= 0x2ull;	// _1 = BinOp(_12 GE 0x2 usize)
	if(var1) goto bb12; else goto bb16;
	// ^ If( _1 : 12, 16)
bb12:
	var13 = & var0;	// _13 = Borrow(Unique, _0)
	var14 = ZRQG1cJ17byteorder1_2_3_H912LittleEndian0g1c_A9ByteOrder0g8read_u160g( arg1 );
	// ^ Call( _14 = <::"byteorder-1_2_3_H9"::LittleEndian/*E*/ as ::"byteorder-1_2_3_H9"::ByteOrder>::read_u16<'M1,>( a1, ), bb13, bb20)
	var39 = (uintptr_t )var14;	// _39 = Cast(_14 as usize)
	var36 = var13->_0;	// _36 = Use(_13*.0)
	var34 = var36 << 0x5;	// _34 = BinOp(_36 BIT_SHL 0x5 u32)
	var35 = var36 >> 0x3b;	// _35 = BinOp(_36 BIT_SHR 0x3b u32)
	var37 = var34 | var35;	// _37 = BinOp(_34 BIT_OR _35)
	var38 = var37 ^ var39;	// _38 = BinOp(_37 BIT_XOR _39)
	__builtin_mul_overflow(var38, 0x517cc1b727220a95ull, &var13->_0);
	// ^ Call( _13*.0 = "overflowing_mul"::<usize,>( _38, 0x517cc1b727220a95 usize, ), bb14, bb20)
	// ^ drop(_13)
	var58 = arg1;	// _58 = Borrow(Shared, a1*)
	var15._0 = 0x2ull;	// _15 = Struct(::"core-0_0_0"::ops::range::RangeFrom<usize,>, {0x2 usize})
	var57 = var58;	// _57 = Cast(_58 as *const [u8])
	var56 = var57.META;	// _56 = DstMeta(_57)
	var55._0 = var15._0;
	var55._1 = var56;	// _55 = Struct(::"core-0_0_0"::ops::range::Range<usize,>, {_15.0, _56})
	var16 = ZRQG3cE9core0_0_03ops5range5Range1gCu2c_A5slice10SliceIndex1gSCa5index0g( var55, var58 );
	// ^ Call( _16 = <::"core-0_0_0"::ops::range::Range<usize,>/*S*/ as ::"core-0_0_0"::slice::SliceIndex<[u8],>>::index<'#omitted,>( _55, _58, ), bb15, bb20)
	// ^ drop(_15)
	arg1 = var16;	// a1 = Borrow(Shared, _16*)
	// ^ Goto(16)
bb16:
	var1 = true;	// _1 = Constant(true)
	var46 = arg1;	// _46 = Cast(a1 as *const [u8])
	var17 = var46.META;	// _17 = DstMeta(_46)
	var1 = var17 >= 0x1ull;	// _1 = BinOp(_17 GE 0x1 usize)
	if(var1) goto bb17; else goto bb19;
	// ^ If( _1 : 17, 19)
bb17:
	var18 = & var0;	// _18 = Borrow(Unique, _0)
	var45 = (uintptr_t )((uint8_t *)arg1.PTR)[0];	// _45 = Cast(a1*.0 as usize)
	var42 = var18->_0;	// _42 = Use(_18*.0)
	var40 = var42 << 0x5;	// _40 = BinOp(_42 BIT_SHL 0x5 u32)
	var41 = var42 >> 0x3b;	// _41 = BinOp(_42 BIT_SHR 0x3b u32)
	var43 = var40 | var41;	// _43 = BinOp(_40 BIT_OR _41)
	var44 = var43 ^ var45;	// _44 = BinOp(_43 BIT_XOR _45)
	__builtin_mul_overflow(var44, 0x517cc1b727220a95ull, &var18->_0);
	// ^ Call( _18*.0 = "overflowing_mul"::<usize,>( _44, 0x517cc1b727220a95 usize, ), bb18, bb20)
	// ^ drop(_18)
	// ^ Goto(19)
bb19:
	arg0->_0 = var0._0;	// a0*.0 = Use(_0.0)
	// ^ drop(_0)
	/* ZST assign */
	// ^ drop(a0)
	return ;
	// ^ Return
bb20: _Unwind_Resume(); // Diverge
}
// <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_i128<'#omitted,>
static void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g10write_i1280g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		int128_t arg1 // i128
		) // -> ()

{
	tUNIT rv;
	uint128_t var0;	// u128
	var0 = (uint128_t )arg1;	// _0 = Cast(a1 as u128)
	ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g10write_u1280g( arg0, var0 );
	// ^ Call( retval = <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_u128<'#omitted,>( a0, _0, ), bb1, bb2)
	return ;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_i16<'#omitted,>
static void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g9write_i160g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		int16_t arg1 // i16
		) // -> ()

{
	tUNIT rv;
	uintptr_t var0;	// usize
	uintptr_t var1;	// usize
	uintptr_t var2;	// usize
	uintptr_t var3;	// usize
	uintptr_t var4;	// usize
	uintptr_t var5;	// usize
	uint16_t var6;	// u16
	var6 = (uint16_t )arg1;	// _6 = Cast(a1 as u16)
	var5 = (uintptr_t )var6;	// _5 = Cast(_6 as usize)
	var2 = arg0->_0;	// _2 = Use(a0*.0)
	var0 = var2 << 0x5;	// _0 = BinOp(_2 BIT_SHL 0x5 u32)
	var1 = var2 >> 0x3b;	// _1 = BinOp(_2 BIT_SHR 0x3b u32)
	var3 = var0 | var1;	// _3 = BinOp(_0 BIT_OR _1)
	var4 = var3 ^ var5;	// _4 = BinOp(_3 BIT_XOR _5)
	__builtin_mul_overflow(var4, 0x517cc1b727220a95ull, &arg0->_0);
	// ^ Call( a0*.0 = "overflowing_mul"::<usize,>( _4, 0x517cc1b727220a95 usize, ), bb1, bb2)
	// ^ drop(a0)
	/* ZST assign */
	return ;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_i32<'#omitted,>
static void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g9write_i320g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		int32_t arg1 // i32
		) // -> ()

{
	tUNIT rv;
	uintptr_t var0;	// usize
	uintptr_t var1;	// usize
	uintptr_t var2;	// usize
	uintptr_t var3;	// usize
	uintptr_t var4;	// usize
	uintptr_t var5;	// usize
	uint32_t var6;	// u32
	var6 = (uint32_t )arg1;	// _6 = Cast(a1 as u32)
	var5 = (uintptr_t )var6;	// _5 = Cast(_6 as usize)
	var2 = arg0->_0;	// _2 = Use(a0*.0)
	var0 = var2 << 0x5;	// _0 = BinOp(_2 BIT_SHL 0x5 u32)
	var1 = var2 >> 0x3b;	// _1 = BinOp(_2 BIT_SHR 0x3b u32)
	var3 = var0 | var1;	// _3 = BinOp(_0 BIT_OR _1)
	var4 = var3 ^ var5;	// _4 = BinOp(_3 BIT_XOR _5)
	__builtin_mul_overflow(var4, 0x517cc1b727220a95ull, &arg0->_0);
	// ^ Call( a0*.0 = "overflowing_mul"::<usize,>( _4, 0x517cc1b727220a95 usize, ), bb1, bb2)
	// ^ drop(a0)
	/* ZST assign */
	return ;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_i64<'#omitted,>
static void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g9write_i640g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		int64_t arg1 // i64
		) // -> ()

{
	tUNIT rv;
	uintptr_t var0;	// usize
	uintptr_t var1;	// usize
	uintptr_t var2;	// usize
	uintptr_t var3;	// usize
	uintptr_t var4;	// usize
	uintptr_t var5;	// usize
	uint64_t var6;	// u64
	var6 = (uint64_t )arg1;	// _6 = Cast(a1 as u64)
	var5 = (uintptr_t )var6;	// _5 = Cast(_6 as usize)
	var2 = arg0->_0;	// _2 = Use(a0*.0)
	var0 = var2 << 0x5;	// _0 = BinOp(_2 BIT_SHL 0x5 u32)
	var1 = var2 >> 0x3b;	// _1 = BinOp(_2 BIT_SHR 0x3b u32)
	var3 = var0 | var1;	// _3 = BinOp(_0 BIT_OR _1)
	var4 = var3 ^ var5;	// _4 = BinOp(_3 BIT_XOR _5)
	__builtin_mul_overflow(var4, 0x517cc1b727220a95ull, &arg0->_0);
	// ^ Call( a0*.0 = "overflowing_mul"::<usize,>( _4, 0x517cc1b727220a95 usize, ), bb1, bb2)
	// ^ drop(a0)
	/* ZST assign */
	return ;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_i8<'#omitted,>
static void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g8write_i80g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		int8_t arg1 // i8
		) // -> ()

{
	tUNIT rv;
	uintptr_t var0;	// usize
	uintptr_t var1;	// usize
	uintptr_t var2;	// usize
	uintptr_t var3;	// usize
	uintptr_t var4;	// usize
	uintptr_t var5;	// usize
	uint8_t var6;	// u8
	var6 = (uint8_t )arg1;	// _6 = Cast(a1 as u8)
	var5 = (uintptr_t )var6;	// _5 = Cast(_6 as usize)
	var2 = arg0->_0;	// _2 = Use(a0*.0)
	var0 = var2 << 0x5;	// _0 = BinOp(_2 BIT_SHL 0x5 u32)
	var1 = var2 >> 0x3b;	// _1 = BinOp(_2 BIT_SHR 0x3b u32)
	var3 = var0 | var1;	// _3 = BinOp(_0 BIT_OR _1)
	var4 = var3 ^ var5;	// _4 = BinOp(_3 BIT_XOR _5)
	__builtin_mul_overflow(var4, 0x517cc1b727220a95ull, &arg0->_0);
	// ^ Call( a0*.0 = "overflowing_mul"::<usize,>( _4, 0x517cc1b727220a95 usize, ), bb1, bb2)
	// ^ drop(a0)
	/* ZST assign */
	return ;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_isize<'#omitted,>
static void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g11write_isize0g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		intptr_t arg1 // isize
		) // -> ()

{
	tUNIT rv;
	uintptr_t var0;	// usize
	uintptr_t var1;	// usize
	uintptr_t var2;	// usize
	uintptr_t var3;	// usize
	uintptr_t var4;	// usize
	uintptr_t var5;	// usize
	var5 = (uintptr_t )arg1;	// _5 = Cast(a1 as usize)
	var2 = arg0->_0;	// _2 = Use(a0*.0)
	var0 = var2 << 0x5;	// _0 = BinOp(_2 BIT_SHL 0x5 u32)
	var1 = var2 >> 0x3b;	// _1 = BinOp(_2 BIT_SHR 0x3b u32)
	var3 = var0 | var1;	// _3 = BinOp(_0 BIT_OR _1)
	var4 = var3 ^ var5;	// _4 = BinOp(_3 BIT_XOR _5)
	__builtin_mul_overflow(var4, 0x517cc1b727220a95ull, &arg0->_0);
	// ^ Call( a0*.0 = "overflowing_mul"::<usize,>( _4, 0x517cc1b727220a95 usize, ), bb1, bb2)
	// ^ drop(a0)
	/* ZST assign */
	return ;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_u128<'#omitted,>
static void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g10write_u1280g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		uint128_t arg1 // u128
		) // -> ()

{
	tUNIT rv;
	t_ZRTA16Ca var0;	// [u8; 16]
	t_ZRTA16Ca *var1;	// &'#local0 [u8; 16]
	SLICE_PTR var2;	// &'#local0 [u8]
	memcpy( &var0, &arg1, sizeof(uint128_t ));
	// ^ Call( _0 = "transmute"::<u128,[u8; 16],>( a1, ), bb1, bb3)
	var1 = & var0;	// _1 = Borrow(Shared, _0)
	var2 = make_sliceptr(var1, 0x10ull);	// _2 = MakeDst(_1, 0x10 usize)
	ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g5write0g( arg0, var2 );
	// ^ Call( retval = <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write<'#omitted,'#local0,>( a0, _2, ), bb2, bb3)
	return ;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_u16<'#omitted,>
void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g9write_u160g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		uint16_t arg1 // u16
		) // -> ()

{
	tUNIT rv;
	uintptr_t var0;	// usize
	uintptr_t var1;	// usize
	uintptr_t var2;	// usize
	uintptr_t var3;	// usize
	uintptr_t var4;	// usize
	uintptr_t var5;	// usize
	var5 = (uintptr_t )arg1;	// _5 = Cast(a1 as usize)
	var2 = arg0->_0;	// _2 = Use(a0*.0)
	var0 = var2 << 0x5;	// _0 = BinOp(_2 BIT_SHL 0x5 u32)
	var1 = var2 >> 0x3b;	// _1 = BinOp(_2 BIT_SHR 0x3b u32)
	var3 = var0 | var1;	// _3 = BinOp(_0 BIT_OR _1)
	var4 = var3 ^ var5;	// _4 = BinOp(_3 BIT_XOR _5)
	__builtin_mul_overflow(var4, 0x517cc1b727220a95ull, &arg0->_0);
	// ^ Call( a0*.0 = "overflowing_mul"::<usize,>( _4, 0x517cc1b727220a95 usize, ), bb1, bb2)
	// ^ drop(a0)
	/* ZST assign */
	return ;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_u32<'#omitted,>
void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g9write_u320g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		uint32_t arg1 // u32
		) // -> ()

{
	tUNIT rv;
	uintptr_t var0;	// usize
	uintptr_t var1;	// usize
	uintptr_t var2;	// usize
	uintptr_t var3;	// usize
	uintptr_t var4;	// usize
	uintptr_t var5;	// usize
	var5 = (uintptr_t )arg1;	// _5 = Cast(a1 as usize)
	var2 = arg0->_0;	// _2 = Use(a0*.0)
	var0 = var2 << 0x5;	// _0 = BinOp(_2 BIT_SHL 0x5 u32)
	var1 = var2 >> 0x3b;	// _1 = BinOp(_2 BIT_SHR 0x3b u32)
	var3 = var0 | var1;	// _3 = BinOp(_0 BIT_OR _1)
	var4 = var3 ^ var5;	// _4 = BinOp(_3 BIT_XOR _5)
	__builtin_mul_overflow(var4, 0x517cc1b727220a95ull, &arg0->_0);
	// ^ Call( a0*.0 = "overflowing_mul"::<usize,>( _4, 0x517cc1b727220a95 usize, ), bb1, bb2)
	// ^ drop(a0)
	/* ZST assign */
	return ;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_u64<'#omitted,>
void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g9write_u640g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		uint64_t arg1 // u64
		) // -> ()

{
	tUNIT rv;
	uintptr_t var0;	// usize
	uintptr_t var1;	// usize
	uintptr_t var2;	// usize
	uintptr_t var3;	// usize
	uintptr_t var4;	// usize
	uintptr_t var5;	// usize
	var5 = (uintptr_t )arg1;	// _5 = Cast(a1 as usize)
	var2 = arg0->_0;	// _2 = Use(a0*.0)
	var0 = var2 << 0x5;	// _0 = BinOp(_2 BIT_SHL 0x5 u32)
	var1 = var2 >> 0x3b;	// _1 = BinOp(_2 BIT_SHR 0x3b u32)
	var3 = var0 | var1;	// _3 = BinOp(_0 BIT_OR _1)
	var4 = var3 ^ var5;	// _4 = BinOp(_3 BIT_XOR _5)
	__builtin_mul_overflow(var4, 0x517cc1b727220a95ull, &arg0->_0);
	// ^ Call( a0*.0 = "overflowing_mul"::<usize,>( _4, 0x517cc1b727220a95 usize, ), bb1, bb2)
	// ^ drop(a0)
	/* ZST assign */
	return ;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_u8<'#omitted,>
void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g8write_u80g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		uint8_t arg1 // u8
		) // -> ()

{
	tUNIT rv;
	uintptr_t var0;	// usize
	uintptr_t var1;	// usize
	uintptr_t var2;	// usize
	uintptr_t var3;	// usize
	uintptr_t var4;	// usize
	uintptr_t var5;	// usize
	var5 = (uintptr_t )arg1;	// _5 = Cast(a1 as usize)
	var2 = arg0->_0;	// _2 = Use(a0*.0)
	var0 = var2 << 0x5;	// _0 = BinOp(_2 BIT_SHL 0x5 u32)
	var1 = var2 >> 0x3b;	// _1 = BinOp(_2 BIT_SHR 0x3b u32)
	var3 = var0 | var1;	// _3 = BinOp(_0 BIT_OR _1)
	var4 = var3 ^ var5;	// _4 = BinOp(_3 BIT_XOR _5)
	__builtin_mul_overflow(var4, 0x517cc1b727220a95ull, &arg0->_0);
	// ^ Call( a0*.0 = "overflowing_mul"::<usize,>( _4, 0x517cc1b727220a95 usize, ), bb1, bb2)
	// ^ drop(a0)
	/* ZST assign */
	return ;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"rustc_hash-1_0_1"::FxHasher/*S*/ as ::"core-0_0_0"::hash::Hasher>::write_usize<'#omitted,>
void  ZRQG1cK15rustc_hash1_0_18FxHasher0g2cE9core0_0_04hash6Hasher0g11write_usize0g(
		struct s_ZRG1cK15rustc_hash1_0_18FxHasher0g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::FxHasher/*S*/
		uintptr_t arg1 // usize
		) // -> ()

{
	tUNIT rv;
	uintptr_t var0;	// usize
	uintptr_t var1;	// usize
	uintptr_t var2;	// usize
	uintptr_t var3;	// usize
	uintptr_t var4;	// usize
	var2 = arg0->_0;	// _2 = Use(a0*.0)
	var0 = var2 << 0x5;	// _0 = BinOp(_2 BIT_SHL 0x5 u32)
	var1 = var2 >> 0x3b;	// _1 = BinOp(_2 BIT_SHR 0x3b u32)
	var3 = var0 | var1;	// _3 = BinOp(_0 BIT_OR _1)
	var4 = var3 ^ arg1;	// _4 = BinOp(_3 BIT_XOR a1)
	__builtin_mul_overflow(var4, 0x517cc1b727220a95ull, &arg0->_0);
	// ^ Call( a0*.0 = "overflowing_mul"::<usize,>( _4, 0x517cc1b727220a95 usize, ), bb1, bb2)
	// ^ drop(a0)
	/* ZST assign */
	return ;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"rustc_hash-1_0_1"::closure#I_write_0<'#omitted,>/*S*/ as ::"core-0_0_0"::ops::function::Fn<(&'#omitted [u8], ),>>::call<'#omitted,>
uint64_t  ZRQG1cK15rustc_hash1_0_1H16closureI_write_00g3cE9core0_0_03ops8function2Fn1gT1BsSCa4call0g(
		struct s_ZRG1cK15rustc_hash1_0_1H16closureI_write_00g *arg0, // &'#omitted ::"rustc_hash-1_0_1"::closure#I_write_0<'#omitted,>/*S*/
		TUP_1_ZRTBsSCa arg1 // (&'#omitted [u8], )
		) // -> u64

{
	uint64_t rv;
	rv = ZRQG1cJ17byteorder1_2_3_H912LittleEndian0g1c_A9ByteOrder0g8read_u640g( arg1._0 );
	// ^ Call( retval = <::"byteorder-1_2_3_H9"::LittleEndian/*E*/ as ::"byteorder-1_2_3_H9"::ByteOrder>::read_u64<'static,>( a1.0, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"rustc_hash-1_0_1"::closure#I_write_0<'#omitted,>/*S*/ as ::"core-0_0_0"::ops::function::FnMut<(&'#omitted [u8], ),>>::call_mut<'#omitted,>
uint64_t  ZRQG1cK15rustc_hash1_0_1H16closureI_write_00g3cE9core0_0_03ops8function5FnMut1gT1BsSCa8call_mut0g(
		struct s_ZRG1cK15rustc_hash1_0_1H16closureI_write_00g *arg0, // &'#omitted mut ::"rustc_hash-1_0_1"::closure#I_write_0<'#omitted,>/*S*/
		TUP_1_ZRTBsSCa arg1 // (&'#omitted [u8], )
		) // -> u64

{
	uint64_t rv;
	rv = ZRQG1cJ17byteorder1_2_3_H912LittleEndian0g1c_A9ByteOrder0g8read_u640g( arg1._0 );
	// ^ Call( retval = <::"byteorder-1_2_3_H9"::LittleEndian/*E*/ as ::"byteorder-1_2_3_H9"::ByteOrder>::read_u64<'static,>( a1.0, ), bb1, bb2)
	// ^ drop(a0)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"rustc_hash-1_0_1"::closure#I_write_0<'#omitted,>/*S*/ as ::"core-0_0_0"::ops::function::FnOnce<(&'#omitted [u8], ),>>::call_once
uint64_t  ZRQG1cK15rustc_hash1_0_1H16closureI_write_00g3cE9core0_0_03ops8function6FnOnce1gT1BsSCa9call_once0g(
		struct s_ZRG1cK15rustc_hash1_0_1H16closureI_write_00g arg0, // ::"rustc_hash-1_0_1"::closure#I_write_0<'#omitted,>/*S*/
		TUP_1_ZRTBsSCa arg1 // (&'#omitted [u8], )
		) // -> u64

{
	uint64_t rv;
	rv = ZRQG1cJ17byteorder1_2_3_H912LittleEndian0g1c_A9ByteOrder0g8read_u640g( arg1._0 );
	// ^ Call( retval = <::"byteorder-1_2_3_H9"::LittleEndian/*E*/ as ::"byteorder-1_2_3_H9"::ByteOrder>::read_u64<'static,>( a1.0, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <&'static str as ::"core-0_0_0"::fmt::Display>::fmt<'static,'static,>
static struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g  ZRQBsCy2cE9core0_0_03fmt7Display0g_B0g(
		SLICE_PTR *arg0, // &'static &'static str
		struct s_ZRG2cE9core0_0_03fmt9Formatter0g *arg1 // &'static mut ::"core-0_0_0"::fmt::Formatter<'static,>/*S*/
		) // -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/

{
	struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g rv;
	SLICE_PTR var0;	// &'static str
	var0 = (*arg0);	// _0 = Borrow(Shared, a0**)
	rv = ZRQCy2cE9core0_0_03fmt7Display0g_B0g( var0, arg1 );
	// ^ Call( retval = <str as ::"core-0_0_0"::fmt::Display>::fmt<'static,'static,>( _0, a1, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
